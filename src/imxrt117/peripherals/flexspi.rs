#![allow(non_snake_case, non_upper_case_globals)]
#![allow(non_camel_case_types)]
//! FlexSPI
//!
//! Used by: imxrt1176_cm4, imxrt1176_cm7

use crate::{RORegister, RWRegister, WORegister};

/// Module Control Register 0
pub mod MCR0 {

    /// Software Reset
    pub mod SWRESET {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Module Disable
    pub mod MDIS {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sample Clock source selection for Flash Reading
    pub mod RXCLKSRC {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (2 bits: 0b11 << 4)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Dummy Read strobe generated by FlexSPI Controller and loopback internally.
            pub const RXCLKSRC_0: u32 = 0b00;

            /// 0b01: Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
            pub const RXCLKSRC_1: u32 = 0b01;

            /// 0b11: Flash provided Read strobe and input from DQS pad
            pub const RXCLKSRC_3: u32 = 0b11;
        }
    }

    /// Enable AHB bus Read Access to IP RX FIFO.
    pub mod ARDFEN {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.
            pub const ARDFEN_0: u32 = 0b0;

            /// 0b1: IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.
            pub const ARDFEN_1: u32 = 0b1;
        }
    }

    /// Enable AHB bus Write Access to IP TX FIFO.
    pub mod ATDFEN {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.
            pub const ATDFEN_0: u32 = 0b0;

            /// 0b1: IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.
            pub const ATDFEN_1: u32 = 0b1;
        }
    }

    /// The serial root clock could be divided inside FlexSPI . Refer Clocks chapter for more details on clocking.
    pub mod SERCLKDIV {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (3 bits: 0b111 << 8)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b000: Divided by 1
            pub const SERCLKDIV_0: u32 = 0b000;

            /// 0b001: Divided by 2
            pub const SERCLKDIV_1: u32 = 0b001;

            /// 0b010: Divided by 3
            pub const SERCLKDIV_2: u32 = 0b010;

            /// 0b011: Divided by 4
            pub const SERCLKDIV_3: u32 = 0b011;

            /// 0b100: Divided by 5
            pub const SERCLKDIV_4: u32 = 0b100;

            /// 0b101: Divided by 6
            pub const SERCLKDIV_5: u32 = 0b101;

            /// 0b110: Divided by 7
            pub const SERCLKDIV_6: u32 = 0b110;

            /// 0b111: Divided by 8
            pub const SERCLKDIV_7: u32 = 0b111;
        }
    }

    /// Half Speed Serial Flash access Enable.
    pub mod HSEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable divide by 2 of serial flash clock for half speed commands.
            pub const HSEN_0: u32 = 0b0;

            /// 0b1: Enable divide by 2 of serial flash clock for half speed commands.
            pub const HSEN_1: u32 = 0b1;
        }
    }

    /// Doze mode enable bit
    pub mod DOZEEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.
            pub const DOZEEN_0: u32 = 0b0;

            /// 0b1: Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.
            pub const DOZEEN_1: u32 = 0b1;
        }
    }

    /// This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\[3:0\] and B_DATA\[3:0\]), when Port A and Port B are of 4 bit data width.
    pub mod COMBINATIONEN {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable.
            pub const COMBINATIONEN_0: u32 = 0b0;

            /// 0b1: Enable.
            pub const COMBINATIONEN_1: u32 = 0b1;
        }
    }

    /// This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\[RXCLKSRC\]=2).
    pub mod SCKFREERUNEN {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable.
            pub const SCKFREERUNEN_0: u32 = 0b0;

            /// 0b1: Enable.
            pub const SCKFREERUNEN_1: u32 = 0b1;
        }
    }

    /// Time out wait cycle for IP command grant.
    pub mod IPGRANTWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Timeout wait cycle for AHB command grant.
    pub mod AHBGRANTWAIT {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Module Control Register 1
pub mod MCR1 {

    /// AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmitted after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
    pub mod AHBBUSWAIT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
    pub mod SEQWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Module Control Register 2
pub mod MCR2 {

    /// This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automatically when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
    pub mod CLRAHBBUFOPT {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return Stop mode ACK.
            pub const CLRAHBBUFOPT_0: u32 = 0b0;

            /// 0b1: AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop mode ACK.
            pub const CLRAHBBUFOPT_1: u32 = 0b1;
        }
    }

    /// All external devices are same devices (both in types and size) for A1/A2/B1/B2.
    pub mod SAMEDEVICEEN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 separately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register settings will be ignored.
            pub const individual_parallel: u32 = 0b0;

            /// 0b1: FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// B_SCLK pad can be used as A_SCLK differential clock output (inverted clock to A_SCLK). In this case, port B flash access is not available. After changing the value of this field, MCR0\[SWRESET\] should be set.
    pub mod SCKBDIFFOPT {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: B_SCLK pad is used as port B SCLK clock output. Port B flash access is available.
            pub const SCKBDIFFOPT_0: u32 = 0b0;

            /// 0b1: B_SCLK pad is used as port A SCLK inverted clock output (Differential clock to A_SCLK). Port B flash access is not available.
            pub const SCKBDIFFOPT_1: u32 = 0b1;
        }
    }

    /// Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
    pub mod RESUMEWAIT {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB Bus Control Register
pub mod AHBCR {

    /// Parallel mode enabled for AHB triggered Command (both read and write) .
    pub mod APAREN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Flash will be accessed in Individual mode.
            pub const individual: u32 = 0b0;

            /// 0b1: Flash will be accessed in Parallel mode.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Clear the status/pointers of AHB RX Buffer. Auto-cleared.
    pub mod CLRAHBRXBUF {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Enable AHB bus cachable read access support.
    pub mod CACHABLEEN {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.
            pub const CACHABLEEN_0: u32 = 0b0;

            /// 0b1: Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.
            pub const CACHABLEEN_1: u32 = 0b1;
        }
    }

    /// Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
    pub mod BUFFERABLEEN {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disabled. For all AHB write access (no matter bufferable or non-bufferable ), FlexSPI will return AHB Bus ready after all data is transmitted to External device and AHB command finished.
            pub const BUFFERABLEEN_0: u32 = 0b0;

            /// 0b1: Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.
            pub const BUFFERABLEEN_1: u32 = 0b1;
        }
    }

    /// AHB Read Prefetch Enable.
    pub mod PREFETCHEN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
    pub mod READADDROPT {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is word-addressable.
            pub const READADDROPT_0: u32 = 0b0;

            /// 0b1: There is no AHB read burst start address alignment limitation. FlexSPI will fetch more data than AHB burst required to meet the alignment requirement.
            pub const READADDROPT_1: u32 = 0b1;
        }
    }

    /// AHB Read Size Alignment
    pub mod READSZALIGN {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB read size will be decided by other register setting like PREFETCH_EN,OTFAD_EN...
            pub const READSZALIGN_0: u32 = 0b0;

            /// 0b1: AHB read size to up size to 8 bytes aligned, no prefetching
            pub const READSZALIGN_1: u32 = 0b1;
        }
    }

    /// AHB Read ECC Enable
    pub mod ECCEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB read ECC check disabled
            pub const ECCEN_0: u32 = 0b0;

            /// 0b1: AHB read ECC check enabled
            pub const ECCEN_1: u32 = 0b1;
        }
    }

    /// AHB transaction SPLIT
    pub mod SPLITEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB Split disabled
            pub const SPLITEN_0: u32 = 0b0;

            /// 0b1: AHB Split enabled
            pub const SPLITEN_1: u32 = 0b1;
        }
    }

    /// AHB SPLIT SIZE
    pub mod SPLIT_LIMIT {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (2 bits: 0b11 << 13)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: AHB Split Size=8bytes
            pub const SPLIT_LIMIT_0: u32 = 0b00;

            /// 0b01: AHB Split Size=16bytes
            pub const SPLIT_LIMIT_1: u32 = 0b01;

            /// 0b10: AHB Split Size=32bytes
            pub const SPLIT_LIMIT_2: u32 = 0b10;

            /// 0b11: AHB Split Size=64bytes
            pub const SPLIT_LIMIT_3: u32 = 0b11;
        }
    }

    /// OTFAD KEY BLOC ECC Enable
    pub mod KEYECCEN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB KEY ECC check disabled
            pub const KEYECCEN_0: u32 = 0b0;

            /// 0b1: AHB KEY ECC check enabled
            pub const KEYECCEN_1: u32 = 0b1;
        }
    }

    /// AHB ECC Single bit ERR CLR
    pub mod ECCSINGLEERRCLR {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB ECC Multi bits ERR CLR
    pub mod ECCMULTIERRCLR {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Master ID Remapping enable
    pub mod HMSTRIDREMAP {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC Read data swap function
    pub mod ECCSWAPEN {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: rdata send to ecc check without swap.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: rdata send to ecc ehck with swap.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Decides all AHB read/write boundary. All access cross the boundary will be divided into smaller sub accesses.
    pub mod ALIGNMENT {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (2 bits: 0b11 << 20)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: No limit
            pub const bit0: u32 = 0b00;

            /// 0b01: 1 KBytes
            pub const bit1: u32 = 0b01;

            /// 0b10: 512 Bytes
            pub const bit2: u32 = 0b10;

            /// 0b11: 256 Bytes
            pub const bit3: u32 = 0b11;
        }
    }
}

/// Interrupt Enable Register
pub mod INTEN {

    /// IP triggered Command Sequences Execution finished interrupt enable.
    pub mod IPCMDDONEEN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Grant Timeout interrupt enable.
    pub mod IPCMDGEEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Grant Timeout interrupt enable.
    pub mod AHBCMDGEEN {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Error Detected interrupt enable.
    pub mod IPCMDERREN {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Error Detected interrupt enable.
    pub mod AHBCMDERREN {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO WaterMark available interrupt enable.
    pub mod IPRXWAEN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO WaterMark empty interrupt enable.
    pub mod IPTXWEEN {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCLK is stopped during command sequence because Async RX FIFO full interrupt enable.
    pub mod SCKSTOPBYRDEN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCLK is stopped during command sequence because Async TX FIFO empty interrupt enable.
    pub mod SCKSTOPBYWREN {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Bus error interrupt enable.Refer Interrupts chapter for more details.
    pub mod AHBBUSERROREN {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
    pub mod SEQTIMEOUTEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OTFAD key blob processing done interrupt enable.Refer Interrupts chapter for more details.
    pub mod KEYDONEEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OTFAD key blob processing error interrupt enable.Refer Interrupts chapter for more details.
    pub mod KEYERROREN {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC multi bits error interrupt enable.Refer Interrupts chapter for more details.
    pub mod ECCMULTIERREN {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC single bit error interrupt enable.Refer Interrupts chapter for more details.
    pub mod ECCSINGLEERREN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP command security violation interrupt enable.
    pub mod IPCMDSECUREVIOEN {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Register
pub mod INTR {

    /// IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
    pub mod IPCMDDONE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Grant Timeout interrupt.
    pub mod IPCMDGE {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Grant Timeout interrupt.
    pub mod AHBCMDGE {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
    pub mod IPCMDERR {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
    pub mod AHBCMDERR {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO watermark available interrupt.
    pub mod IPRXWA {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO watermark empty interrupt.
    pub mod IPTXWE {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCLK is stopped during command sequence because Async RX FIFO full interrupt.
    pub mod SCKSTOPBYRD {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCLK is stopped during command sequence because Async TX FIFO empty interrupt.
    pub mod SCKSTOPBYWR {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob processing interrupt.
    pub mod AHBBUSERROR {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence execution timeout interrupt.
    pub mod SEQTIMEOUT {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OTFAD key blob processing done interrupt.
    pub mod KEYDONE {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OTFAD key blob processing error interrupt.
    pub mod KEYERROR {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC multi bits error interrupt.
    pub mod ECCMULTIERR {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC single bit error interrupt.
    pub mod ECCSINGLEERR {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP command security violation interrupt.
    pub mod IPCMDSECUREVIO {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT Key Register
pub mod LUTKEY {

    /// The Key to lock or unlock LUT.
    pub mod KEY {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT Control Register
pub mod LUTCR {

    /// Lock LUT
    pub mod LOCK {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Unlock LUT
    pub mod UNLOCK {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// LUT protection
    pub mod PROTECT {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB RX Buffer 0 Control Register 0
pub mod AHBRXBUF0CR0 {

    /// AHB RX Buffer Size in 64 bits.
    pub mod BUFSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (10 bits: 0x3ff << 0)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).
    pub mod MSTRID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.
    pub mod PRIORITY {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (3 bits: 0b111 << 24)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB RX Buffer address region funciton enable
    pub mod REGIONEN {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    pub mod PREFETCHEN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB RX Buffer 1 Control Register 0
pub mod AHBRXBUF1CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 2 Control Register 0
pub mod AHBRXBUF2CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 3 Control Register 0
pub mod AHBRXBUF3CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 4 Control Register 0
pub mod AHBRXBUF4CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 5 Control Register 0
pub mod AHBRXBUF5CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 6 Control Register 0
pub mod AHBRXBUF6CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// AHB RX Buffer 7 Control Register 0
pub mod AHBRXBUF7CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
    pub use super::AHBRXBUF0CR0::REGIONEN;
}

/// Flash Control Register 0
pub mod FLSHA1CR0 {

    /// Flash Size in KByte.
    pub mod FLSHSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (23 bits: 0x7fffff << 0)
        pub const mask: u32 = 0x7fffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB write access split function control.
    pub mod SPLITWREN {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB read access split function control.
    pub mod SPLITRDEN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash Control Register 0
pub mod FLSHA2CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
    pub use super::FLSHA1CR0::SPLITRDEN;
    pub use super::FLSHA1CR0::SPLITWREN;
}

/// Flash Control Register 0
pub mod FLSHB1CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
    pub use super::FLSHA1CR0::SPLITRDEN;
    pub use super::FLSHA1CR0::SPLITWREN;
}

/// Flash Control Register 0
pub mod FLSHB2CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
    pub use super::FLSHA1CR0::SPLITRDEN;
    pub use super::FLSHA1CR0::SPLITWREN;
}

/// Flash Control Register 1
pub mod FLSHCR1A1 {

    /// Serial Flash CS setup time.
    pub mod TCSS {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Serial Flash CS Hold time.
    pub mod TCSH {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (5 bits: 0b11111 << 5)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Word Addressable.
    pub mod WA {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Column Address Size.
    pub mod CAS {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (4 bits: 0b1111 << 11)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CS interval unit
    pub mod CSINTERVALUNIT {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The CS interval unit is 1 serial clock cycle
            pub const CSINTERVALUNIT_0: u32 = 0b0;

            /// 0b1: The CS interval unit is 256 serial clock cycle
            pub const CSINTERVALUNIT_1: u32 = 0b1;
        }
    }

    /// This field is used to set the minimum interval between flash device Chip selection deassertion and flash device Chip selection assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.
    pub mod CSINTERVAL {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash Control Register 1
pub mod FLSHCR1A2 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash Control Register 1
pub mod FLSHCR1B1 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash Control Register 1
pub mod FLSHCR1B2 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash Control Register 2
pub mod FLSHCR2A1 {

    /// Sequence Index for AHB Read triggered Command in LUT.
    pub mod ARDSEQID {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (4 bits: 0b1111 << 0)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for AHB Read triggered Command in LUT.
    pub mod ARDSEQNUM {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (3 bits: 0b111 << 5)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Index for AHB Write triggered Command.
    pub mod AWRSEQID {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (4 bits: 0b1111 << 8)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for AHB Write triggered Command.
    pub mod AWRSEQNUM {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (3 bits: 0b111 << 13)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface
    pub mod AWRWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (12 bits: 0xfff << 16)
        pub const mask: u32 = 0xfff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AWRWAIT unit
    pub mod AWRWAITUNIT {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (3 bits: 0b111 << 28)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b000: The AWRWAIT unit is 2 ahb clock cycle
            pub const AWRWAITUNIT_0: u32 = 0b000;

            /// 0b001: The AWRWAIT unit is 8 ahb clock cycle
            pub const AWRWAITUNIT_1: u32 = 0b001;

            /// 0b010: The AWRWAIT unit is 32 ahb clock cycle
            pub const AWRWAITUNIT_2: u32 = 0b010;

            /// 0b011: The AWRWAIT unit is 128 ahb clock cycle
            pub const AWRWAITUNIT_3: u32 = 0b011;

            /// 0b100: The AWRWAIT unit is 512 ahb clock cycle
            pub const AWRWAITUNIT_4: u32 = 0b100;

            /// 0b101: The AWRWAIT unit is 2048 ahb clock cycle
            pub const AWRWAITUNIT_5: u32 = 0b101;

            /// 0b110: The AWRWAIT unit is 8192 ahb clock cycle
            pub const AWRWAITUNIT_6: u32 = 0b110;

            /// 0b111: The AWRWAIT unit is 32768 ahb clock cycle
            pub const AWRWAITUNIT_7: u32 = 0b111;
        }
    }

    /// Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer Programmable Sequence Engine for details.
    pub mod CLRINSTRPTR {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash Control Register 2
pub mod FLSHCR2A2 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash Control Register 2
pub mod FLSHCR2B1 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash Control Register 2
pub mod FLSHCR2B2 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash Control Register 4
pub mod FLSHCR4 {

    /// Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
    pub mod WMOPT1 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst start address alignment when flash is accessed in individual mode.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst start address alignment when flash is accessed in individual mode.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Write mask option bit 2. When using AP memory, This option bit could be used to remove AHB write burst minimal length limitation. When using this bit, WMOPT1 should also be set.
    pub mod WMOPT2 {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst length when flash is accessed in individual mode.
            pub const WMOPT2_0: u32 = 0b0;

            /// 0b1: DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst length when flash is accessed in individual mode, the minimal write burst length should be 4.
            pub const WMOPT2_1: u32 = 0b1;
        }
    }

    /// Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
    pub mod WMENA {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
            pub const WMENA_0: u32 = 0b0;

            /// 0b1: Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
            pub const WMENA_1: u32 = 0b1;
        }
    }

    /// Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
    pub mod WMENB {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
            pub const WMENB_0: u32 = 0b0;

            /// 0b1: Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
            pub const WMENB_1: u32 = 0b1;
        }
    }

    /// Enable APMEM 16 bit write mask function, bit 9 for A1-B1 pair, bit 10 for A2-B2 pair.
    pub mod PAR_WM {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (2 bits: 0b11 << 9)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Disable the address shift logic for lower density of 16 bit PSRAM.
    pub mod PAR_ADDR_ADJ_DIS {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP Control Register 0
pub mod IPCR0 {

    /// Serial Flash Address for IP command.
    pub mod SFAR {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP Control Register 1
pub mod IPCR1 {

    /// Flash Read/Program Data Size (in Bytes) for IP command.
    pub mod IDATSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Index in LUT for IP command.
    pub mod ISEQID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for IP command: ISEQNUM+1.
    pub mod ISEQNUM {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (3 bits: 0b111 << 24)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Parallel mode Enabled for IP command.
    pub mod IPAREN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Flash will be accessed in Individual mode.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Flash will be accessed in Parallel mode.
            pub const ENABLE: u32 = 0b1;
        }
    }
}

/// IP Command Register
pub mod IPCMD {

    /// Setting this bit will trigger an IP Command.
    pub mod TRG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Control Register
pub mod IPRXFCR {

    /// Clear all valid data entries in IP RX FIFO.
    pub mod CLRIPRXF {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO reading by DMA enabled.
    pub mod RXDMAEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP RX FIFO would be read by processor.
            pub const RXDMAEN_0: u32 = 0b0;

            /// 0b1: IP RX FIFO would be read by DMA.
            pub const RXDMAEN_1: u32 = 0b1;
        }
    }

    /// Watermark level is (RXWMRK+1)*64 Bits.
    pub mod RXWMRK {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (5 bits: 0b11111 << 2)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Control Register
pub mod IPTXFCR {

    /// Clear all valid data entries in IP TX FIFO.
    pub mod CLRIPTXF {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO filling by DMA enabled.
    pub mod TXDMAEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP TX FIFO would be filled by processor.
            pub const TXDMAEN_0: u32 = 0b0;

            /// 0b1: IP TX FIFO would be filled by DMA.
            pub const TXDMAEN_1: u32 = 0b1;
        }
    }

    /// Watermark level is (TXWMRK+1)*64 Bits.
    pub mod TXWMRK {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (5 bits: 0b11111 << 2)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// DLL Control Register 0
pub mod DLLCRA {

    /// DLL calibration enable.
    pub mod DLLEN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
    pub mod DLLRESET {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial root clock). If serial root clock is >= 100 MHz, DLLEN set to 0x1, OVRDEN set to =0x0, then SLVDLYTARGET setting of 0xF is recommended.
    pub mod SLVDLYTARGET {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (4 bits: 0b1111 << 3)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Slave clock delay line delay cell number selection override enable.
    pub mod OVRDEN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Slave clock delay line delay cell number selection override value.
    pub mod OVRDVAL {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (6 bits: 0x3f << 9)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// DLL Control Register 0
pub mod DLLCRB {
    pub use super::DLLCRA::DLLEN;
    pub use super::DLLCRA::DLLRESET;
    pub use super::DLLCRA::OVRDEN;
    pub use super::DLLCRA::OVRDVAL;
    pub use super::DLLCRA::SLVDLYTARGET;
}

/// Misc Control Register 4
pub mod MISCCR4 {

    /// AHB bus address that trigger the current ECC multi bits error interrupt.
    pub mod AHBADDRESS {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Misc Control Register 5
pub mod MISCCR5 {

    /// ECC single bit error correction indication.
    pub mod ECCSINGLEERRORCORR {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Misc Control Register 6
pub mod MISCCR6 {

    /// ECC single error information Valid
    pub mod VALID {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC single error information Hit
    pub mod HIT {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ECC single error address
    pub mod ADDRESS {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (30 bits: 0x3fffffff << 2)
        pub const mask: u32 = 0x3fffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Misc Control Register 7
pub mod MISCCR7 {
    pub use super::MISCCR6::ADDRESS;
    pub use super::MISCCR6::HIT;
    pub use super::MISCCR6::VALID;
}

/// Status Register 0
pub mod STS0 {

    /// This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
    pub mod SEQIDLE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
    pub mod ARBIDLE {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0\[ARBIDLE\]=0x1).
    pub mod ARBCMDSRC {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (2 bits: 0b11 << 2)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Triggered by AHB read command (triggered by AHB read).
            pub const ARBCMDSRC_0: u32 = 0b00;

            /// 0b01: Triggered by AHB write command (triggered by AHB Write).
            pub const ARBCMDSRC_1: u32 = 0b01;

            /// 0b10: Triggered by IP command (triggered by setting register bit IPCMD.TRG).
            pub const ARBCMDSRC_2: u32 = 0b10;

            /// 0b11: Triggered by suspended command (resumed).
            pub const ARBCMDSRC_3: u32 = 0b11;
        }
    }
}

/// Status Register 1
pub mod STS1 {

    /// Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR\[AHBCMDERR\] is write-1-clear(w1c).
    pub mod AHBCMDERRID {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (4 bits: 0b1111 << 0)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR\[AHBCMDERR\] is write-1-clear(w1c).
    pub mod AHBCMDERRCODE {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (4 bits: 0b1111 << 8)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0000: No error.
            pub const AHBCMDERRCODE_0: u32 = 0b0000;

            /// 0b0010: AHB Write command with JMP_ON_CS instruction used in the sequence.
            pub const AHBCMDERRCODE_2: u32 = 0b0010;

            /// 0b0011: There is unknown instruction opcode in the sequence.
            pub const AHBCMDERRCODE_3: u32 = 0b0011;

            /// 0b0100: Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
            pub const AHBCMDERRCODE_4: u32 = 0b0100;

            /// 0b0101: Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
            pub const AHBCMDERRCODE_5: u32 = 0b0101;

            /// 0b1110: Sequence execution timeout.
            pub const AHBCMDERRCODE_14: u32 = 0b1110;
        }
    }

    /// Indicates the sequence Index when IP command error detected. This field will be cleared when INTR\[IPCMDERR\] is write-1-clear(w1c).
    pub mod IPCMDERRID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Indicates the Error Code when IP command Error detected. This field will be cleared when INTR\[IPCMDERR\] is write-1-clear(w1c).
    pub mod IPCMDERRCODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0000: No error.
            pub const IPCMDERRCODE_0: u32 = 0b0000;

            /// 0b0010: IP command with JMP_ON_CS instruction used in the sequence.
            pub const IPCMDERRCODE_2: u32 = 0b0010;

            /// 0b0011: There is unknown instruction opcode in the sequence.
            pub const IPCMDERRCODE_3: u32 = 0b0011;

            /// 0b0100: Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
            pub const IPCMDERRCODE_4: u32 = 0b0100;

            /// 0b0101: Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
            pub const IPCMDERRCODE_5: u32 = 0b0101;

            /// 0b0110: Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
            pub const IPCMDERRCODE_6: u32 = 0b0110;

            /// 0b1110: Sequence execution timeout.
            pub const IPCMDERRCODE_14: u32 = 0b1110;

            /// 0b1111: Flash boundary crossed.
            pub const IPCMDERRCODE_15: u32 = 0b1111;
        }
    }
}

/// Status Register 2
pub mod STS2 {

    /// Flash A sample clock slave delay line locked.
    pub mod ASLVLOCK {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock reference delay line locked.
    pub mod AREFLOCK {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock slave delay line delay cell number selection .
    pub mod ASLVSEL {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (6 bits: 0x3f << 2)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock reference delay line delay cell number selection.
    pub mod AREFSEL {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (6 bits: 0x3f << 8)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock slave delay line locked.
    pub mod BSLVLOCK {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock reference delay line locked.
    pub mod BREFLOCK {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock slave delay line delay cell number selection.
    pub mod BSLVSEL {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (6 bits: 0x3f << 18)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock reference delay line delay cell number selection.
    pub mod BREFSEL {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (6 bits: 0x3f << 24)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB Suspend Status Register
pub mod AHBSPNDSTS {

    /// Indicates if an AHB read prefetch command sequence has been suspended.
    pub mod ACTIVE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB RX BUF ID for suspended command sequence.
    pub mod BUFID {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (3 bits: 0b111 << 1)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Left Data size for suspended command sequence (in byte).
    pub mod DATLFT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Status Register
pub mod IPRXFSTS {

    /// Fill level of IP RX FIFO.
    pub mod FILL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Total Read Data Counter: RDCNTR * 64 Bits.
    pub mod RDCNTR {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Status Register
pub mod IPTXFSTS {

    /// Fill level of IP TX FIFO.
    pub mod FILL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Total Write Data Counter: WRCNTR * 64 Bits.
    pub mod WRCNTR {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Data Register x
pub mod RFDR0 {

    /// RX Data
    pub mod RXDATA {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Data Register x
pub mod RFDR1 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR2 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR3 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR4 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR5 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR6 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR7 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR8 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR9 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR10 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR11 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR12 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR13 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR14 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR15 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR16 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR17 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR18 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR19 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR20 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR21 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR22 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR23 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR24 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR25 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR26 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR27 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR28 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR29 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR30 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register x
pub mod RFDR31 {
    pub use super::RFDR0::RXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR0 {

    /// TX Data
    pub mod TXDATA {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Data Register x
pub mod TFDR1 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR2 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR3 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR4 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR5 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR6 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR7 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR8 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR9 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR10 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR11 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR12 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR13 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR14 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR15 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR16 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR17 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR18 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR19 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR20 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR21 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR22 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR23 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR24 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR25 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR26 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR27 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR28 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR29 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR30 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register x
pub mod TFDR31 {
    pub use super::TFDR0::TXDATA;
}

/// LUT x
pub mod LUT0 {

    /// OPERAND0
    pub mod OPERAND0 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// NUM_PADS0
    pub mod NUM_PADS0 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (2 bits: 0b11 << 8)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPCODE
    pub mod OPCODE0 {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (6 bits: 0x3f << 10)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPERAND1
    pub mod OPERAND1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// NUM_PADS1
    pub mod NUM_PADS1 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (2 bits: 0b11 << 24)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPCODE1
    pub mod OPCODE1 {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (6 bits: 0x3f << 26)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT x
pub mod LUT1 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT2 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT3 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT4 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT5 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT6 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT7 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT8 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT9 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT10 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT11 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT12 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT13 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT14 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT15 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT16 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT17 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT18 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT19 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT20 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT21 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT22 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT23 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT24 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT25 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT26 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT27 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT28 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT29 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT30 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT31 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT32 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT33 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT34 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT35 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT36 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT37 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT38 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT39 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT40 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT41 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT42 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT43 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT44 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT45 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT46 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT47 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT48 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT49 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT50 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT51 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT52 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT53 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT54 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT55 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT56 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT57 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT58 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT59 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT60 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT61 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT62 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT x
pub mod LUT63 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// AHB Master ID 0 Control Register
pub mod HMSTR0CR {

    /// Mask bits for AHB master ID.
    pub mod MASK {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0000000000000000: Mask
            pub const DISABLE: u32 = 0b0000000000000000;

            /// 0b0000000000000001: Unmask
            pub const ENABLE: u32 = 0b0000000000000001;
        }
    }

    /// This is expected Master ID.
    pub mod MSTRID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB Master ID 1 Control Register
pub mod HMSTR1CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 2 Control Register
pub mod HMSTR2CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 3 Control Register
pub mod HMSTR3CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 4 Control Register
pub mod HMSTR4CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 5 Control Register
pub mod HMSTR5CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 6 Control Register
pub mod HMSTR6CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// AHB Master ID 7 Control Register
pub mod HMSTR7CR {
    pub use super::HMSTR0CR::MASK;
    pub use super::HMSTR0CR::MSTRID;
}

/// HADDR REMAP START ADDR
pub mod HADDRSTART {

    /// AHB Bus address remap function enable
    pub mod REMAPEN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: HADDR REMAP Disabled
            pub const REMAPEN_0: u32 = 0b0;

            /// 0b1: HADDR REMAP Enabled
            pub const REMAPEN_1: u32 = 0b1;
        }
    }

    /// OTFAD Keyblob is in ECC region and need to be remapped
    pub mod KBINECC {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: If key blob is in remap region, FlexSPI will fetch keyblob at base address + offset
            pub const KBINECC_0: u32 = 0b0;

            /// 0b1: If key blob is in remap region, FlexSPI will fetch keyblob at base address + offset*2
            pub const KBINECC_1: u32 = 0b1;
        }
    }

    /// HADDR remap range's start addr, 4K aligned When ADDRSTART setting is same as ASFM_BASE, and OTFAD keyblob function is enabled, keyblob will also be remapped
    pub mod ADDRSTART {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (20 bits: 0xfffff << 12)
        pub const mask: u32 = 0xfffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// HADDR REMAP END ADDR
pub mod HADDREND {

    /// HADDR remap range's end addr, 4K aligned
    pub mod ENDSTART {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (20 bits: 0xfffff << 12)
        pub const mask: u32 = 0xfffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// HADDR REMAP OFFSET
pub mod HADDROFFSET {

    /// HADDR offset field, remapped address will be ADDR\[31:12\]=ADDR_original\[31:12\]+ADDROFFSET
    pub mod ADDROFFSET {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (20 bits: 0xfffff << 12)
        pub const mask: u32 = 0xfffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IPS nonsecure region Start address of region 0
pub mod IPSNSZSTART0 {

    /// Start address of region 0. Minimal 4K Bytes aligned. It is flash address.
    pub mod start_address {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (20 bits: 0xfffff << 12)
        pub const mask: u32 = 0xfffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IPS nonsecure region End address of region 0
pub mod IPSNSZEND0 {

    /// End address of region 0. Minimal 4K Bytes aligned. It is flash address.
    pub mod end_address {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (20 bits: 0xfffff << 12)
        pub const mask: u32 = 0xfffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IPS nonsecure region Start address of region 1
pub mod IPSNSZSTART1 {
    pub use super::IPSNSZSTART0::start_address;
}

/// IPS nonsecure region End address of region 1
pub mod IPSNSZEND1 {
    pub use super::IPSNSZEND0::end_address;
}

/// RX BUF Start address of region 0
pub mod AHBBUFREGIONSTART0 {
    pub use super::IPSNSZSTART0::start_address;
}

/// RX BUF region End address of region 0
pub mod AHBBUFREGIONEND0 {
    pub use super::IPSNSZEND0::end_address;
}

/// RX BUF Start address of region 1
pub mod AHBBUFREGIONSTART1 {
    pub use super::IPSNSZSTART0::start_address;
}

/// RX BUF region End address of region 1
pub mod AHBBUFREGIONEND1 {
    pub use super::IPSNSZEND0::end_address;
}

/// RX BUF Start address of region 2
pub mod AHBBUFREGIONSTART2 {
    pub use super::IPSNSZSTART0::start_address;
}

/// RX BUF region End address of region 2
pub mod AHBBUFREGIONEND2 {
    pub use super::IPSNSZEND0::end_address;
}

/// RX BUF Start address of region 3
pub mod AHBBUFREGIONSTART3 {
    pub use super::IPSNSZSTART0::start_address;
}

/// RX BUF region End address of region 3
pub mod AHBBUFREGIONEND3 {
    pub use super::IPSNSZEND0::end_address;
}
#[repr(C)]
pub struct RegisterBlock {
    /// Module Control Register 0
    pub MCR0: RWRegister<u32>,

    /// Module Control Register 1
    pub MCR1: RWRegister<u32>,

    /// Module Control Register 2
    pub MCR2: RWRegister<u32>,

    /// AHB Bus Control Register
    pub AHBCR: RWRegister<u32>,

    /// Interrupt Enable Register
    pub INTEN: RWRegister<u32>,

    /// Interrupt Register
    pub INTR: RWRegister<u32>,

    /// LUT Key Register
    pub LUTKEY: RWRegister<u32>,

    /// LUT Control Register
    pub LUTCR: RWRegister<u32>,

    /// AHB RX Buffer 0 Control Register 0
    pub AHBRXBUF0CR0: RWRegister<u32>,

    /// AHB RX Buffer 1 Control Register 0
    pub AHBRXBUF1CR0: RWRegister<u32>,

    /// AHB RX Buffer 2 Control Register 0
    pub AHBRXBUF2CR0: RWRegister<u32>,

    /// AHB RX Buffer 3 Control Register 0
    pub AHBRXBUF3CR0: RWRegister<u32>,

    /// AHB RX Buffer 4 Control Register 0
    pub AHBRXBUF4CR0: RWRegister<u32>,

    /// AHB RX Buffer 5 Control Register 0
    pub AHBRXBUF5CR0: RWRegister<u32>,

    /// AHB RX Buffer 6 Control Register 0
    pub AHBRXBUF6CR0: RWRegister<u32>,

    /// AHB RX Buffer 7 Control Register 0
    pub AHBRXBUF7CR0: RWRegister<u32>,

    _reserved1: [u32; 8],

    /// Flash Control Register 0
    pub FLSHA1CR0: RWRegister<u32>,

    /// Flash Control Register 0
    pub FLSHA2CR0: RWRegister<u32>,

    /// Flash Control Register 0
    pub FLSHB1CR0: RWRegister<u32>,

    /// Flash Control Register 0
    pub FLSHB2CR0: RWRegister<u32>,

    /// Flash Control Register 1
    pub FLSHCR1A1: RWRegister<u32>,

    /// Flash Control Register 1
    pub FLSHCR1A2: RWRegister<u32>,

    /// Flash Control Register 1
    pub FLSHCR1B1: RWRegister<u32>,

    /// Flash Control Register 1
    pub FLSHCR1B2: RWRegister<u32>,

    /// Flash Control Register 2
    pub FLSHCR2A1: RWRegister<u32>,

    /// Flash Control Register 2
    pub FLSHCR2A2: RWRegister<u32>,

    /// Flash Control Register 2
    pub FLSHCR2B1: RWRegister<u32>,

    /// Flash Control Register 2
    pub FLSHCR2B2: RWRegister<u32>,

    _reserved2: [u32; 1],

    /// Flash Control Register 4
    pub FLSHCR4: RWRegister<u32>,

    _reserved3: [u32; 2],

    /// IP Control Register 0
    pub IPCR0: RWRegister<u32>,

    /// IP Control Register 1
    pub IPCR1: RWRegister<u32>,

    _reserved4: [u32; 2],

    /// IP Command Register
    pub IPCMD: RWRegister<u32>,

    _reserved5: [u32; 1],

    /// IP RX FIFO Control Register
    pub IPRXFCR: RWRegister<u32>,

    /// IP TX FIFO Control Register
    pub IPTXFCR: RWRegister<u32>,

    /// DLL Control Register 0
    pub DLLCRA: RWRegister<u32>,

    /// DLL Control Register 0
    pub DLLCRB: RWRegister<u32>,

    _reserved6: [u32; 2],

    /// Misc Control Register 4
    pub MISCCR4: RORegister<u32>,

    /// Misc Control Register 5
    pub MISCCR5: RORegister<u32>,

    /// Misc Control Register 6
    pub MISCCR6: RORegister<u32>,

    /// Misc Control Register 7
    pub MISCCR7: RORegister<u32>,

    /// Status Register 0
    pub STS0: RORegister<u32>,

    /// Status Register 1
    pub STS1: RORegister<u32>,

    /// Status Register 2
    pub STS2: RORegister<u32>,

    /// AHB Suspend Status Register
    pub AHBSPNDSTS: RORegister<u32>,

    /// IP RX FIFO Status Register
    pub IPRXFSTS: RORegister<u32>,

    /// IP TX FIFO Status Register
    pub IPTXFSTS: RORegister<u32>,

    _reserved7: [u32; 2],

    /// IP RX FIFO Data Register x
    pub RFDR0: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR1: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR2: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR3: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR4: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR5: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR6: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR7: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR8: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR9: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR10: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR11: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR12: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR13: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR14: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR15: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR16: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR17: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR18: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR19: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR20: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR21: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR22: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR23: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR24: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR25: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR26: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR27: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR28: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR29: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR30: RORegister<u32>,

    /// IP RX FIFO Data Register x
    pub RFDR31: RORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR0: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR1: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR2: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR3: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR4: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR5: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR6: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR7: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR8: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR9: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR10: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR11: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR12: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR13: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR14: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR15: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR16: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR17: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR18: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR19: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR20: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR21: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR22: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR23: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR24: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR25: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR26: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR27: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR28: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR29: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR30: WORegister<u32>,

    /// IP TX FIFO Data Register x
    pub TFDR31: WORegister<u32>,

    /// LUT x
    pub LUT0: RWRegister<u32>,

    /// LUT x
    pub LUT1: RWRegister<u32>,

    /// LUT x
    pub LUT2: RWRegister<u32>,

    /// LUT x
    pub LUT3: RWRegister<u32>,

    /// LUT x
    pub LUT4: RWRegister<u32>,

    /// LUT x
    pub LUT5: RWRegister<u32>,

    /// LUT x
    pub LUT6: RWRegister<u32>,

    /// LUT x
    pub LUT7: RWRegister<u32>,

    /// LUT x
    pub LUT8: RWRegister<u32>,

    /// LUT x
    pub LUT9: RWRegister<u32>,

    /// LUT x
    pub LUT10: RWRegister<u32>,

    /// LUT x
    pub LUT11: RWRegister<u32>,

    /// LUT x
    pub LUT12: RWRegister<u32>,

    /// LUT x
    pub LUT13: RWRegister<u32>,

    /// LUT x
    pub LUT14: RWRegister<u32>,

    /// LUT x
    pub LUT15: RWRegister<u32>,

    /// LUT x
    pub LUT16: RWRegister<u32>,

    /// LUT x
    pub LUT17: RWRegister<u32>,

    /// LUT x
    pub LUT18: RWRegister<u32>,

    /// LUT x
    pub LUT19: RWRegister<u32>,

    /// LUT x
    pub LUT20: RWRegister<u32>,

    /// LUT x
    pub LUT21: RWRegister<u32>,

    /// LUT x
    pub LUT22: RWRegister<u32>,

    /// LUT x
    pub LUT23: RWRegister<u32>,

    /// LUT x
    pub LUT24: RWRegister<u32>,

    /// LUT x
    pub LUT25: RWRegister<u32>,

    /// LUT x
    pub LUT26: RWRegister<u32>,

    /// LUT x
    pub LUT27: RWRegister<u32>,

    /// LUT x
    pub LUT28: RWRegister<u32>,

    /// LUT x
    pub LUT29: RWRegister<u32>,

    /// LUT x
    pub LUT30: RWRegister<u32>,

    /// LUT x
    pub LUT31: RWRegister<u32>,

    /// LUT x
    pub LUT32: RWRegister<u32>,

    /// LUT x
    pub LUT33: RWRegister<u32>,

    /// LUT x
    pub LUT34: RWRegister<u32>,

    /// LUT x
    pub LUT35: RWRegister<u32>,

    /// LUT x
    pub LUT36: RWRegister<u32>,

    /// LUT x
    pub LUT37: RWRegister<u32>,

    /// LUT x
    pub LUT38: RWRegister<u32>,

    /// LUT x
    pub LUT39: RWRegister<u32>,

    /// LUT x
    pub LUT40: RWRegister<u32>,

    /// LUT x
    pub LUT41: RWRegister<u32>,

    /// LUT x
    pub LUT42: RWRegister<u32>,

    /// LUT x
    pub LUT43: RWRegister<u32>,

    /// LUT x
    pub LUT44: RWRegister<u32>,

    /// LUT x
    pub LUT45: RWRegister<u32>,

    /// LUT x
    pub LUT46: RWRegister<u32>,

    /// LUT x
    pub LUT47: RWRegister<u32>,

    /// LUT x
    pub LUT48: RWRegister<u32>,

    /// LUT x
    pub LUT49: RWRegister<u32>,

    /// LUT x
    pub LUT50: RWRegister<u32>,

    /// LUT x
    pub LUT51: RWRegister<u32>,

    /// LUT x
    pub LUT52: RWRegister<u32>,

    /// LUT x
    pub LUT53: RWRegister<u32>,

    /// LUT x
    pub LUT54: RWRegister<u32>,

    /// LUT x
    pub LUT55: RWRegister<u32>,

    /// LUT x
    pub LUT56: RWRegister<u32>,

    /// LUT x
    pub LUT57: RWRegister<u32>,

    /// LUT x
    pub LUT58: RWRegister<u32>,

    /// LUT x
    pub LUT59: RWRegister<u32>,

    /// LUT x
    pub LUT60: RWRegister<u32>,

    /// LUT x
    pub LUT61: RWRegister<u32>,

    /// LUT x
    pub LUT62: RWRegister<u32>,

    /// LUT x
    pub LUT63: RWRegister<u32>,

    _reserved8: [u32; 64],

    /// AHB Master ID 0 Control Register
    pub HMSTR0CR: RWRegister<u32>,

    /// AHB Master ID 1 Control Register
    pub HMSTR1CR: RWRegister<u32>,

    /// AHB Master ID 2 Control Register
    pub HMSTR2CR: RWRegister<u32>,

    /// AHB Master ID 3 Control Register
    pub HMSTR3CR: RWRegister<u32>,

    /// AHB Master ID 4 Control Register
    pub HMSTR4CR: RWRegister<u32>,

    /// AHB Master ID 5 Control Register
    pub HMSTR5CR: RWRegister<u32>,

    /// AHB Master ID 6 Control Register
    pub HMSTR6CR: RWRegister<u32>,

    /// AHB Master ID 7 Control Register
    pub HMSTR7CR: RWRegister<u32>,

    /// HADDR REMAP START ADDR
    pub HADDRSTART: RWRegister<u32>,

    /// HADDR REMAP END ADDR
    pub HADDREND: RWRegister<u32>,

    /// HADDR REMAP OFFSET
    pub HADDROFFSET: RWRegister<u32>,

    _reserved9: [u32; 1],

    /// IPS nonsecure region Start address of region 0
    pub IPSNSZSTART0: RWRegister<u32>,

    /// IPS nonsecure region End address of region 0
    pub IPSNSZEND0: RWRegister<u32>,

    /// IPS nonsecure region Start address of region 1
    pub IPSNSZSTART1: RWRegister<u32>,

    /// IPS nonsecure region End address of region 1
    pub IPSNSZEND1: RWRegister<u32>,

    /// RX BUF Start address of region 0
    pub AHBBUFREGIONSTART0: RWRegister<u32>,

    /// RX BUF region End address of region 0
    pub AHBBUFREGIONEND0: RWRegister<u32>,

    /// RX BUF Start address of region 1
    pub AHBBUFREGIONSTART1: RWRegister<u32>,

    /// RX BUF region End address of region 1
    pub AHBBUFREGIONEND1: RWRegister<u32>,

    /// RX BUF Start address of region 2
    pub AHBBUFREGIONSTART2: RWRegister<u32>,

    /// RX BUF region End address of region 2
    pub AHBBUFREGIONEND2: RWRegister<u32>,

    /// RX BUF Start address of region 3
    pub AHBBUFREGIONSTART3: RWRegister<u32>,

    /// RX BUF region End address of region 3
    pub AHBBUFREGIONEND3: RWRegister<u32>,
}
pub struct ResetValues {
    pub MCR0: u32,
    pub MCR1: u32,
    pub MCR2: u32,
    pub AHBCR: u32,
    pub INTEN: u32,
    pub INTR: u32,
    pub LUTKEY: u32,
    pub LUTCR: u32,
    pub AHBRXBUF0CR0: u32,
    pub AHBRXBUF1CR0: u32,
    pub AHBRXBUF2CR0: u32,
    pub AHBRXBUF3CR0: u32,
    pub AHBRXBUF4CR0: u32,
    pub AHBRXBUF5CR0: u32,
    pub AHBRXBUF6CR0: u32,
    pub AHBRXBUF7CR0: u32,
    pub FLSHA1CR0: u32,
    pub FLSHA2CR0: u32,
    pub FLSHB1CR0: u32,
    pub FLSHB2CR0: u32,
    pub FLSHCR1A1: u32,
    pub FLSHCR1A2: u32,
    pub FLSHCR1B1: u32,
    pub FLSHCR1B2: u32,
    pub FLSHCR2A1: u32,
    pub FLSHCR2A2: u32,
    pub FLSHCR2B1: u32,
    pub FLSHCR2B2: u32,
    pub FLSHCR4: u32,
    pub IPCR0: u32,
    pub IPCR1: u32,
    pub IPCMD: u32,
    pub IPRXFCR: u32,
    pub IPTXFCR: u32,
    pub DLLCRA: u32,
    pub DLLCRB: u32,
    pub MISCCR4: u32,
    pub MISCCR5: u32,
    pub MISCCR6: u32,
    pub MISCCR7: u32,
    pub STS0: u32,
    pub STS1: u32,
    pub STS2: u32,
    pub AHBSPNDSTS: u32,
    pub IPRXFSTS: u32,
    pub IPTXFSTS: u32,
    pub RFDR0: u32,
    pub RFDR1: u32,
    pub RFDR2: u32,
    pub RFDR3: u32,
    pub RFDR4: u32,
    pub RFDR5: u32,
    pub RFDR6: u32,
    pub RFDR7: u32,
    pub RFDR8: u32,
    pub RFDR9: u32,
    pub RFDR10: u32,
    pub RFDR11: u32,
    pub RFDR12: u32,
    pub RFDR13: u32,
    pub RFDR14: u32,
    pub RFDR15: u32,
    pub RFDR16: u32,
    pub RFDR17: u32,
    pub RFDR18: u32,
    pub RFDR19: u32,
    pub RFDR20: u32,
    pub RFDR21: u32,
    pub RFDR22: u32,
    pub RFDR23: u32,
    pub RFDR24: u32,
    pub RFDR25: u32,
    pub RFDR26: u32,
    pub RFDR27: u32,
    pub RFDR28: u32,
    pub RFDR29: u32,
    pub RFDR30: u32,
    pub RFDR31: u32,
    pub TFDR0: u32,
    pub TFDR1: u32,
    pub TFDR2: u32,
    pub TFDR3: u32,
    pub TFDR4: u32,
    pub TFDR5: u32,
    pub TFDR6: u32,
    pub TFDR7: u32,
    pub TFDR8: u32,
    pub TFDR9: u32,
    pub TFDR10: u32,
    pub TFDR11: u32,
    pub TFDR12: u32,
    pub TFDR13: u32,
    pub TFDR14: u32,
    pub TFDR15: u32,
    pub TFDR16: u32,
    pub TFDR17: u32,
    pub TFDR18: u32,
    pub TFDR19: u32,
    pub TFDR20: u32,
    pub TFDR21: u32,
    pub TFDR22: u32,
    pub TFDR23: u32,
    pub TFDR24: u32,
    pub TFDR25: u32,
    pub TFDR26: u32,
    pub TFDR27: u32,
    pub TFDR28: u32,
    pub TFDR29: u32,
    pub TFDR30: u32,
    pub TFDR31: u32,
    pub LUT0: u32,
    pub LUT1: u32,
    pub LUT2: u32,
    pub LUT3: u32,
    pub LUT4: u32,
    pub LUT5: u32,
    pub LUT6: u32,
    pub LUT7: u32,
    pub LUT8: u32,
    pub LUT9: u32,
    pub LUT10: u32,
    pub LUT11: u32,
    pub LUT12: u32,
    pub LUT13: u32,
    pub LUT14: u32,
    pub LUT15: u32,
    pub LUT16: u32,
    pub LUT17: u32,
    pub LUT18: u32,
    pub LUT19: u32,
    pub LUT20: u32,
    pub LUT21: u32,
    pub LUT22: u32,
    pub LUT23: u32,
    pub LUT24: u32,
    pub LUT25: u32,
    pub LUT26: u32,
    pub LUT27: u32,
    pub LUT28: u32,
    pub LUT29: u32,
    pub LUT30: u32,
    pub LUT31: u32,
    pub LUT32: u32,
    pub LUT33: u32,
    pub LUT34: u32,
    pub LUT35: u32,
    pub LUT36: u32,
    pub LUT37: u32,
    pub LUT38: u32,
    pub LUT39: u32,
    pub LUT40: u32,
    pub LUT41: u32,
    pub LUT42: u32,
    pub LUT43: u32,
    pub LUT44: u32,
    pub LUT45: u32,
    pub LUT46: u32,
    pub LUT47: u32,
    pub LUT48: u32,
    pub LUT49: u32,
    pub LUT50: u32,
    pub LUT51: u32,
    pub LUT52: u32,
    pub LUT53: u32,
    pub LUT54: u32,
    pub LUT55: u32,
    pub LUT56: u32,
    pub LUT57: u32,
    pub LUT58: u32,
    pub LUT59: u32,
    pub LUT60: u32,
    pub LUT61: u32,
    pub LUT62: u32,
    pub LUT63: u32,
    pub HMSTR0CR: u32,
    pub HMSTR1CR: u32,
    pub HMSTR2CR: u32,
    pub HMSTR3CR: u32,
    pub HMSTR4CR: u32,
    pub HMSTR5CR: u32,
    pub HMSTR6CR: u32,
    pub HMSTR7CR: u32,
    pub HADDRSTART: u32,
    pub HADDREND: u32,
    pub HADDROFFSET: u32,
    pub IPSNSZSTART0: u32,
    pub IPSNSZEND0: u32,
    pub IPSNSZSTART1: u32,
    pub IPSNSZEND1: u32,
    pub AHBBUFREGIONSTART0: u32,
    pub AHBBUFREGIONEND0: u32,
    pub AHBBUFREGIONSTART1: u32,
    pub AHBBUFREGIONEND1: u32,
    pub AHBBUFREGIONSTART2: u32,
    pub AHBBUFREGIONEND2: u32,
    pub AHBBUFREGIONSTART3: u32,
    pub AHBBUFREGIONEND3: u32,
}
pub struct Instance<const N: u8> {
    #[cfg_attr(feature = "nosync", allow(unused))]
    pub(crate) addr: u32,
    #[cfg_attr(feature = "nosync", allow(unused))]
    pub(crate) intrs: &'static [crate::Interrupt],
}

#[cfg(not(feature = "nosync"))]
impl<const N: u8> ::core::ops::Deref for Instance<N> {
    type Target = RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &RegisterBlock {
        unsafe { &*(self.addr as *const _) }
    }
}

#[cfg(not(feature = "nosync"))]
unsafe impl<const N: u8> Send for Instance<N> {}

#[cfg(not(feature = "nosync"))]
impl<const N: u8> Instance<N> {
    /// Return the interrupt signals associated with this
    /// peripheral instance
    ///
    /// Collection may be empty if there is no interrupt signal
    /// associated with the peripheral. There's no guarantee for
    /// interrupt signal ordering in the collection.
    #[inline(always)]
    pub const fn interrupts<'a>(&'a self) -> &'a [crate::Interrupt] {
        self.intrs
    }
}
