#![allow(non_snake_case, non_upper_case_globals)]
#![allow(non_camel_case_types)]
//! CAN
//!
//! Used by: imxrt1176_cm4, imxrt1176_cm7

use crate::{RORegister, RWRegister};

/// Module Configuration register
pub mod MCR {

    /// Number Of The Last Message Buffer
    pub mod MAXMB {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (7 bits: 0x7f << 0)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Acceptance Mode
    pub mod IDAM {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (2 bits: 0b11 << 8)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Format A: One full ID (standard and extended) per ID filter table element.
            pub const one_full_ID: u32 = 0b00;

            /// 0b01: Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID filter table element.
            pub const two_full_ID: u32 = 0b01;

            /// 0b10: Format C: Four partial 8-bit standard IDs per ID filter table element.
            pub const four_partial_ID: u32 = 0b10;

            /// 0b11: Format D: All frames rejected.
            pub const all_frames_rejected: u32 = 0b11;
        }
    }

    /// CAN FD operation enable
    pub mod FDEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: CAN FD is disabled. FlexCAN is able to receive and transmit messages in CAN 2.0 format.
            pub const CAN_FD_disabled: u32 = 0b0;

            /// 0b1: CAN FD is enabled. FlexCAN is able to receive and transmit messages in both CAN FD and CAN 2.0 formats.
            pub const CAN_FD_enabled: u32 = 0b1;
        }
    }

    /// Abort Enable
    pub mod AEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Abort disabled.
            pub const abort_disabled: u32 = 0b0;

            /// 0b1: Abort enabled.
            pub const abort_enabled: u32 = 0b1;
        }
    }

    /// Local Priority Enable
    pub mod LPRIOEN {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Local Priority disabled.
            pub const local_priority_disabled: u32 = 0b0;

            /// 0b1: Local Priority enabled.
            pub const local_priority_enabled: u32 = 0b1;
        }
    }

    /// DMA Enable
    pub mod DMA {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: DMA feature for RX FIFO disabled.
            pub const id2: u32 = 0b0;

            /// 0b1: DMA feature for RX FIFO enabled.
            pub const id4: u32 = 0b1;
        }
    }

    /// Individual Rx Masking And Queue Enable
    pub mod IRMQ {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
            pub const individual_rx_masking_disabled: u32 = 0b0;

            /// 0b1: Individual Rx masking and queue feature are enabled.
            pub const individual_rx_masking_enabled: u32 = 0b1;
        }
    }

    /// Self Reception Disable
    pub mod SRXDIS {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Self-reception enabled.
            pub const self_reception_enabled: u32 = 0b0;

            /// 0b1: Self-reception disabled.
            pub const self_reception_disabled: u32 = 0b1;
        }
    }

    /// Doze Mode Enable
    pub mod DOZE {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not enabled to enter low-power mode when Doze mode is requested.
            pub const low_power_doze_disabled: u32 = 0b0;

            /// 0b1: FlexCAN is enabled to enter low-power mode when Doze mode is requested.
            pub const low_power_doze_enabled: u32 = 0b1;
        }
    }

    /// Wake Up Source
    pub mod WAKSRC {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
            pub const unfiltered_rx_input: u32 = 0b0;

            /// 0b1: FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.
            pub const filtered_rx_input: u32 = 0b1;
        }
    }

    /// Low-Power Mode Acknowledge
    pub mod LPMACK {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not in a low-power mode.
            pub const low_power_no: u32 = 0b0;

            /// 0b1: FlexCAN is in a low-power mode.
            pub const low_power_yes: u32 = 0b1;
        }
    }

    /// Warning Interrupt Enable
    pub mod WRNEN {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
            pub const TWRNINT_RWRNINT_inactive: u32 = 0b0;

            /// 0b1: TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
            pub const TWRNINT_RWRNINT_active: u32 = 0b1;
        }
    }

    /// Self Wake Up
    pub mod SLFWAK {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN Self Wake Up feature is disabled.
            pub const self_wakeup_disabled: u32 = 0b0;

            /// 0b1: FlexCAN Self Wake Up feature is enabled.
            pub const self_wakeup_enabled: u32 = 0b1;
        }
    }

    /// Supervisor Mode
    pub mod SUPV {
        /// Offset (23 bits)
        pub const offset: u32 = 23;
        /// Mask (1 bit: 1 << 23)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses.
            pub const id2: u32 = 0b0;

            /// 0b1: FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location.
            pub const id4: u32 = 0b1;
        }
    }

    /// Freeze Mode Acknowledge
    pub mod FRZACK {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (1 bit: 1 << 24)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN not in Freeze mode, prescaler running.
            pub const freeze_mode_no: u32 = 0b0;

            /// 0b1: FlexCAN in Freeze mode, prescaler stopped.
            pub const freeze_mode_yes: u32 = 0b1;
        }
    }

    /// Soft Reset
    pub mod SOFTRST {
        /// Offset (25 bits)
        pub const offset: u32 = 25;
        /// Mask (1 bit: 1 << 25)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No reset request.
            pub const SOFTRST_no_reset_request: u32 = 0b0;

            /// 0b1: Resets the registers affected by soft reset.
            pub const SOFTRST_reset_registers: u32 = 0b1;
        }
    }

    /// Wake Up Interrupt Mask
    pub mod WAKMSK {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (1 bit: 1 << 26)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Wake Up interrupt is disabled.
            pub const wakeup_interrupt_disabled: u32 = 0b0;

            /// 0b1: Wake Up interrupt is enabled.
            pub const wakeup_interrupt_enabled: u32 = 0b1;
        }
    }

    /// FlexCAN Not Ready
    pub mod NOTRDY {
        /// Offset (27 bits)
        pub const offset: u32 = 27;
        /// Mask (1 bit: 1 << 27)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN module is either in Normal mode, Listen-Only mode, or Loop-Back mode.
            pub const id1: u32 = 0b0;

            /// 0b1: FlexCAN module is either in Disable mode, Doze mode, Stop mode, or Freeze mode.
            pub const id2: u32 = 0b1;
        }
    }

    /// Halt FlexCAN
    pub mod HALT {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No Freeze mode request.
            pub const HALT_disable: u32 = 0b0;

            /// 0b1: Enters Freeze mode if the FRZ bit is asserted.
            pub const HALT_enable: u32 = 0b1;
        }
    }

    /// Rx FIFO Enable
    pub mod RFEN {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Rx FIFO not enabled.
            pub const id2: u32 = 0b0;

            /// 0b1: Rx FIFO enabled.
            pub const id4: u32 = 0b1;
        }
    }

    /// Freeze Enable
    pub mod FRZ {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Not enabled to enter Freeze mode.
            pub const freeze_mode_disabled: u32 = 0b0;

            /// 0b1: Enabled to enter Freeze mode.
            pub const freeze_mode_enabled: u32 = 0b1;
        }
    }

    /// Module Disable
    pub mod MDIS {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enable the FlexCAN module.
            pub const flexcan_enabled: u32 = 0b0;

            /// 0b1: Disable the FlexCAN module.
            pub const flexcan_disabled: u32 = 0b1;
        }
    }
}

/// Control 1 register
pub mod CTRL1 {

    /// Propagation Segment
    pub mod PROPSEG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (3 bits: 0b111 << 0)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Listen-Only Mode
    pub mod LOM {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Listen-Only mode is deactivated.
            pub const listen_only_mode_disabled: u32 = 0b0;

            /// 0b1: FlexCAN module operates in Listen-Only mode.
            pub const listen_only_mode_enabled: u32 = 0b1;
        }
    }

    /// Lowest Buffer Transmitted First
    pub mod LBUF {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Buffer with highest priority is transmitted first.
            pub const highest_buffer_first: u32 = 0b0;

            /// 0b1: Lowest number buffer is transmitted first.
            pub const lowest_buffer_first: u32 = 0b1;
        }
    }

    /// Timer Sync
    pub mod TSYN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Timer sync feature disabled
            pub const timer_sync_disabled: u32 = 0b0;

            /// 0b1: Timer sync feature enabled
            pub const timer_sync_enabled: u32 = 0b1;
        }
    }

    /// Bus Off Recovery
    pub mod BOFFREC {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Automatic recovering from Bus Off state enabled.
            pub const auto_recover_enabled: u32 = 0b0;

            /// 0b1: Automatic recovering from Bus Off state disabled.
            pub const auto_recover_disabled: u32 = 0b1;
        }
    }

    /// CAN Bit Sampling
    pub mod SMP {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Just one sample is used to determine the bit value.
            pub const one_sample: u32 = 0b0;

            /// 0b1: Three samples are used to determine the value of the received bit: the regular one (sample point) and two preceding samples; a majority rule is used.
            pub const three_sample: u32 = 0b1;
        }
    }

    /// Rx Warning Interrupt Mask
    pub mod RWRNMSK {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Rx Warning interrupt disabled.
            pub const rx_warning_int_disabled: u32 = 0b0;

            /// 0b1: Rx Warning interrupt enabled.
            pub const rx_warning_int_enabled: u32 = 0b1;
        }
    }

    /// Tx Warning Interrupt Mask
    pub mod TWRNMSK {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Tx Warning interrupt disabled.
            pub const tx_warning_int_disabled: u32 = 0b0;

            /// 0b1: Tx Warning interrupt enabled.
            pub const tx_warning_int_enabled: u32 = 0b1;
        }
    }

    /// Loop Back Mode
    pub mod LPB {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Loop Back disabled.
            pub const loopback_disabled: u32 = 0b0;

            /// 0b1: Loop Back enabled.
            pub const loopback_enabled: u32 = 0b1;
        }
    }

    /// CAN Engine Clock Source
    pub mod CLKSRC {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
            pub const oscillator_clock: u32 = 0b0;

            /// 0b1: The CAN engine clock source is the peripheral clock.
            pub const peripheral_clock: u32 = 0b1;
        }
    }

    /// Error Interrupt Mask
    pub mod ERRMSK {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Error interrupt disabled.
            pub const error_int_disabled: u32 = 0b0;

            /// 0b1: Error interrupt enabled.
            pub const error_int_enabled: u32 = 0b1;
        }
    }

    /// Bus Off Interrupt Mask
    pub mod BOFFMSK {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Bus Off interrupt disabled.
            pub const bus_off_int_disabled: u32 = 0b0;

            /// 0b1: Bus Off interrupt enabled.
            pub const bus_off_int_enabled: u32 = 0b1;
        }
    }

    /// Phase Segment 2
    pub mod PSEG2 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (3 bits: 0b111 << 16)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Phase Segment 1
    pub mod PSEG1 {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (3 bits: 0b111 << 19)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Resync Jump Width
    pub mod RJW {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (2 bits: 0b11 << 22)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Prescaler Division Factor
    pub mod PRESDIV {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Free Running Timer
pub mod TIMER {

    /// Timer Value
    pub mod TIMER {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx Mailboxes Global Mask register
pub mod RXMGMASK {

    /// Rx Mailboxes Global Mask Bits
    pub mod MG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx 14 Mask register
pub mod RX14MASK {

    /// Rx Buffer 14 Mask Bits
    pub mod RX14M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx 15 Mask register
pub mod RX15MASK {

    /// Rx Buffer 15 Mask Bits
    pub mod RX15M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Counter
pub mod ECR {

    /// Transmit Error Counter
    pub mod TXERRCNT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Receive Error Counter
    pub mod RXERRCNT {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transmit Error Counter for fast bits
    pub mod TXERRCNT_FAST {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Receive Error Counter for fast bits
    pub mod RXERRCNT_FAST {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error and Status 1 register
pub mod ESR1 {

    /// Wake-Up Interrupt
    pub mod WAKINT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Indicates a recessive to dominant transition was received on the CAN bus.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Error Interrupt
    pub mod ERRINT {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Indicates setting of any error bit in the Error and Status register.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Bus Off Interrupt
    pub mod BOFFINT {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: FlexCAN module entered Bus Off state.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// FlexCAN In Reception
    pub mod RX {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not receiving a message.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: FlexCAN is receiving a message.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Fault Confinement State
    pub mod FLTCONF {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (2 bits: 0b11 << 4)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Error Active
            pub const error_active: u32 = 0b00;

            /// 0b01: Error Passive
            pub const error_passive: u32 = 0b01;

            /// 0b00: Bus Off
            pub const bus_off: u32 = 0b00;
        }
    }

    /// FlexCAN In Transmission
    pub mod TX {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not transmitting a message.
            pub const transmit_message_no: u32 = 0b0;

            /// 0b1: FlexCAN is transmitting a message.
            pub const transmit_message_yes: u32 = 0b1;
        }
    }

    /// IDLE
    pub mod IDLE {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const can_bus_not_idle: u32 = 0b0;

            /// 0b1: CAN bus is now IDLE.
            pub const can_bus_idle: u32 = 0b1;
        }
    }

    /// Rx Error Warning
    pub mod RXWRN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const RXERRCNT_LT_96: u32 = 0b0;

            /// 0b1: RXERRCNT is greater than or equal to 96.
            pub const RXERRCNT_GTE_96: u32 = 0b1;
        }
    }

    /// TX Error Warning
    pub mod TXWRN {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const TXERRCNT_LT_96: u32 = 0b0;

            /// 0b1: TXERRCNT is greater than or equal to 96.
            pub const TXERRCNT_GTE_96: u32 = 0b1;
        }
    }

    /// Stuffing Error
    pub mod STFERR {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const stuffing_error_no: u32 = 0b0;

            /// 0b1: A stuffing error occurred since last read of this register.
            pub const stuffing_error_yes: u32 = 0b1;
        }
    }

    /// Form Error
    pub mod FRMERR {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const form_error_no: u32 = 0b0;

            /// 0b1: A Form Error occurred since last read of this register.
            pub const form_error_yes: u32 = 0b1;
        }
    }

    /// Cyclic Redundancy Check Error
    pub mod CRCERR {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const CRC_error_no: u32 = 0b0;

            /// 0b1: A CRC error occurred since last read of this register.
            pub const CRC_error_yes: u32 = 0b1;
        }
    }

    /// Acknowledge Error
    pub mod ACKERR {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const ACK_error_no: u32 = 0b0;

            /// 0b1: An ACK error occurred since last read of this register.
            pub const ACK_error_yes: u32 = 0b1;
        }
    }

    /// Bit0 Error
    pub mod BIT0ERR {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const bit0_error_no: u32 = 0b0;

            /// 0b1: At least one bit sent as dominant is received as recessive.
            pub const bit0_error_yes: u32 = 0b1;
        }
    }

    /// Bit1 Error
    pub mod BIT1ERR {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const bit1_error_no: u32 = 0b0;

            /// 0b1: At least one bit sent as recessive is received as dominant.
            pub const bit1_error_yes: u32 = 0b1;
        }
    }

    /// Rx Warning Interrupt Flag
    pub mod RWRNINT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const Rx_warning_int_no: u32 = 0b0;

            /// 0b1: The Rx error counter transitioned from less than 96 to greater than or equal to 96.
            pub const Rx_warning_int_yes: u32 = 0b1;
        }
    }

    /// Tx Warning Interrupt Flag
    pub mod TWRNINT {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const Tx_warning_int_no: u32 = 0b0;

            /// 0b1: The Tx error counter transitioned from less than 96 to greater than or equal to 96.
            pub const Tx_warning_int_yes: u32 = 0b1;
        }
    }

    /// CAN Synchronization Status
    pub mod SYNCH {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not synchronized to the CAN bus.
            pub const CAN_bus_sync_no: u32 = 0b0;

            /// 0b1: FlexCAN is synchronized to the CAN bus.
            pub const CAN_bus_sync_yes: u32 = 0b1;
        }
    }

    /// Bus Off Done Interrupt
    pub mod BOFFDONEINT {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const bus_off_not_done: u32 = 0b0;

            /// 0b1: FlexCAN module has completed Bus Off process.
            pub const bus_off_done: u32 = 0b1;
        }
    }

    /// Error interrupt for errors detected in Data Phase of CAN FD frames with BRS bit set
    pub mod ERRINT_FAST {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const errors_data_phase_no: u32 = 0b0;

            /// 0b1: Indicates setting of any error bit detected in the data phase of CAN FD frames with the BRS bit set.
            pub const errors_data_phase_yes: u32 = 0b1;
        }
    }

    /// Error Overrun
    pub mod ERROVR {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Overrun has not occurred.
            pub const overrun_not_occurred: u32 = 0b0;

            /// 0b1: Overrun has occurred.
            pub const overrun_occurred: u32 = 0b1;
        }
    }

    /// Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod STFERR_FAST {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (1 bit: 1 << 26)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::STFERR::RW;
    }

    /// Form Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod FRMERR_FAST {
        /// Offset (27 bits)
        pub const offset: u32 = 27;
        /// Mask (1 bit: 1 << 27)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const form_error_no: u32 = 0b0;

            /// 0b1: A form error occurred since last read of this register.
            pub const form_error_yes: u32 = 0b1;
        }
    }

    /// Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the BRS bit set
    pub mod CRCERR_FAST {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::CRCERR::RW;
    }

    /// Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod BIT0ERR_FAST {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::BIT0ERR::RW;
    }

    /// Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod BIT1ERR_FAST {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::BIT1ERR::RW;
    }
}

/// Interrupt Masks 2 register
pub mod IMASK2 {

    /// Buffer MBi Mask
    pub mod BUF63TO32M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Masks 1 register
pub mod IMASK1 {

    /// Buffer MBi Mask
    pub mod BUF31TO0M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Flags 2 register
pub mod IFLAG2 {

    /// Buffer MBi Interrupt
    pub mod BUF63TO32I {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Flags 1 register
pub mod IFLAG1 {

    /// Buffer MB0 Interrupt Or Clear FIFO bit
    pub mod BUF0I {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR\[RFEN\]=0.
            pub const buffer_Tx_Rx_not_complete: u32 = 0b0;

            /// 0b1: The corresponding buffer has successfully completed transmission or reception when MCR\[RFEN\]=0.
            pub const buffer_Tx_Rx_complete: u32 = 0b1;
        }
    }

    /// Buffer MBi Interrupt Or Reserved
    pub mod BUF4TO1I {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (4 bits: 0b1111 << 1)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Buffer MB5 Interrupt Or Frames available in Rx FIFO
    pub mod BUF5I {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB5 completing transmission/reception when MCR\[RFEN\]=0, or of frame(s) available in the FIFO, when MCR\[RFEN\]=1
            pub const id2: u32 = 0b0;

            /// 0b1: MB5 completed transmission/reception when MCR\[RFEN\]=0, or frame(s) available in the Rx FIFO when MCR\[RFEN\]=1. It generates a DMA request in case of MCR\[RFEN\] and MCR\[DMA\] are enabled.
            pub const id4: u32 = 0b1;
        }
    }

    /// Buffer MB6 Interrupt Or Rx FIFO Warning
    pub mod BUF6I {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB6 completing transmission/reception when MCR\[RFEN\]=0, or of Rx FIFO almost full when MCR\[RFEN\]=1
            pub const id2: u32 = 0b0;

            /// 0b1: MB6 completed transmission/reception when MCR\[RFEN\]=0, or Rx FIFO almost full when MCR\[RFEN\]=1
            pub const id4: u32 = 0b1;
        }
    }

    /// Buffer MB7 Interrupt Or Rx FIFO Overflow
    pub mod BUF7I {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB7 completing transmission/reception when MCR\[RFEN\]=0, or of Rx FIFO overflow when MCR\[RFEN\]=1
            pub const id2: u32 = 0b0;

            /// 0b1: MB7 completed transmission/reception when MCR\[RFEN\]=0, or Rx FIFO overflow when MCR\[RFEN\]=1
            pub const id4: u32 = 0b1;
        }
    }

    /// Buffer MBi Interrupt
    pub mod BUF31TO8I {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (24 bits: 0xffffff << 8)
        pub const mask: u32 = 0xffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Control 2 register
pub mod CTRL2 {

    /// Edge Filter Disable
    pub mod EDFLTDIS {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Edge filter is enabled
            pub const ENABLE: u32 = 0b0;

            /// 0b1: Edge filter is disabled
            pub const DISABLE: u32 = 0b1;
        }
    }

    /// ISO CAN FD Enable
    pub mod ISOCANFDEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN operates using the non-ISO CAN FD protocol.
            pub const non_ISO: u32 = 0b0;

            /// 0b1: FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1).
            pub const ISO: u32 = 0b1;
        }
    }

    /// Protocol Exception Enable
    pub mod PREXCEN {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Protocol exception is disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Protocol exception is enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Timer Source
    pub mod TIMER_SRC {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The free running timer is clocked by the CAN bit clock, which defines the baud rate on the CAN bus.
            pub const CAN_bit_clock: u32 = 0b0;

            /// 0b1: The free running timer is clocked by an external time tick. The period can be either adjusted to be equal to the baud rate on the CAN bus, or a different value as required. See the device-specific section for details about the external time tick.
            pub const external_clock: u32 = 0b1;
        }
    }

    /// Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
    pub mod EACEN {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Rx mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
            pub const RTR_compare_no: u32 = 0b0;

            /// 0b1: Enables the comparison of both Rx mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
            pub const RTR_compare_yes: u32 = 0b1;
        }
    }

    /// Remote Request Storing
    pub mod RRS {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Remote response frame is generated.
            pub const remote_response_frame_not_generated: u32 = 0b0;

            /// 0b1: Remote request frame is stored.
            pub const remote_response_frame_generated: u32 = 0b1;
        }
    }

    /// Mailboxes Reception Priority
    pub mod MRP {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Matching starts from Rx FIFO and continues on mailboxes.
            pub const id2: u32 = 0b0;

            /// 0b1: Matching starts from mailboxes and continues on Rx FIFO.
            pub const id4: u32 = 0b1;
        }
    }

    /// Tx Arbitration Start Delay
    pub mod TASD {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (5 bits: 0b11111 << 19)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Number Of Rx FIFO Filters
    pub mod RFFN {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Write-Access To Memory In Freeze Mode
    pub mod WRMFRZ {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Maintain the write access restrictions.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Enable unrestricted write access to FlexCAN memory.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Error-correction Configuration Register Write Enable
    pub mod ECRWRE {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable update.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Enable update.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Bus Off Done Interrupt Mask
    pub mod BOFFDONEMSK {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Bus off done interrupt disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Bus off done interrupt enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Error Interrupt Mask for errors detected in the data phase of fast CAN FD frames
    pub mod ERRMSK_FAST {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: ERRINT_FAST error interrupt disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: ERRINT_FAST error interrupt enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }
}

/// Error and Status 2 register
pub mod ESR2 {

    /// Inactive Mailbox
    pub mod IMB {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: If ESR2\[VPS\] is asserted, the ESR2\[LPTM\] is not an inactive mailbox.
            pub const inactive_mailbox_no: u32 = 0b0;

            /// 0b1: If ESR2\[VPS\] is asserted, there is at least one inactive mailbox. LPTM content is the number of the first one.
            pub const inactive_mailbox_yes: u32 = 0b1;
        }
    }

    /// Valid Priority Status
    pub mod VPS {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Contents of IMB and LPTM are invalid.
            pub const invalid: u32 = 0b0;

            /// 0b1: Contents of IMB and LPTM are valid.
            pub const valid: u32 = 0b1;
        }
    }

    /// Lowest Priority Tx Mailbox
    pub mod LPTM {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CRC register
pub mod CRCR {

    /// Transmitted CRC value
    pub mod TXCRC {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (15 bits: 0x7fff << 0)
        pub const mask: u32 = 0x7fff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CRC Mailbox
    pub mod MBCRC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx FIFO Global Mask register
pub mod RXFGMASK {

    /// Rx FIFO Global Mask Bits
    pub mod FGM {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx FIFO Information register
pub mod RXFIR {

    /// Identifier Acceptance Filter Hit Indicator
    pub mod IDHIT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (9 bits: 0x1ff << 0)
        pub const mask: u32 = 0x1ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CAN Bit Timing register
pub mod CBT {

    /// Extended Phase Segment 2
    pub mod EPSEG2 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Phase Segment 1
    pub mod EPSEG1 {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (5 bits: 0b11111 << 5)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Propagation Segment
    pub mod EPROPSEG {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (6 bits: 0x3f << 10)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Resync Jump Width
    pub mod ERJW {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (5 bits: 0b11111 << 16)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Prescaler Division Factor
    pub mod EPRESDIV {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (10 bits: 0x3ff << 21)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Timing Format Enable
    pub mod BTF {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Extended bit time definitions disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Extended bit time definitions enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }
}

/// CS0 and MB0_8B_CS
/// CS0: CS0 and MB0_64B_CS_L
/// CS0: CS0 and MB0_32B_CS_L
/// CS0: CS0 and MB0_16B_CS_L
/// CS0: Message Buffer 0 CS Register
/// MB0_16B_CS_L: Message Buffer 0 CS Register
/// MB0_32B_CS_L: Message Buffer 0 CS Register
/// MB0_64B_CS_L: Message Buffer 0 CS Register
/// MB0_8B_CS: Message Buffer 0 CS Register
pub mod CS0 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID0 and MB0_8B_ID
/// ID0: ID0 and MB0_64B_ID_L
/// ID0: ID0 and MB0_32B_ID_L
/// ID0: ID0 and MB0_16B_ID_L
/// ID0: Message Buffer 0 ID Register
/// MB0_16B_ID_L: Message Buffer 0 ID Register
/// MB0_32B_ID_L: Message Buffer 0 ID Register
/// MB0_64B_ID_L: Message Buffer 0 ID Register
/// MB0_8B_ID: Message Buffer 0 ID Register
pub mod ID0 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0 and WORD00
/// MB0: MB0 and MB0_8B_WORD0
/// MB0: MB0 and MB0_64B_WORD0_L
/// MB0: MB0_16B_WORD0_L and MB0_32B_WORD0_L
/// MB0_16B_WORD0_L: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD0_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD0_L: Message Buffer 0 WORD_64B Register
/// MB0_8B_WORD0: Message Buffer 0 WORD_8B Register
/// WORD00: Message Buffer 0 WORD0 Register
pub mod MB0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_16B_WORD1_L and WORD10
/// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_8B_WORD1
/// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_64B_WORD1_L
/// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_32B_WORD1_L
/// MB0_16B_WORD1_L: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD1_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD1_L: Message Buffer 0 WORD_64B Register
/// MB0_8B_WORD1: Message Buffer 0 WORD_8B Register
/// WORD10: Message Buffer 0 WORD1 Register
pub mod MB0_16B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS1 and MB1_8B_CS
/// CS1: CS1 and MB0_64B_WORD2_L
/// CS1: CS1 and MB0_32B_WORD2_L
/// CS1: CS1 and MB0_16B_WORD2_L
/// CS1: Message Buffer 1 CS Register
/// MB0_16B_WORD2_L: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD2_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD2_L: Message Buffer 0 WORD_64B Register
/// MB1_8B_CS: Message Buffer 1 CS Register
pub mod CS1 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID1 and MB1_8B_ID
/// ID1: ID1 and MB0_64B_WORD3_L
/// ID1: ID1 and MB0_32B_WORD3_L
/// ID1: ID1 and MB0_16B_WORD3_L
/// ID1: Message Buffer 1 ID Register
/// MB0_16B_WORD3_L: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD3_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD3_L: Message Buffer 0 WORD_64B Register
/// MB1_8B_ID: Message Buffer 1 ID Register
pub mod ID1 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB and WORD01
/// MB: MB and MB1_8B_WORD0
/// MB: MB0_32B_WORD4_L and MB1_16B_CS_L
/// MB0_32B_WORD4_L: MB0_32B_WORD4_L and MB0_64B_WORD4_L
/// MB0_32B_WORD4_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD4_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_CS_L: Message Buffer 1 CS Register
/// MB1_8B_WORD0: Message Buffer 1 WORD_8B Register
/// WORD01: Message Buffer 1 WORD0 Register
pub mod MB {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_32B_WORD5_L and WORD11
/// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB1_8B_WORD1
/// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB1_16B_ID_L
/// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB0_64B_WORD5_L
/// MB0_32B_WORD5_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD5_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_ID_L: Message Buffer 1 ID Register
/// MB1_8B_WORD1: Message Buffer 1 WORD_8B Register
/// WORD11: Message Buffer 1 WORD1 Register
pub mod MB0_32B_WORD5_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS2 and MB2_8B_CS
/// CS2: CS2 and MB1_16B_WORD0_L
/// CS2: CS2 and MB0_64B_WORD6_L
/// CS2: CS2 and MB0_32B_WORD6_L
/// CS2: Message Buffer 2 CS Register
/// MB0_32B_WORD6_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD6_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD0_L: Message Buffer 1 WORD_16B Register
/// MB2_8B_CS: Message Buffer 2 CS Register
pub mod CS2 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID2 and MB2_8B_ID
/// ID2: ID2 and MB1_16B_WORD1_L
/// ID2: ID2 and MB0_64B_WORD7_L
/// ID2: ID2 and MB0_32B_WORD7_L
/// ID2: Message Buffer 2 ID Register
/// MB0_32B_WORD7_L: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD7_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD1_L: Message Buffer 1 WORD_16B Register
/// MB2_8B_ID: Message Buffer 2 ID Register
pub mod ID2 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD8_L and WORD02
/// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB2_8B_WORD0
/// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB1_32B_CS_L
/// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB1_16B_WORD2_L
/// MB0_64B_WORD8_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD2_L: Message Buffer 1 WORD_16B Register
/// MB1_32B_CS_L: Message Buffer 1 CS Register
/// MB2_8B_WORD0: Message Buffer 2 WORD_8B Register
/// WORD02: Message Buffer 2 WORD0 Register
pub mod MB0_64B_WORD8_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD9_L and WORD12
/// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB2_8B_WORD1
/// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB1_32B_ID_L
/// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB1_16B_WORD3_L
/// MB0_64B_WORD9_L: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD3_L: Message Buffer 1 WORD_16B Register
/// MB1_32B_ID_L: Message Buffer 1 ID Register
/// MB2_8B_WORD1: Message Buffer 2 WORD_8B Register
/// WORD12: Message Buffer 2 WORD1 Register
pub mod MB0_64B_WORD9_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS3 and MB3_8B_CS
/// CS3: CS3 and MB2_16B_CS_L
/// CS3: CS3 and MB1_32B_WORD0_L
/// CS3: CS3 and MB0_64B_WORD10_L
/// CS3: Message Buffer 3 CS Register
/// MB0_64B_WORD10_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD0_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_CS_L: Message Buffer 2 CS Register
/// MB3_8B_CS: Message Buffer 3 CS Register
pub mod CS3 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID3 and MB3_8B_ID
/// ID3: ID3 and MB2_16B_ID_L
/// ID3: ID3 and MB1_32B_WORD1_L
/// ID3: ID3 and MB0_64B_WORD11_L
/// ID3: Message Buffer 3 ID Register
/// MB0_64B_WORD11_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD1_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_ID_L: Message Buffer 2 ID Register
/// MB3_8B_ID: Message Buffer 3 ID Register
pub mod ID3 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD12_L and WORD03
/// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB3_8B_WORD0
/// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB2_16B_WORD0_L
/// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB1_32B_WORD2_L
/// MB0_64B_WORD12_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD2_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD0_L: Message Buffer 2 WORD_16B Register
/// MB3_8B_WORD0: Message Buffer 3 WORD_8B Register
/// WORD03: Message Buffer 3 WORD0 Register
pub mod MB0_64B_WORD12_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD13_L and WORD13
/// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB3_8B_WORD1
/// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB2_16B_WORD1_L
/// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB1_32B_WORD3_L
/// MB0_64B_WORD13_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD3_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD1_L: Message Buffer 2 WORD_16B Register
/// MB3_8B_WORD1: Message Buffer 3 WORD_8B Register
/// WORD13: Message Buffer 3 WORD1 Register
pub mod MB0_64B_WORD13_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS4 and MB4_8B_CS
/// CS4: CS4 and MB2_16B_WORD2_L
/// CS4: CS4 and MB1_32B_WORD4_L
/// CS4: CS4 and MB0_64B_WORD14_L
/// CS4: Message Buffer 4 CS Register
/// MB0_64B_WORD14_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD4_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD2_L: Message Buffer 2 WORD_16B Register
/// MB4_8B_CS: Message Buffer 4 CS Register
pub mod CS4 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID4 and MB4_8B_ID
/// ID4: ID4 and MB2_16B_WORD3_L
/// ID4: ID4 and MB1_32B_WORD5_L
/// ID4: ID4 and MB0_64B_WORD15_L
/// ID4: Message Buffer 4 ID Register
/// MB0_64B_WORD15_L: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD5_L: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD3_L: Message Buffer 2 WORD_16B Register
/// MB4_8B_ID: Message Buffer 4 ID Register
pub mod ID4 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1 and WORD04
/// MB1: MB1 and MB4_8B_WORD0
/// MB1: MB1 and MB3_16B_CS_L
/// MB1: MB1_32B_WORD6_L and MB1_64B_CS_L
/// MB1_32B_WORD6_L: Message Buffer 1 WORD_32B Register
/// MB1_64B_CS_L: Message Buffer 1 CS Register
/// MB3_16B_CS_L: Message Buffer 3 CS Register
/// MB4_8B_WORD0: Message Buffer 4 WORD_8B Register
/// WORD04: Message Buffer 4 WORD0 Register
pub mod MB1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_32B_WORD7_L and WORD14
/// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB4_8B_WORD1
/// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB3_16B_ID_L
/// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB1_64B_ID_L
/// MB1_32B_WORD7_L: Message Buffer 1 WORD_32B Register
/// MB1_64B_ID_L: Message Buffer 1 ID Register
/// MB3_16B_ID_L: Message Buffer 3 ID Register
/// MB4_8B_WORD1: Message Buffer 4 WORD_8B Register
/// WORD14: Message Buffer 4 WORD1 Register
pub mod MB1_32B_WORD7_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS5 and MB5_8B_CS
/// CS5: CS5 and MB3_16B_WORD0_L
/// CS5: CS5 and MB2_32B_CS_L
/// CS5: CS5 and MB1_64B_WORD0_L
/// CS5: Message Buffer 5 CS Register
/// MB1_64B_WORD0_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_CS_L: Message Buffer 2 CS Register
/// MB3_16B_WORD0_L: Message Buffer 3 WORD_16B Register
/// MB5_8B_CS: Message Buffer 5 CS Register
pub mod CS5 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID5 and MB5_8B_ID
/// ID5: ID5 and MB3_16B_WORD1_L
/// ID5: ID5 and MB2_32B_ID_L
/// ID5: ID5 and MB1_64B_WORD1_L
/// ID5: Message Buffer 5 ID Register
/// MB1_64B_WORD1_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_ID_L: Message Buffer 2 ID Register
/// MB3_16B_WORD1_L: Message Buffer 3 WORD_16B Register
/// MB5_8B_ID: Message Buffer 5 ID Register
pub mod ID5 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD2_L and WORD05
/// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB5_8B_WORD0
/// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB3_16B_WORD2_L
/// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB2_32B_WORD0_L
/// MB1_64B_WORD2_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD0_L: Message Buffer 2 WORD_32B Register
/// MB3_16B_WORD2_L: Message Buffer 3 WORD_16B Register
/// MB5_8B_WORD0: Message Buffer 5 WORD_8B Register
/// WORD05: Message Buffer 5 WORD0 Register
pub mod MB1_64B_WORD2_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD3_L and WORD15
/// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB5_8B_WORD1
/// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB3_16B_WORD3_L
/// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB2_32B_WORD1_L
/// MB1_64B_WORD3_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD1_L: Message Buffer 2 WORD_32B Register
/// MB3_16B_WORD3_L: Message Buffer 3 WORD_16B Register
/// MB5_8B_WORD1: Message Buffer 5 WORD_8B Register
/// WORD15: Message Buffer 5 WORD1 Register
pub mod MB1_64B_WORD3_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS6 and MB6_8B_CS
/// CS6: CS6 and MB4_16B_CS_L
/// CS6: CS6 and MB2_32B_WORD2_L
/// CS6: CS6 and MB1_64B_WORD4_L
/// CS6: Message Buffer 6 CS Register
/// MB1_64B_WORD4_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD2_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_CS_L: Message Buffer 4 CS Register
/// MB6_8B_CS: Message Buffer 6 CS Register
pub mod CS6 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID6 and MB6_8B_ID
/// ID6: ID6 and MB4_16B_ID_L
/// ID6: ID6 and MB2_32B_WORD3_L
/// ID6: ID6 and MB1_64B_WORD5_L
/// ID6: Message Buffer 6 ID Register
/// MB1_64B_WORD5_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD3_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_ID_L: Message Buffer 4 ID Register
/// MB6_8B_ID: Message Buffer 6 ID Register
pub mod ID6 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD6_L and WORD06
/// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB6_8B_WORD0
/// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB4_16B_WORD0_L
/// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB2_32B_WORD4_L
/// MB1_64B_WORD6_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD4_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD0_L: Message Buffer 4 WORD_16B Register
/// MB6_8B_WORD0: Message Buffer 6 WORD_8B Register
/// WORD06: Message Buffer 6 WORD0 Register
pub mod MB1_64B_WORD6_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD7_L and WORD16
/// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB6_8B_WORD1
/// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB4_16B_WORD1_L
/// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB2_32B_WORD5_L
/// MB1_64B_WORD7_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD5_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD1_L: Message Buffer 4 WORD_16B Register
/// MB6_8B_WORD1: Message Buffer 6 WORD_8B Register
/// WORD16: Message Buffer 6 WORD1 Register
pub mod MB1_64B_WORD7_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS7 and MB7_8B_CS
/// CS7: CS7 and MB4_16B_WORD2_L
/// CS7: CS7 and MB2_32B_WORD6_L
/// CS7: CS7 and MB1_64B_WORD8_L
/// CS7: Message Buffer 7 CS Register
/// MB1_64B_WORD8_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD6_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD2_L: Message Buffer 4 WORD_16B Register
/// MB7_8B_CS: Message Buffer 7 CS Register
pub mod CS7 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID7 and MB7_8B_ID
/// ID7: ID7 and MB4_16B_WORD3_L
/// ID7: ID7 and MB2_32B_WORD7_L
/// ID7: ID7 and MB1_64B_WORD9_L
/// ID7: Message Buffer 7 ID Register
/// MB1_64B_WORD9_L: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD7_L: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD3_L: Message Buffer 4 WORD_16B Register
/// MB7_8B_ID: Message Buffer 7 ID Register
pub mod ID7 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD10_L and WORD07
/// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB7_8B_WORD0
/// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB5_16B_CS_L
/// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB3_32B_CS_L
/// MB1_64B_WORD10_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_CS_L: Message Buffer 3 CS Register
/// MB5_16B_CS_L: Message Buffer 5 CS Register
/// MB7_8B_WORD0: Message Buffer 7 WORD_8B Register
/// WORD07: Message Buffer 7 WORD0 Register
pub mod MB1_64B_WORD10_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD11_L and WORD17
/// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB7_8B_WORD1
/// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB5_16B_ID_L
/// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB3_32B_ID_L
/// MB1_64B_WORD11_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_ID_L: Message Buffer 3 ID Register
/// MB5_16B_ID_L: Message Buffer 5 ID Register
/// MB7_8B_WORD1: Message Buffer 7 WORD_8B Register
/// WORD17: Message Buffer 7 WORD1 Register
pub mod MB1_64B_WORD11_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS8 and MB8_8B_CS
/// CS8: CS8 and MB5_16B_WORD0_L
/// CS8: CS8 and MB3_32B_WORD0_L
/// CS8: CS8 and MB1_64B_WORD12_L
/// CS8: Message Buffer 8 CS Register
/// MB1_64B_WORD12_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD0_L: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD0_L: Message Buffer 5 WORD_16B Register
/// MB8_8B_CS: Message Buffer 8 CS Register
pub mod CS8 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID8 and MB8_8B_ID
/// ID8: ID8 and MB5_16B_WORD1_L
/// ID8: ID8 and MB3_32B_WORD1_L
/// ID8: ID8 and MB1_64B_WORD13_L
/// ID8: Message Buffer 8 ID Register
/// MB1_64B_WORD13_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD1_L: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD1_L: Message Buffer 5 WORD_16B Register
/// MB8_8B_ID: Message Buffer 8 ID Register
pub mod ID8 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD14_L and WORD08
/// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB8_8B_WORD0
/// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB5_16B_WORD2_L
/// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB3_32B_WORD2_L
/// MB1_64B_WORD14_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD2_L: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD2_L: Message Buffer 5 WORD_16B Register
/// MB8_8B_WORD0: Message Buffer 8 WORD_8B Register
/// WORD08: Message Buffer 8 WORD0 Register
pub mod MB1_64B_WORD14_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD15_L and WORD18
/// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB8_8B_WORD1
/// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB5_16B_WORD3_L
/// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB3_32B_WORD3_L
/// MB1_64B_WORD15_L: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD3_L: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD3_L: Message Buffer 5 WORD_16B Register
/// MB8_8B_WORD1: Message Buffer 8 WORD_8B Register
/// WORD18: Message Buffer 8 WORD1 Register
pub mod MB1_64B_WORD15_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS9 and MB9_8B_CS
/// CS9: CS9 and MB6_16B_CS_L
/// CS9: CS9 and MB3_32B_WORD4_L
/// CS9: CS9 and MB2_64B_CS_L
/// CS9: Message Buffer 9 CS Register
/// MB2_64B_CS_L: Message Buffer 2 CS Register
/// MB3_32B_WORD4_L: Message Buffer 3 WORD_32B Register
/// MB6_16B_CS_L: Message Buffer 6 CS Register
/// MB9_8B_CS: Message Buffer 9 CS Register
pub mod CS9 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID9 and MB9_8B_ID
/// ID9: ID9 and MB6_16B_ID_L
/// ID9: ID9 and MB3_32B_WORD5_L
/// ID9: ID9 and MB2_64B_ID_L
/// ID9: Message Buffer 9 ID Register
/// MB2_64B_ID_L: Message Buffer 2 ID Register
/// MB3_32B_WORD5_L: Message Buffer 3 WORD_32B Register
/// MB6_16B_ID_L: Message Buffer 6 ID Register
/// MB9_8B_ID: Message Buffer 9 ID Register
pub mod ID9 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD0_L and WORD09
/// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB9_8B_WORD0
/// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB6_16B_WORD0_L
/// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB3_32B_WORD6_L
/// MB2_64B_WORD0_L: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD6_L: Message Buffer 3 WORD_32B Register
/// MB6_16B_WORD0_L: Message Buffer 6 WORD_16B Register
/// MB9_8B_WORD0: Message Buffer 9 WORD_8B Register
/// WORD09: Message Buffer 9 WORD0 Register
pub mod MB2_64B_WORD0_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD1_L and WORD19
/// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB9_8B_WORD1
/// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB6_16B_WORD1_L
/// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB3_32B_WORD7_L
/// MB2_64B_WORD1_L: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD7_L: Message Buffer 3 WORD_32B Register
/// MB6_16B_WORD1_L: Message Buffer 6 WORD_16B Register
/// MB9_8B_WORD1: Message Buffer 9 WORD_8B Register
/// WORD19: Message Buffer 9 WORD1 Register
pub mod MB2_64B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS10 and MB6_16B_WORD2_L
/// CS10: CS10 and MB4_32B_CS_L
/// CS10: CS10 and MB2_64B_WORD2_L
/// CS10: CS10 and MB10_8B_CS
/// CS10: Message Buffer 10 CS Register
/// MB10_8B_CS: Message Buffer 10 CS Register
/// MB2_64B_WORD2_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_CS_L: Message Buffer 4 CS Register
/// MB6_16B_WORD2_L: Message Buffer 6 WORD_16B Register
pub mod CS10 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID10 and MB6_16B_WORD3_L
/// ID10: ID10 and MB4_32B_ID_L
/// ID10: ID10 and MB2_64B_WORD3_L
/// ID10: ID10 and MB10_8B_ID
/// ID10: Message Buffer 10 ID Register
/// MB10_8B_ID: Message Buffer 10 ID Register
/// MB2_64B_WORD3_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_ID_L: Message Buffer 4 ID Register
/// MB6_16B_WORD3_L: Message Buffer 6 WORD_16B Register
pub mod ID10 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB10_8B_WORD0 and WORD010
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB7_16B_CS_L
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB4_32B_WORD0_L
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB2_64B_WORD4_L
/// MB10_8B_WORD0: Message Buffer 10 WORD_8B Register
/// MB2_64B_WORD4_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD0_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_CS_L: Message Buffer 7 CS Register
/// WORD010: Message Buffer 10 WORD0 Register
pub mod MB10_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_8B_WORD1 and WORD110
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB7_16B_ID_L
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB4_32B_WORD1_L
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB2_64B_WORD5_L
/// MB10_8B_WORD1: Message Buffer 10 WORD_8B Register
/// MB2_64B_WORD5_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD1_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_ID_L: Message Buffer 7 ID Register
/// WORD110: Message Buffer 10 WORD1 Register
pub mod MB10_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS11 and MB7_16B_WORD0_L
/// CS11: CS11 and MB4_32B_WORD2_L
/// CS11: CS11 and MB2_64B_WORD6_L
/// CS11: CS11 and MB11_8B_CS
/// CS11: Message Buffer 11 CS Register
/// MB11_8B_CS: Message Buffer 11 CS Register
/// MB2_64B_WORD6_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD2_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD0_L: Message Buffer 7 WORD_16B Register
pub mod CS11 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID11 and MB7_16B_WORD1_L
/// ID11: ID11 and MB4_32B_WORD3_L
/// ID11: ID11 and MB2_64B_WORD7_L
/// ID11: ID11 and MB11_8B_ID
/// ID11: Message Buffer 11 ID Register
/// MB11_8B_ID: Message Buffer 11 ID Register
/// MB2_64B_WORD7_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD3_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD1_L: Message Buffer 7 WORD_16B Register
pub mod ID11 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_8B_WORD0 and WORD011
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB7_16B_WORD2_L
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB4_32B_WORD4_L
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB2_64B_WORD8_L
/// MB11_8B_WORD0: Message Buffer 11 WORD_8B Register
/// MB2_64B_WORD8_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD4_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD2_L: Message Buffer 7 WORD_16B Register
/// WORD011: Message Buffer 11 WORD0 Register
pub mod MB11_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_8B_WORD1 and WORD111
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB7_16B_WORD3_L
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB4_32B_WORD5_L
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB2_64B_WORD9_L
/// MB11_8B_WORD1: Message Buffer 11 WORD_8B Register
/// MB2_64B_WORD9_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD5_L: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD3_L: Message Buffer 7 WORD_16B Register
/// WORD111: Message Buffer 11 WORD1 Register
pub mod MB11_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS12 and MB8_16B_CS_L
/// CS12: CS12 and MB4_32B_WORD6_L
/// CS12: CS12 and MB2_64B_WORD10_L
/// CS12: CS12 and MB12_8B_CS
/// CS12: Message Buffer 12 CS Register
/// MB12_8B_CS: Message Buffer 12 CS Register
/// MB2_64B_WORD10_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD6_L: Message Buffer 4 WORD_32B Register
/// MB8_16B_CS_L: Message Buffer 8 CS Register
pub mod CS12 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID12 and MB8_16B_ID_L
/// ID12: ID12 and MB4_32B_WORD7_L
/// ID12: ID12 and MB2_64B_WORD11_L
/// ID12: ID12 and MB12_8B_ID
/// ID12: Message Buffer 12 ID Register
/// MB12_8B_ID: Message Buffer 12 ID Register
/// MB2_64B_WORD11_L: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD7_L: Message Buffer 4 WORD_32B Register
/// MB8_16B_ID_L: Message Buffer 8 ID Register
pub mod ID12 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_8B_WORD0 and WORD012
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB8_16B_WORD0_L
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB5_32B_CS_L
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB2_64B_WORD12_L
/// MB12_8B_WORD0: Message Buffer 12 WORD_8B Register
/// MB2_64B_WORD12_L: Message Buffer 2 WORD_64B Register
/// MB5_32B_CS_L: Message Buffer 5 CS Register
/// MB8_16B_WORD0_L: Message Buffer 8 WORD_16B Register
/// WORD012: Message Buffer 12 WORD0 Register
pub mod MB12_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_8B_WORD1 and WORD112
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB8_16B_WORD1_L
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB5_32B_ID_L
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB2_64B_WORD13_L
/// MB12_8B_WORD1: Message Buffer 12 WORD_8B Register
/// MB2_64B_WORD13_L: Message Buffer 2 WORD_64B Register
/// MB5_32B_ID_L: Message Buffer 5 ID Register
/// MB8_16B_WORD1_L: Message Buffer 8 WORD_16B Register
/// WORD112: Message Buffer 12 WORD1 Register
pub mod MB12_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS13 and MB8_16B_WORD2_L
/// CS13: CS13 and MB5_32B_WORD0_L
/// CS13: CS13 and MB2_64B_WORD14_L
/// CS13: CS13 and MB13_8B_CS
/// CS13: Message Buffer 13 CS Register
/// MB13_8B_CS: Message Buffer 13 CS Register
/// MB2_64B_WORD14_L: Message Buffer 2 WORD_64B Register
/// MB5_32B_WORD0_L: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD2_L: Message Buffer 8 WORD_16B Register
pub mod CS13 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID13 and MB8_16B_WORD3_L
/// ID13: ID13 and MB5_32B_WORD1_L
/// ID13: ID13 and MB2_64B_WORD15_L
/// ID13: ID13 and MB13_8B_ID
/// ID13: Message Buffer 13 ID Register
/// MB13_8B_ID: Message Buffer 13 ID Register
/// MB2_64B_WORD15_L: Message Buffer 2 WORD_64B Register
/// MB5_32B_WORD1_L: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD3_L: Message Buffer 8 WORD_16B Register
pub mod ID13 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_8B_WORD0 and WORD013
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB9_16B_CS_L
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB5_32B_WORD2_L
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB3_64B_CS_L
/// MB13_8B_WORD0: Message Buffer 13 WORD_8B Register
/// MB3_64B_CS_L: Message Buffer 3 CS Register
/// MB5_32B_WORD2_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_CS_L: Message Buffer 9 CS Register
/// WORD013: Message Buffer 13 WORD0 Register
pub mod MB13_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_8B_WORD1 and WORD113
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB9_16B_ID_L
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB5_32B_WORD3_L
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB3_64B_ID_L
/// MB13_8B_WORD1: Message Buffer 13 WORD_8B Register
/// MB3_64B_ID_L: Message Buffer 3 ID Register
/// MB5_32B_WORD3_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_ID_L: Message Buffer 9 ID Register
/// WORD113: Message Buffer 13 WORD1 Register
pub mod MB13_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS14 and MB9_16B_WORD0_L
/// CS14: CS14 and MB5_32B_WORD4_L
/// CS14: CS14 and MB3_64B_WORD0_L
/// CS14: CS14 and MB14_8B_CS
/// CS14: Message Buffer 14 CS Register
/// MB14_8B_CS: Message Buffer 14 CS Register
/// MB3_64B_WORD0_L: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD4_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD0_L: Message Buffer 9 WORD_16B Register
pub mod CS14 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID14 and MB9_16B_WORD1_L
/// ID14: ID14 and MB5_32B_WORD5_L
/// ID14: ID14 and MB3_64B_WORD1_L
/// ID14: ID14 and MB14_8B_ID
/// ID14: Message Buffer 14 ID Register
/// MB14_8B_ID: Message Buffer 14 ID Register
/// MB3_64B_WORD1_L: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD5_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD1_L: Message Buffer 9 WORD_16B Register
pub mod ID14 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_8B_WORD0 and WORD014
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB9_16B_WORD2_L
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB5_32B_WORD6_L
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB3_64B_WORD2_L
/// MB14_8B_WORD0: Message Buffer 14 WORD_8B Register
/// MB3_64B_WORD2_L: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD6_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD2_L: Message Buffer 9 WORD_16B Register
/// WORD014: Message Buffer 14 WORD0 Register
pub mod MB14_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_8B_WORD1 and WORD114
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB9_16B_WORD3_L
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB5_32B_WORD7_L
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB3_64B_WORD3_L
/// MB14_8B_WORD1: Message Buffer 14 WORD_8B Register
/// MB3_64B_WORD3_L: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD7_L: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD3_L: Message Buffer 9 WORD_16B Register
/// WORD114: Message Buffer 14 WORD1 Register
pub mod MB14_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS15 and MB6_32B_CS_L
/// CS15: CS15 and MB3_64B_WORD4_L
/// CS15: CS15 and MB15_8B_CS
/// CS15: CS15 and MB10_16B_CS_L
/// CS15: Message Buffer 15 CS Register
/// MB10_16B_CS_L: Message Buffer 10 CS Register
/// MB15_8B_CS: Message Buffer 15 CS Register
/// MB3_64B_WORD4_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_CS_L: Message Buffer 6 CS Register
pub mod CS15 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID15 and MB6_32B_ID_L
/// ID15: ID15 and MB3_64B_WORD5_L
/// ID15: ID15 and MB15_8B_ID
/// ID15: ID15 and MB10_16B_ID_L
/// ID15: Message Buffer 15 ID Register
/// MB10_16B_ID_L: Message Buffer 10 ID Register
/// MB15_8B_ID: Message Buffer 15 ID Register
/// MB3_64B_WORD5_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_ID_L: Message Buffer 6 ID Register
pub mod ID15 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB10_16B_WORD0_L and WORD015
/// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB6_32B_WORD0_L
/// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB3_64B_WORD6_L
/// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB15_8B_WORD0
/// MB10_16B_WORD0_L: Message Buffer 10 WORD_16B Register
/// MB15_8B_WORD0: Message Buffer 15 WORD_8B Register
/// MB3_64B_WORD6_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD0_L: Message Buffer 6 WORD_32B Register
/// WORD015: Message Buffer 15 WORD0 Register
pub mod MB10_16B_WORD0_L {
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_3;
}

/// MB10_16B_WORD1_L and WORD115
/// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB6_32B_WORD1_L
/// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB3_64B_WORD7_L
/// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB15_8B_WORD1
/// MB10_16B_WORD1_L: Message Buffer 10 WORD_16B Register
/// MB15_8B_WORD1: Message Buffer 15 WORD_8B Register
/// MB3_64B_WORD7_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD1_L: Message Buffer 6 WORD_32B Register
/// WORD115: Message Buffer 15 WORD1 Register
pub mod MB10_16B_WORD1_L {
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_7;
}

/// CS16 and MB6_32B_WORD2_L
/// CS16: CS16 and MB3_64B_WORD8_L
/// CS16: CS16 and MB16_8B_CS
/// CS16: CS16 and MB10_16B_WORD2_L
/// CS16: Message Buffer 16 CS Register
/// MB10_16B_WORD2_L: Message Buffer 10 WORD_16B Register
/// MB16_8B_CS: Message Buffer 16 CS Register
/// MB3_64B_WORD8_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD2_L: Message Buffer 6 WORD_32B Register
pub mod CS16 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID16 and MB6_32B_WORD3_L
/// ID16: ID16 and MB3_64B_WORD9_L
/// ID16: ID16 and MB16_8B_ID
/// ID16: ID16 and MB10_16B_WORD3_L
/// ID16: Message Buffer 16 ID Register
/// MB10_16B_WORD3_L: Message Buffer 10 WORD_16B Register
/// MB16_8B_ID: Message Buffer 16 ID Register
/// MB3_64B_WORD9_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD3_L: Message Buffer 6 WORD_32B Register
pub mod ID16 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_CS_L and WORD016
/// MB11_16B_CS_L: MB11_16B_CS_L and MB6_32B_WORD4_L
/// MB11_16B_CS_L: MB11_16B_CS_L and MB3_64B_WORD10_L
/// MB11_16B_CS_L: MB11_16B_CS_L and MB16_8B_WORD0
/// MB11_16B_CS_L: Message Buffer 11 CS Register
/// MB16_8B_WORD0: Message Buffer 16 WORD_8B Register
/// MB3_64B_WORD10_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD4_L: Message Buffer 6 WORD_32B Register
/// WORD016: Message Buffer 16 WORD0 Register
pub mod MB11_16B_CS_L {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_ID_L and WORD116
/// MB11_16B_ID_L: MB11_16B_ID_L and MB6_32B_WORD5_L
/// MB11_16B_ID_L: MB11_16B_ID_L and MB3_64B_WORD11_L
/// MB11_16B_ID_L: MB11_16B_ID_L and MB16_8B_WORD1
/// MB11_16B_ID_L: Message Buffer 11 ID Register
/// MB16_8B_WORD1: Message Buffer 16 WORD_8B Register
/// MB3_64B_WORD11_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD5_L: Message Buffer 6 WORD_32B Register
/// WORD116: Message Buffer 16 WORD1 Register
pub mod MB11_16B_ID_L {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS17 and MB6_32B_WORD6_L
/// CS17: CS17 and MB3_64B_WORD12_L
/// CS17: CS17 and MB17_8B_CS
/// CS17: CS17 and MB11_16B_WORD0_L
/// CS17: Message Buffer 17 CS Register
/// MB11_16B_WORD0_L: Message Buffer 11 WORD_16B Register
/// MB17_8B_CS: Message Buffer 17 CS Register
/// MB3_64B_WORD12_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD6_L: Message Buffer 6 WORD_32B Register
pub mod CS17 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID17 and MB6_32B_WORD7_L
/// ID17: ID17 and MB3_64B_WORD13_L
/// ID17: ID17 and MB17_8B_ID
/// ID17: ID17 and MB11_16B_WORD1_L
/// ID17: Message Buffer 17 ID Register
/// MB11_16B_WORD1_L: Message Buffer 11 WORD_16B Register
/// MB17_8B_ID: Message Buffer 17 ID Register
/// MB3_64B_WORD13_L: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD7_L: Message Buffer 6 WORD_32B Register
pub mod ID17 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_WORD2_L and WORD017
/// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB7_32B_CS_L
/// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB3_64B_WORD14_L
/// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB17_8B_WORD0
/// MB11_16B_WORD2_L: Message Buffer 11 WORD_16B Register
/// MB17_8B_WORD0: Message Buffer 17 WORD_8B Register
/// MB3_64B_WORD14_L: Message Buffer 3 WORD_64B Register
/// MB7_32B_CS_L: Message Buffer 7 CS Register
/// WORD017: Message Buffer 17 WORD0 Register
pub mod MB11_16B_WORD2_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_WORD3_L and WORD117
/// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB7_32B_ID_L
/// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB3_64B_WORD15_L
/// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB17_8B_WORD1
/// MB11_16B_WORD3_L: Message Buffer 11 WORD_16B Register
/// MB17_8B_WORD1: Message Buffer 17 WORD_8B Register
/// MB3_64B_WORD15_L: Message Buffer 3 WORD_64B Register
/// MB7_32B_ID_L: Message Buffer 7 ID Register
/// WORD117: Message Buffer 17 WORD1 Register
pub mod MB11_16B_WORD3_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS18 and MB7_32B_WORD0_L
/// CS18: CS18 and MB4_64B_CS_L
/// CS18: CS18 and MB18_8B_CS
/// CS18: CS18 and MB12_16B_CS_L
/// CS18: Message Buffer 18 CS Register
/// MB12_16B_CS_L: Message Buffer 12 CS Register
/// MB18_8B_CS: Message Buffer 18 CS Register
/// MB4_64B_CS_L: Message Buffer 4 CS Register
/// MB7_32B_WORD0_L: Message Buffer 7 WORD_32B Register
pub mod CS18 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID18 and MB7_32B_WORD1_L
/// ID18: ID18 and MB4_64B_ID_L
/// ID18: ID18 and MB18_8B_ID
/// ID18: ID18 and MB12_16B_ID_L
/// ID18: Message Buffer 18 ID Register
/// MB12_16B_ID_L: Message Buffer 12 ID Register
/// MB18_8B_ID: Message Buffer 18 ID Register
/// MB4_64B_ID_L: Message Buffer 4 ID Register
/// MB7_32B_WORD1_L: Message Buffer 7 WORD_32B Register
pub mod ID18 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB12_16B_WORD0_L and WORD018
/// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB7_32B_WORD2_L
/// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB4_64B_WORD0_L
/// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB18_8B_WORD0
/// MB12_16B_WORD0_L: Message Buffer 12 WORD_16B Register
/// MB18_8B_WORD0: Message Buffer 18 WORD_8B Register
/// MB4_64B_WORD0_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD2_L: Message Buffer 7 WORD_32B Register
/// WORD018: Message Buffer 18 WORD0 Register
pub mod MB12_16B_WORD0_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_16B_WORD1_L and WORD118
/// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB7_32B_WORD3_L
/// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB4_64B_WORD1_L
/// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB18_8B_WORD1
/// MB12_16B_WORD1_L: Message Buffer 12 WORD_16B Register
/// MB18_8B_WORD1: Message Buffer 18 WORD_8B Register
/// MB4_64B_WORD1_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD3_L: Message Buffer 7 WORD_32B Register
/// WORD118: Message Buffer 18 WORD1 Register
pub mod MB12_16B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS19 and MB7_32B_WORD4_L
/// CS19: CS19 and MB4_64B_WORD2_L
/// CS19: CS19 and MB19_8B_CS
/// CS19: CS19 and MB12_16B_WORD2_L
/// CS19: Message Buffer 19 CS Register
/// MB12_16B_WORD2_L: Message Buffer 12 WORD_16B Register
/// MB19_8B_CS: Message Buffer 19 CS Register
/// MB4_64B_WORD2_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD4_L: Message Buffer 7 WORD_32B Register
pub mod CS19 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID19 and MB7_32B_WORD5_L
/// ID19: ID19 and MB4_64B_WORD3_L
/// ID19: ID19 and MB19_8B_ID
/// ID19: ID19 and MB12_16B_WORD3_L
/// ID19: Message Buffer 19 ID Register
/// MB12_16B_WORD3_L: Message Buffer 12 WORD_16B Register
/// MB19_8B_ID: Message Buffer 19 ID Register
/// MB4_64B_WORD3_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD5_L: Message Buffer 7 WORD_32B Register
pub mod ID19 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_CS_L and WORD019
/// MB13_16B_CS_L: MB13_16B_CS_L and MB7_32B_WORD6_L
/// MB13_16B_CS_L: MB13_16B_CS_L and MB4_64B_WORD4_L
/// MB13_16B_CS_L: MB13_16B_CS_L and MB19_8B_WORD0
/// MB13_16B_CS_L: Message Buffer 13 CS Register
/// MB19_8B_WORD0: Message Buffer 19 WORD_8B Register
/// MB4_64B_WORD4_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD6_L: Message Buffer 7 WORD_32B Register
/// WORD019: Message Buffer 19 WORD0 Register
pub mod MB13_16B_CS_L {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_ID_L and WORD119
/// MB13_16B_ID_L: MB13_16B_ID_L and MB7_32B_WORD7_L
/// MB13_16B_ID_L: MB13_16B_ID_L and MB4_64B_WORD5_L
/// MB13_16B_ID_L: MB13_16B_ID_L and MB19_8B_WORD1
/// MB13_16B_ID_L: Message Buffer 13 ID Register
/// MB19_8B_WORD1: Message Buffer 19 WORD_8B Register
/// MB4_64B_WORD5_L: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD7_L: Message Buffer 7 WORD_32B Register
/// WORD119: Message Buffer 19 WORD1 Register
pub mod MB13_16B_ID_L {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS20 and MB8_32B_CS_L
/// CS20: CS20 and MB4_64B_WORD6_L
/// CS20: CS20 and MB20_8B_CS
/// CS20: CS20 and MB13_16B_WORD0_L
/// CS20: Message Buffer 20 CS Register
/// MB13_16B_WORD0_L: Message Buffer 13 WORD_16B Register
/// MB20_8B_CS: Message Buffer 20 CS Register
/// MB4_64B_WORD6_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_CS_L: Message Buffer 8 CS Register
pub mod CS20 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID20 and MB8_32B_ID_L
/// ID20: ID20 and MB4_64B_WORD7_L
/// ID20: ID20 and MB20_8B_ID
/// ID20: ID20 and MB13_16B_WORD1_L
/// ID20: Message Buffer 20 ID Register
/// MB13_16B_WORD1_L: Message Buffer 13 WORD_16B Register
/// MB20_8B_ID: Message Buffer 20 ID Register
/// MB4_64B_WORD7_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_ID_L: Message Buffer 8 ID Register
pub mod ID20 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_WORD2_L and WORD020
/// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB8_32B_WORD0_L
/// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB4_64B_WORD8_L
/// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB20_8B_WORD0
/// MB13_16B_WORD2_L: Message Buffer 13 WORD_16B Register
/// MB20_8B_WORD0: Message Buffer 20 WORD_8B Register
/// MB4_64B_WORD8_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD0_L: Message Buffer 8 WORD_32B Register
/// WORD020: Message Buffer 20 WORD0 Register
pub mod MB13_16B_WORD2_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_WORD3_L and WORD120
/// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB8_32B_WORD1_L
/// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB4_64B_WORD9_L
/// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB20_8B_WORD1
/// MB13_16B_WORD3_L: Message Buffer 13 WORD_16B Register
/// MB20_8B_WORD1: Message Buffer 20 WORD_8B Register
/// MB4_64B_WORD9_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD1_L: Message Buffer 8 WORD_32B Register
/// WORD120: Message Buffer 20 WORD1 Register
pub mod MB13_16B_WORD3_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS21 and MB8_32B_WORD2_L
/// CS21: CS21 and MB4_64B_WORD10_L
/// CS21: CS21 and MB21_8B_CS
/// CS21: CS21 and MB14_16B_CS_L
/// CS21: Message Buffer 21 CS Register
/// MB14_16B_CS_L: Message Buffer 14 CS Register
/// MB21_8B_CS: Message Buffer 21 CS Register
/// MB4_64B_WORD10_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD2_L: Message Buffer 8 WORD_32B Register
pub mod CS21 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID21 and MB8_32B_WORD3_L
/// ID21: ID21 and MB4_64B_WORD11_L
/// ID21: ID21 and MB21_8B_ID
/// ID21: ID21 and MB14_16B_ID_L
/// ID21: Message Buffer 21 ID Register
/// MB14_16B_ID_L: Message Buffer 14 ID Register
/// MB21_8B_ID: Message Buffer 21 ID Register
/// MB4_64B_WORD11_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD3_L: Message Buffer 8 WORD_32B Register
pub mod ID21 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_16B_WORD0_L and WORD021
/// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB8_32B_WORD4_L
/// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB4_64B_WORD12_L
/// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB21_8B_WORD0
/// MB14_16B_WORD0_L: Message Buffer 14 WORD_16B Register
/// MB21_8B_WORD0: Message Buffer 21 WORD_8B Register
/// MB4_64B_WORD12_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD4_L: Message Buffer 8 WORD_32B Register
/// WORD021: Message Buffer 21 WORD0 Register
pub mod MB14_16B_WORD0_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_16B_WORD1_L and WORD121
/// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB8_32B_WORD5_L
/// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB4_64B_WORD13_L
/// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB21_8B_WORD1
/// MB14_16B_WORD1_L: Message Buffer 14 WORD_16B Register
/// MB21_8B_WORD1: Message Buffer 21 WORD_8B Register
/// MB4_64B_WORD13_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD5_L: Message Buffer 8 WORD_32B Register
/// WORD121: Message Buffer 21 WORD1 Register
pub mod MB14_16B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS22 and MB8_32B_WORD6_L
/// CS22: CS22 and MB4_64B_WORD14_L
/// CS22: CS22 and MB22_8B_CS
/// CS22: CS22 and MB14_16B_WORD2_L
/// CS22: Message Buffer 22 CS Register
/// MB14_16B_WORD2_L: Message Buffer 14 WORD_16B Register
/// MB22_8B_CS: Message Buffer 22 CS Register
/// MB4_64B_WORD14_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD6_L: Message Buffer 8 WORD_32B Register
pub mod CS22 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID22 and MB8_32B_WORD7_L
/// ID22: ID22 and MB4_64B_WORD15_L
/// ID22: ID22 and MB22_8B_ID
/// ID22: ID22 and MB14_16B_WORD3_L
/// ID22: Message Buffer 22 ID Register
/// MB14_16B_WORD3_L: Message Buffer 14 WORD_16B Register
/// MB22_8B_ID: Message Buffer 22 ID Register
/// MB4_64B_WORD15_L: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD7_L: Message Buffer 8 WORD_32B Register
pub mod ID22 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB15_16B_CS_L and WORD022
/// MB15_16B_CS_L: MB15_16B_CS_L and MB9_32B_CS_L
/// MB15_16B_CS_L: MB15_16B_CS_L and MB5_64B_CS_L
/// MB15_16B_CS_L: MB15_16B_CS_L and MB22_8B_WORD0
/// MB15_16B_CS_L: Message Buffer 15 CS Register
/// MB22_8B_WORD0: Message Buffer 22 WORD_8B Register
/// MB5_64B_CS_L: Message Buffer 5 CS Register
/// MB9_32B_CS_L: Message Buffer 9 CS Register
/// WORD022: Message Buffer 22 WORD0 Register
pub mod MB15_16B_CS_L {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB15_16B_ID_L and WORD122
/// MB15_16B_ID_L: MB15_16B_ID_L and MB9_32B_ID_L
/// MB15_16B_ID_L: MB15_16B_ID_L and MB5_64B_ID_L
/// MB15_16B_ID_L: MB15_16B_ID_L and MB22_8B_WORD1
/// MB15_16B_ID_L: Message Buffer 15 ID Register
/// MB22_8B_WORD1: Message Buffer 22 WORD_8B Register
/// MB5_64B_ID_L: Message Buffer 5 ID Register
/// MB9_32B_ID_L: Message Buffer 9 ID Register
/// WORD122: Message Buffer 22 WORD1 Register
pub mod MB15_16B_ID_L {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS23 and MB9_32B_WORD0_L
/// CS23: CS23 and MB5_64B_WORD0_L
/// CS23: CS23 and MB23_8B_CS
/// CS23: CS23 and MB15_16B_WORD0_L
/// CS23: Message Buffer 23 CS Register
/// MB15_16B_WORD0_L: Message Buffer 15 WORD_16B Register
/// MB23_8B_CS: Message Buffer 23 CS Register
/// MB5_64B_WORD0_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD0_L: Message Buffer 9 WORD_32B Register
pub mod CS23 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID23 and MB9_32B_WORD1_L
/// ID23: ID23 and MB5_64B_WORD1_L
/// ID23: ID23 and MB23_8B_ID
/// ID23: ID23 and MB15_16B_WORD1_L
/// ID23: Message Buffer 23 ID Register
/// MB15_16B_WORD1_L: Message Buffer 15 WORD_16B Register
/// MB23_8B_ID: Message Buffer 23 ID Register
/// MB5_64B_WORD1_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD1_L: Message Buffer 9 WORD_32B Register
pub mod ID23 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB15_16B_WORD2_L and WORD023
/// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB9_32B_WORD2_L
/// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB5_64B_WORD2_L
/// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB23_8B_WORD0
/// MB15_16B_WORD2_L: Message Buffer 15 WORD_16B Register
/// MB23_8B_WORD0: Message Buffer 23 WORD_8B Register
/// MB5_64B_WORD2_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD2_L: Message Buffer 9 WORD_32B Register
/// WORD023: Message Buffer 23 WORD0 Register
pub mod MB15_16B_WORD2_L {
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_0;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_1;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_10;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_11;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_2;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_3;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_8;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_9;
}

/// MB15_16B_WORD3_L and WORD123
/// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB9_32B_WORD3_L
/// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB5_64B_WORD3_L
/// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB23_8B_WORD1
/// MB15_16B_WORD3_L: Message Buffer 15 WORD_16B Register
/// MB23_8B_WORD1: Message Buffer 23 WORD_8B Register
/// MB5_64B_WORD3_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD3_L: Message Buffer 9 WORD_32B Register
/// WORD123: Message Buffer 23 WORD1 Register
pub mod MB15_16B_WORD3_L {
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_12;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_13;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_14;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_15;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_4;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_5;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_6;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_7;
}

/// CS24 and MB9_32B_WORD4_L
/// CS24: CS24 and MB5_64B_WORD4_L
/// CS24: CS24 and MB24_8B_CS
/// CS24: CS24 and MB16_16B_CS_L
/// CS24: Message Buffer 24 CS Register
/// MB16_16B_CS_L: Message Buffer 16 CS Register
/// MB24_8B_CS: Message Buffer 24 CS Register
/// MB5_64B_WORD4_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD4_L: Message Buffer 9 WORD_32B Register
pub mod CS24 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID24 and MB9_32B_WORD5_L
/// ID24: ID24 and MB5_64B_WORD5_L
/// ID24: ID24 and MB24_8B_ID
/// ID24: ID24 and MB16_16B_ID_L
/// ID24: Message Buffer 24 ID Register
/// MB16_16B_ID_L: Message Buffer 16 ID Register
/// MB24_8B_ID: Message Buffer 24 ID Register
/// MB5_64B_WORD5_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD5_L: Message Buffer 9 WORD_32B Register
pub mod ID24 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB16_16B_WORD0_L and WORD024
/// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB9_32B_WORD6_L
/// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB5_64B_WORD6_L
/// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB24_8B_WORD0
/// MB16_16B_WORD0_L: Message Buffer 16 WORD_16B Register
/// MB24_8B_WORD0: Message Buffer 24 WORD_8B Register
/// MB5_64B_WORD6_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD6_L: Message Buffer 9 WORD_32B Register
/// WORD024: Message Buffer 24 WORD0 Register
pub mod MB16_16B_WORD0_L {
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_3;
}

/// MB16_16B_WORD1_L and WORD124
/// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB9_32B_WORD7_L
/// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB5_64B_WORD7_L
/// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB24_8B_WORD1
/// MB16_16B_WORD1_L: Message Buffer 16 WORD_16B Register
/// MB24_8B_WORD1: Message Buffer 24 WORD_8B Register
/// MB5_64B_WORD7_L: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD7_L: Message Buffer 9 WORD_32B Register
/// WORD124: Message Buffer 24 WORD1 Register
pub mod MB16_16B_WORD1_L {
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_7;
}

/// CS25 and MB5_64B_WORD8_L
/// CS25: CS25 and MB25_8B_CS
/// CS25: CS25 and MB16_16B_WORD2_L
/// CS25: CS25 and MB10_32B_CS_L
/// CS25: Message Buffer 25 CS Register
/// MB10_32B_CS_L: Message Buffer 10 CS Register
/// MB16_16B_WORD2_L: Message Buffer 16 WORD_16B Register
/// MB25_8B_CS: Message Buffer 25 CS Register
/// MB5_64B_WORD8_L: Message Buffer 5 WORD_64B Register
pub mod CS25 {
    pub use super::CS16::BRS;
    pub use super::CS16::CODE;
    pub use super::CS16::DATA_BYTE_10;
    pub use super::CS16::DATA_BYTE_11;
    pub use super::CS16::DATA_BYTE_32;
    pub use super::CS16::DATA_BYTE_33;
    pub use super::CS16::DATA_BYTE_34;
    pub use super::CS16::DATA_BYTE_35;
    pub use super::CS16::DATA_BYTE_8;
    pub use super::CS16::DATA_BYTE_9;
    pub use super::CS16::DLC;
    pub use super::CS16::EDL;
    pub use super::CS16::ESI;
    pub use super::CS16::IDE;
    pub use super::CS16::RTR;
    pub use super::CS16::SRR;
    pub use super::CS16::TIME_STAMP;
}

/// ID25 and MB5_64B_WORD9_L
/// ID25: ID25 and MB25_8B_ID
/// ID25: ID25 and MB16_16B_WORD3_L
/// ID25: ID25 and MB10_32B_ID_L
/// ID25: Message Buffer 25 ID Register
/// MB10_32B_ID_L: Message Buffer 10 ID Register
/// MB16_16B_WORD3_L: Message Buffer 16 WORD_16B Register
/// MB25_8B_ID: Message Buffer 25 ID Register
/// MB5_64B_WORD9_L: Message Buffer 5 WORD_64B Register
pub mod ID25 {
    pub use super::ID16::DATA_BYTE_12;
    pub use super::ID16::DATA_BYTE_13;
    pub use super::ID16::DATA_BYTE_14;
    pub use super::ID16::DATA_BYTE_15;
    pub use super::ID16::DATA_BYTE_36;
    pub use super::ID16::DATA_BYTE_37;
    pub use super::ID16::DATA_BYTE_38;
    pub use super::ID16::DATA_BYTE_39;
    pub use super::ID16::EXT;
    pub use super::ID16::PRIO;
    pub use super::ID16::STD;
}

/// MB10_32B_WORD0_L and WORD025
/// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB5_64B_WORD10_L
/// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB25_8B_WORD0
/// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB17_16B_CS_L
/// MB10_32B_WORD0_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_CS_L: Message Buffer 17 CS Register
/// MB25_8B_WORD0: Message Buffer 25 WORD_8B Register
/// MB5_64B_WORD10_L: Message Buffer 5 WORD_64B Register
/// WORD025: Message Buffer 25 WORD0 Register
pub mod MB10_32B_WORD0_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD1_L and WORD125
/// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB5_64B_WORD11_L
/// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB25_8B_WORD1
/// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB17_16B_ID_L
/// MB10_32B_WORD1_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_ID_L: Message Buffer 17 ID Register
/// MB25_8B_WORD1: Message Buffer 25 WORD_8B Register
/// MB5_64B_WORD11_L: Message Buffer 5 WORD_64B Register
/// WORD125: Message Buffer 25 WORD1 Register
pub mod MB10_32B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS26 and MB5_64B_WORD12_L
/// CS26: CS26 and MB26_8B_CS
/// CS26: CS26 and MB17_16B_WORD0_L
/// CS26: CS26 and MB10_32B_WORD2_L
/// CS26: Message Buffer 26 CS Register
/// MB10_32B_WORD2_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD0_L: Message Buffer 17 WORD_16B Register
/// MB26_8B_CS: Message Buffer 26 CS Register
/// MB5_64B_WORD12_L: Message Buffer 5 WORD_64B Register
pub mod CS26 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID26 and MB5_64B_WORD13_L
/// ID26: ID26 and MB26_8B_ID
/// ID26: ID26 and MB17_16B_WORD1_L
/// ID26: ID26 and MB10_32B_WORD3_L
/// ID26: Message Buffer 26 ID Register
/// MB10_32B_WORD3_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD1_L: Message Buffer 17 WORD_16B Register
/// MB26_8B_ID: Message Buffer 26 ID Register
/// MB5_64B_WORD13_L: Message Buffer 5 WORD_64B Register
pub mod ID26 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD4_L and WORD026
/// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB5_64B_WORD14_L
/// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB26_8B_WORD0
/// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB17_16B_WORD2_L
/// MB10_32B_WORD4_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD2_L: Message Buffer 17 WORD_16B Register
/// MB26_8B_WORD0: Message Buffer 26 WORD_8B Register
/// MB5_64B_WORD14_L: Message Buffer 5 WORD_64B Register
/// WORD026: Message Buffer 26 WORD0 Register
pub mod MB10_32B_WORD4_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD5_L and WORD126
/// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB5_64B_WORD15_L
/// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB26_8B_WORD1
/// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB17_16B_WORD3_L
/// MB10_32B_WORD5_L: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD3_L: Message Buffer 17 WORD_16B Register
/// MB26_8B_WORD1: Message Buffer 26 WORD_8B Register
/// MB5_64B_WORD15_L: Message Buffer 5 WORD_64B Register
/// WORD126: Message Buffer 26 WORD1 Register
pub mod MB10_32B_WORD5_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS27 and MB6_64B_CS_L
/// CS27: CS27 and MB27_8B_CS
/// CS27: CS27 and MB18_16B_CS_L
/// CS27: CS27 and MB10_32B_WORD6_L
/// CS27: Message Buffer 27 CS Register
/// MB10_32B_WORD6_L: Message Buffer 10 WORD_32B Register
/// MB18_16B_CS_L: Message Buffer 18 CS Register
/// MB27_8B_CS: Message Buffer 27 CS Register
/// MB6_64B_CS_L: Message Buffer 6 CS Register
pub mod CS27 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID27 and MB6_64B_ID_L
/// ID27: ID27 and MB27_8B_ID
/// ID27: ID27 and MB18_16B_ID_L
/// ID27: ID27 and MB10_32B_WORD7_L
/// ID27: Message Buffer 27 ID Register
/// MB10_32B_WORD7_L: Message Buffer 10 WORD_32B Register
/// MB18_16B_ID_L: Message Buffer 18 ID Register
/// MB27_8B_ID: Message Buffer 27 ID Register
/// MB6_64B_ID_L: Message Buffer 6 ID Register
pub mod ID27 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_CS_L and WORD027
/// MB11_32B_CS_L: MB11_32B_CS_L and MB6_64B_WORD0_L
/// MB11_32B_CS_L: MB11_32B_CS_L and MB27_8B_WORD0
/// MB11_32B_CS_L: MB11_32B_CS_L and MB18_16B_WORD0_L
/// MB11_32B_CS_L: Message Buffer 11 CS Register
/// MB18_16B_WORD0_L: Message Buffer 18 WORD_16B Register
/// MB27_8B_WORD0: Message Buffer 27 WORD_8B Register
/// MB6_64B_WORD0_L: Message Buffer 6 WORD_64B Register
/// WORD027: Message Buffer 27 WORD0 Register
pub mod MB11_32B_CS_L {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB11_32B_ID_L and WORD127
/// MB11_32B_ID_L: MB11_32B_ID_L and MB6_64B_WORD1_L
/// MB11_32B_ID_L: MB11_32B_ID_L and MB27_8B_WORD1
/// MB11_32B_ID_L: MB11_32B_ID_L and MB18_16B_WORD1_L
/// MB11_32B_ID_L: Message Buffer 11 ID Register
/// MB18_16B_WORD1_L: Message Buffer 18 WORD_16B Register
/// MB27_8B_WORD1: Message Buffer 27 WORD_8B Register
/// MB6_64B_WORD1_L: Message Buffer 6 WORD_64B Register
/// WORD127: Message Buffer 27 WORD1 Register
pub mod MB11_32B_ID_L {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS28 and MB6_64B_WORD2_L
/// CS28: CS28 and MB28_8B_CS
/// CS28: CS28 and MB18_16B_WORD2_L
/// CS28: CS28 and MB11_32B_WORD0_L
/// CS28: Message Buffer 28 CS Register
/// MB11_32B_WORD0_L: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD2_L: Message Buffer 18 WORD_16B Register
/// MB28_8B_CS: Message Buffer 28 CS Register
/// MB6_64B_WORD2_L: Message Buffer 6 WORD_64B Register
pub mod CS28 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID28 and MB6_64B_WORD3_L
/// ID28: ID28 and MB28_8B_ID
/// ID28: ID28 and MB18_16B_WORD3_L
/// ID28: ID28 and MB11_32B_WORD1_L
/// ID28: Message Buffer 28 ID Register
/// MB11_32B_WORD1_L: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD3_L: Message Buffer 18 WORD_16B Register
/// MB28_8B_ID: Message Buffer 28 ID Register
/// MB6_64B_WORD3_L: Message Buffer 6 WORD_64B Register
pub mod ID28 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD2_L and WORD028
/// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB6_64B_WORD4_L
/// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB28_8B_WORD0
/// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB19_16B_CS_L
/// MB11_32B_WORD2_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_CS_L: Message Buffer 19 CS Register
/// MB28_8B_WORD0: Message Buffer 28 WORD_8B Register
/// MB6_64B_WORD4_L: Message Buffer 6 WORD_64B Register
/// WORD028: Message Buffer 28 WORD0 Register
pub mod MB11_32B_WORD2_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD3_L and WORD128
/// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB6_64B_WORD5_L
/// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB28_8B_WORD1
/// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB19_16B_ID_L
/// MB11_32B_WORD3_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_ID_L: Message Buffer 19 ID Register
/// MB28_8B_WORD1: Message Buffer 28 WORD_8B Register
/// MB6_64B_WORD5_L: Message Buffer 6 WORD_64B Register
/// WORD128: Message Buffer 28 WORD1 Register
pub mod MB11_32B_WORD3_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS29 and MB6_64B_WORD6_L
/// CS29: CS29 and MB29_8B_CS
/// CS29: CS29 and MB19_16B_WORD0_L
/// CS29: CS29 and MB11_32B_WORD4_L
/// CS29: Message Buffer 29 CS Register
/// MB11_32B_WORD4_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD0_L: Message Buffer 19 WORD_16B Register
/// MB29_8B_CS: Message Buffer 29 CS Register
/// MB6_64B_WORD6_L: Message Buffer 6 WORD_64B Register
pub mod CS29 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID29 and MB6_64B_WORD7_L
/// ID29: ID29 and MB29_8B_ID
/// ID29: ID29 and MB19_16B_WORD1_L
/// ID29: ID29 and MB11_32B_WORD5_L
/// ID29: Message Buffer 29 ID Register
/// MB11_32B_WORD5_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD1_L: Message Buffer 19 WORD_16B Register
/// MB29_8B_ID: Message Buffer 29 ID Register
/// MB6_64B_WORD7_L: Message Buffer 6 WORD_64B Register
pub mod ID29 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD6_L and WORD029
/// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB6_64B_WORD8_L
/// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB29_8B_WORD0
/// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB19_16B_WORD2_L
/// MB11_32B_WORD6_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD2_L: Message Buffer 19 WORD_16B Register
/// MB29_8B_WORD0: Message Buffer 29 WORD_8B Register
/// MB6_64B_WORD8_L: Message Buffer 6 WORD_64B Register
/// WORD029: Message Buffer 29 WORD0 Register
pub mod MB11_32B_WORD6_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD7_L and WORD129
/// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB6_64B_WORD9_L
/// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB29_8B_WORD1
/// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB19_16B_WORD3_L
/// MB11_32B_WORD7_L: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD3_L: Message Buffer 19 WORD_16B Register
/// MB29_8B_WORD1: Message Buffer 29 WORD_8B Register
/// MB6_64B_WORD9_L: Message Buffer 6 WORD_64B Register
/// WORD129: Message Buffer 29 WORD1 Register
pub mod MB11_32B_WORD7_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS30 and MB6_64B_WORD10_L
/// CS30: CS30 and MB30_8B_CS
/// CS30: CS30 and MB20_16B_CS_L
/// CS30: Message Buffer 30 CS Register
/// MB20_16B_CS_L: Message Buffer 20 CS Register
/// MB30_8B_CS: Message Buffer 30 CS Register
/// MB6_64B_WORD10_L: Message Buffer 6 WORD_64B Register
pub mod CS30 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID30 and MB6_64B_WORD11_L
/// ID30: ID30 and MB30_8B_ID
/// ID30: ID30 and MB20_16B_ID_L
/// ID30: Message Buffer 30 ID Register
/// MB20_16B_ID_L: Message Buffer 20 ID Register
/// MB30_8B_ID: Message Buffer 30 ID Register
/// MB6_64B_WORD11_L: Message Buffer 6 WORD_64B Register
pub mod ID30 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB20_16B_WORD0_L and WORD030
/// MB20_16B_WORD0_L: MB20_16B_WORD0_L and MB6_64B_WORD12_L
/// MB20_16B_WORD0_L: MB20_16B_WORD0_L and MB30_8B_WORD0
/// MB20_16B_WORD0_L: Message Buffer 20 WORD_16B Register
/// MB30_8B_WORD0: Message Buffer 30 WORD_8B Register
/// MB6_64B_WORD12_L: Message Buffer 6 WORD_64B Register
/// WORD030: Message Buffer 30 WORD0 Register
pub mod MB20_16B_WORD0_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB20_16B_WORD1_L and WORD130
/// MB20_16B_WORD1_L: MB20_16B_WORD1_L and MB6_64B_WORD13_L
/// MB20_16B_WORD1_L: MB20_16B_WORD1_L and MB30_8B_WORD1
/// MB20_16B_WORD1_L: Message Buffer 20 WORD_16B Register
/// MB30_8B_WORD1: Message Buffer 30 WORD_8B Register
/// MB6_64B_WORD13_L: Message Buffer 6 WORD_64B Register
/// WORD130: Message Buffer 30 WORD1 Register
pub mod MB20_16B_WORD1_L {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS31 and MB6_64B_WORD14_L
/// CS31: CS31 and MB31_8B_CS
/// CS31: CS31 and MB20_16B_WORD2_L
/// CS31: Message Buffer 31 CS Register
/// MB20_16B_WORD2_L: Message Buffer 20 WORD_16B Register
/// MB31_8B_CS: Message Buffer 31 CS Register
/// MB6_64B_WORD14_L: Message Buffer 6 WORD_64B Register
pub mod CS31 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID31 and MB6_64B_WORD15_L
/// ID31: ID31 and MB31_8B_ID
/// ID31: ID31 and MB20_16B_WORD3_L
/// ID31: Message Buffer 31 ID Register
/// MB20_16B_WORD3_L: Message Buffer 20 WORD_16B Register
/// MB31_8B_ID: Message Buffer 31 ID Register
/// MB6_64B_WORD15_L: Message Buffer 6 WORD_64B Register
pub mod ID31 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB31_8B_WORD0 and WORD031
/// MB31_8B_WORD0: Message Buffer 31 WORD_8B Register
/// WORD031: Message Buffer 31 WORD0 Register
pub mod MB31_8B_WORD0 {
    pub use super::MB0::DATA_BYTE_0;
    pub use super::MB0::DATA_BYTE_1;
    pub use super::MB0::DATA_BYTE_2;
    pub use super::MB0::DATA_BYTE_3;
}

/// MB31_8B_WORD1 and WORD131
/// MB31_8B_WORD1: Message Buffer 31 WORD_8B Register
/// WORD131: Message Buffer 31 WORD1 Register
pub mod MB31_8B_WORD1 {
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_7;
}

/// CS32 and MB32_8B_CS
/// CS32: CS32 and MB0_64B_CS_H
/// CS32: CS32 and MB0_32B_CS_H
/// CS32: CS32 and MB0_16B_CS_H
/// CS32: Message Buffer 32 CS Register
/// MB0_16B_CS_H: Message Buffer 0 CS Register
/// MB0_32B_CS_H: Message Buffer 0 CS Register
/// MB0_64B_CS_H: Message Buffer 0 CS Register
/// MB32_8B_CS: Message Buffer 32 CS Register
pub mod CS32 {
    pub use super::CS0::BRS;
    pub use super::CS0::CODE;
    pub use super::CS0::DLC;
    pub use super::CS0::EDL;
    pub use super::CS0::ESI;
    pub use super::CS0::IDE;
    pub use super::CS0::RTR;
    pub use super::CS0::SRR;
    pub use super::CS0::TIME_STAMP;
}

/// ID32 and MB32_8B_ID
/// ID32: ID32 and MB0_64B_ID_H
/// ID32: ID32 and MB0_32B_ID_H
/// ID32: ID32 and MB0_16B_ID_H
/// ID32: Message Buffer 32 ID Register
/// MB0_16B_ID_H: Message Buffer 0 ID Register
/// MB0_32B_ID_H: Message Buffer 0 ID Register
/// MB0_64B_ID_H: Message Buffer 0 ID Register
/// MB32_8B_ID: Message Buffer 32 ID Register
pub mod ID32 {
    pub use super::ID0::EXT;
    pub use super::ID0::PRIO;
    pub use super::ID0::STD;
}

/// MB0_16B_WORD0_H and WORD032
/// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB32_8B_WORD0
/// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB0_64B_WORD0_H
/// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB0_32B_WORD0_H
/// MB0_16B_WORD0_H: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD0_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD0_H: Message Buffer 0 WORD_64B Register
/// MB32_8B_WORD0: Message Buffer 32 WORD_8B Register
/// WORD032: Message Buffer 32 WORD0 Register
pub mod MB0_16B_WORD0_H {
    pub use super::MB0::DATA_BYTE_0;
    pub use super::MB0::DATA_BYTE_1;
    pub use super::MB0::DATA_BYTE_2;
    pub use super::MB0::DATA_BYTE_3;
}

/// MB0_16B_WORD1_H and WORD132
/// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB32_8B_WORD1
/// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB0_64B_WORD1_H
/// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB0_32B_WORD1_H
/// MB0_16B_WORD1_H: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD1_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD1_H: Message Buffer 0 WORD_64B Register
/// MB32_8B_WORD1: Message Buffer 32 WORD_8B Register
/// WORD132: Message Buffer 32 WORD1 Register
pub mod MB0_16B_WORD1_H {
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_7;
}

/// CS33 and MB33_8B_CS
/// CS33: CS33 and MB0_64B_WORD2_H
/// CS33: CS33 and MB0_32B_WORD2_H
/// CS33: CS33 and MB0_16B_WORD2_H
/// CS33: Message Buffer 33 CS Register
/// MB0_16B_WORD2_H: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD2_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD2_H: Message Buffer 0 WORD_64B Register
/// MB33_8B_CS: Message Buffer 33 CS Register
pub mod CS33 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID33 and MB33_8B_ID
/// ID33: ID33 and MB0_64B_WORD3_H
/// ID33: ID33 and MB0_32B_WORD3_H
/// ID33: ID33 and MB0_16B_WORD3_H
/// ID33: Message Buffer 33 ID Register
/// MB0_16B_WORD3_H: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD3_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD3_H: Message Buffer 0 WORD_64B Register
/// MB33_8B_ID: Message Buffer 33 ID Register
pub mod ID33 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB0_32B_WORD4_H and WORD033
/// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB33_8B_WORD0
/// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB1_16B_CS_H
/// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB0_64B_WORD4_H
/// MB0_32B_WORD4_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD4_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_CS_H: Message Buffer 1 CS Register
/// MB33_8B_WORD0: Message Buffer 33 WORD_8B Register
/// WORD033: Message Buffer 33 WORD0 Register
pub mod MB0_32B_WORD4_H {
    pub use super::MB::BRS;
    pub use super::MB::CODE;
    pub use super::MB::DATA_BYTE_0;
    pub use super::MB::DATA_BYTE_1;
    pub use super::MB::DATA_BYTE_16;
    pub use super::MB::DATA_BYTE_17;
    pub use super::MB::DATA_BYTE_18;
    pub use super::MB::DATA_BYTE_19;
    pub use super::MB::DATA_BYTE_2;
    pub use super::MB::DATA_BYTE_3;
    pub use super::MB::DLC;
    pub use super::MB::EDL;
    pub use super::MB::ESI;
    pub use super::MB::IDE;
    pub use super::MB::RTR;
    pub use super::MB::SRR;
    pub use super::MB::TIME_STAMP;
}

/// MB0_32B_WORD5_H and WORD133
/// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB33_8B_WORD1
/// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB1_16B_ID_H
/// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB0_64B_WORD5_H
/// MB0_32B_WORD5_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD5_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_ID_H: Message Buffer 1 ID Register
/// MB33_8B_WORD1: Message Buffer 33 WORD_8B Register
/// WORD133: Message Buffer 33 WORD1 Register
pub mod MB0_32B_WORD5_H {
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_20;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_21;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_22;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_23;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_4;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_5;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_6;
    pub use super::MB0_32B_WORD5_L::DATA_BYTE_7;
    pub use super::MB0_32B_WORD5_L::EXT;
    pub use super::MB0_32B_WORD5_L::PRIO;
    pub use super::MB0_32B_WORD5_L::STD;
}

/// CS34 and MB34_8B_CS
/// CS34: CS34 and MB1_16B_WORD0_H
/// CS34: CS34 and MB0_64B_WORD6_H
/// CS34: CS34 and MB0_32B_WORD6_H
/// CS34: Message Buffer 34 CS Register
/// MB0_32B_WORD6_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD6_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD0_H: Message Buffer 1 WORD_16B Register
/// MB34_8B_CS: Message Buffer 34 CS Register
pub mod CS34 {
    pub use super::CS2::BRS;
    pub use super::CS2::CODE;
    pub use super::CS2::DATA_BYTE_0;
    pub use super::CS2::DATA_BYTE_1;
    pub use super::CS2::DATA_BYTE_2;
    pub use super::CS2::DATA_BYTE_24;
    pub use super::CS2::DATA_BYTE_25;
    pub use super::CS2::DATA_BYTE_26;
    pub use super::CS2::DATA_BYTE_27;
    pub use super::CS2::DATA_BYTE_3;
    pub use super::CS2::DLC;
    pub use super::CS2::EDL;
    pub use super::CS2::ESI;
    pub use super::CS2::IDE;
    pub use super::CS2::RTR;
    pub use super::CS2::SRR;
    pub use super::CS2::TIME_STAMP;
}

/// ID34 and MB34_8B_ID
/// ID34: ID34 and MB1_16B_WORD1_H
/// ID34: ID34 and MB0_64B_WORD7_H
/// ID34: ID34 and MB0_32B_WORD7_H
/// ID34: Message Buffer 34 ID Register
/// MB0_32B_WORD7_H: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD7_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD1_H: Message Buffer 1 WORD_16B Register
/// MB34_8B_ID: Message Buffer 34 ID Register
pub mod ID34 {
    pub use super::ID2::DATA_BYTE_28;
    pub use super::ID2::DATA_BYTE_29;
    pub use super::ID2::DATA_BYTE_30;
    pub use super::ID2::DATA_BYTE_31;
    pub use super::ID2::DATA_BYTE_4;
    pub use super::ID2::DATA_BYTE_5;
    pub use super::ID2::DATA_BYTE_6;
    pub use super::ID2::DATA_BYTE_7;
    pub use super::ID2::EXT;
    pub use super::ID2::PRIO;
    pub use super::ID2::STD;
}

/// MB0_64B_WORD8_H and WORD034
/// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB34_8B_WORD0
/// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB1_32B_CS_H
/// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB1_16B_WORD2_H
/// MB0_64B_WORD8_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD2_H: Message Buffer 1 WORD_16B Register
/// MB1_32B_CS_H: Message Buffer 1 CS Register
/// MB34_8B_WORD0: Message Buffer 34 WORD_8B Register
/// WORD034: Message Buffer 34 WORD0 Register
pub mod MB0_64B_WORD8_H {
    pub use super::MB0_64B_WORD8_L::BRS;
    pub use super::MB0_64B_WORD8_L::CODE;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_0;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_1;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_10;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_11;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_2;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_3;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_32;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_33;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_34;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_35;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_8;
    pub use super::MB0_64B_WORD8_L::DATA_BYTE_9;
    pub use super::MB0_64B_WORD8_L::DLC;
    pub use super::MB0_64B_WORD8_L::EDL;
    pub use super::MB0_64B_WORD8_L::ESI;
    pub use super::MB0_64B_WORD8_L::IDE;
    pub use super::MB0_64B_WORD8_L::RTR;
    pub use super::MB0_64B_WORD8_L::SRR;
    pub use super::MB0_64B_WORD8_L::TIME_STAMP;
}

/// MB0_64B_WORD9_H and WORD134
/// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB34_8B_WORD1
/// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB1_32B_ID_H
/// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB1_16B_WORD3_H
/// MB0_64B_WORD9_H: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD3_H: Message Buffer 1 WORD_16B Register
/// MB1_32B_ID_H: Message Buffer 1 ID Register
/// MB34_8B_WORD1: Message Buffer 34 WORD_8B Register
/// WORD134: Message Buffer 34 WORD1 Register
pub mod MB0_64B_WORD9_H {
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_12;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_13;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_14;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_15;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_36;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_37;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_38;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_39;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_4;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_5;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_6;
    pub use super::MB0_64B_WORD9_L::DATA_BYTE_7;
    pub use super::MB0_64B_WORD9_L::EXT;
    pub use super::MB0_64B_WORD9_L::PRIO;
    pub use super::MB0_64B_WORD9_L::STD;
}

/// CS35 and MB35_8B_CS
/// CS35: CS35 and MB2_16B_CS_H
/// CS35: CS35 and MB1_32B_WORD0_H
/// CS35: CS35 and MB0_64B_WORD10_H
/// CS35: Message Buffer 35 CS Register
/// MB0_64B_WORD10_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD0_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_CS_H: Message Buffer 2 CS Register
/// MB35_8B_CS: Message Buffer 35 CS Register
pub mod CS35 {
    pub use super::CS3::BRS;
    pub use super::CS3::CODE;
    pub use super::CS3::DATA_BYTE_0;
    pub use super::CS3::DATA_BYTE_1;
    pub use super::CS3::DATA_BYTE_2;
    pub use super::CS3::DATA_BYTE_3;
    pub use super::CS3::DATA_BYTE_40;
    pub use super::CS3::DATA_BYTE_41;
    pub use super::CS3::DATA_BYTE_42;
    pub use super::CS3::DATA_BYTE_43;
    pub use super::CS3::DLC;
    pub use super::CS3::EDL;
    pub use super::CS3::ESI;
    pub use super::CS3::IDE;
    pub use super::CS3::RTR;
    pub use super::CS3::SRR;
    pub use super::CS3::TIME_STAMP;
}

/// ID35 and MB35_8B_ID
/// ID35: ID35 and MB2_16B_ID_H
/// ID35: ID35 and MB1_32B_WORD1_H
/// ID35: ID35 and MB0_64B_WORD11_H
/// ID35: Message Buffer 35 ID Register
/// MB0_64B_WORD11_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD1_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_ID_H: Message Buffer 2 ID Register
/// MB35_8B_ID: Message Buffer 35 ID Register
pub mod ID35 {
    pub use super::ID3::DATA_BYTE_4;
    pub use super::ID3::DATA_BYTE_44;
    pub use super::ID3::DATA_BYTE_45;
    pub use super::ID3::DATA_BYTE_46;
    pub use super::ID3::DATA_BYTE_47;
    pub use super::ID3::DATA_BYTE_5;
    pub use super::ID3::DATA_BYTE_6;
    pub use super::ID3::DATA_BYTE_7;
    pub use super::ID3::EXT;
    pub use super::ID3::PRIO;
    pub use super::ID3::STD;
}

/// MB0_64B_WORD12_H and WORD035
/// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB35_8B_WORD0
/// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB2_16B_WORD0_H
/// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB1_32B_WORD2_H
/// MB0_64B_WORD12_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD2_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD0_H: Message Buffer 2 WORD_16B Register
/// MB35_8B_WORD0: Message Buffer 35 WORD_8B Register
/// WORD035: Message Buffer 35 WORD0 Register
pub mod MB0_64B_WORD12_H {
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_0;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_1;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_10;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_11;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_2;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_3;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_48;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_49;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_50;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_51;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_8;
    pub use super::MB0_64B_WORD12_L::DATA_BYTE_9;
}

/// MB0_64B_WORD13_H and WORD135
/// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB35_8B_WORD1
/// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB2_16B_WORD1_H
/// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB1_32B_WORD3_H
/// MB0_64B_WORD13_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD3_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD1_H: Message Buffer 2 WORD_16B Register
/// MB35_8B_WORD1: Message Buffer 35 WORD_8B Register
/// WORD135: Message Buffer 35 WORD1 Register
pub mod MB0_64B_WORD13_H {
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_12;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_13;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_14;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_15;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_4;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_5;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_52;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_53;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_54;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_55;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_6;
    pub use super::MB0_64B_WORD13_L::DATA_BYTE_7;
}

/// CS36 and MB36_8B_CS
/// CS36: CS36 and MB2_16B_WORD2_H
/// CS36: CS36 and MB1_32B_WORD4_H
/// CS36: CS36 and MB0_64B_WORD14_H
/// CS36: Message Buffer 36 CS Register
/// MB0_64B_WORD14_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD4_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD2_H: Message Buffer 2 WORD_16B Register
/// MB36_8B_CS: Message Buffer 36 CS Register
pub mod CS36 {
    pub use super::CS4::BRS;
    pub use super::CS4::CODE;
    pub use super::CS4::DATA_BYTE_10;
    pub use super::CS4::DATA_BYTE_11;
    pub use super::CS4::DATA_BYTE_16;
    pub use super::CS4::DATA_BYTE_17;
    pub use super::CS4::DATA_BYTE_18;
    pub use super::CS4::DATA_BYTE_19;
    pub use super::CS4::DATA_BYTE_56;
    pub use super::CS4::DATA_BYTE_57;
    pub use super::CS4::DATA_BYTE_58;
    pub use super::CS4::DATA_BYTE_59;
    pub use super::CS4::DATA_BYTE_8;
    pub use super::CS4::DATA_BYTE_9;
    pub use super::CS4::DLC;
    pub use super::CS4::EDL;
    pub use super::CS4::ESI;
    pub use super::CS4::IDE;
    pub use super::CS4::RTR;
    pub use super::CS4::SRR;
    pub use super::CS4::TIME_STAMP;
}

/// ID36 and MB36_8B_ID
/// ID36: ID36 and MB2_16B_WORD3_H
/// ID36: ID36 and MB1_32B_WORD5_H
/// ID36: ID36 and MB0_64B_WORD15_H
/// ID36: Message Buffer 36 ID Register
/// MB0_64B_WORD15_H: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD5_H: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD3_H: Message Buffer 2 WORD_16B Register
/// MB36_8B_ID: Message Buffer 36 ID Register
pub mod ID36 {
    pub use super::ID4::DATA_BYTE_12;
    pub use super::ID4::DATA_BYTE_13;
    pub use super::ID4::DATA_BYTE_14;
    pub use super::ID4::DATA_BYTE_15;
    pub use super::ID4::DATA_BYTE_20;
    pub use super::ID4::DATA_BYTE_21;
    pub use super::ID4::DATA_BYTE_22;
    pub use super::ID4::DATA_BYTE_23;
    pub use super::ID4::DATA_BYTE_60;
    pub use super::ID4::DATA_BYTE_61;
    pub use super::ID4::DATA_BYTE_62;
    pub use super::ID4::DATA_BYTE_63;
    pub use super::ID4::EXT;
    pub use super::ID4::PRIO;
    pub use super::ID4::STD;
}

/// MB1_32B_WORD6_H and WORD036
/// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB3_16B_CS_H
/// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB36_8B_WORD0
/// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB1_64B_CS_H
/// MB1_32B_WORD6_H: Message Buffer 1 WORD_32B Register
/// MB1_64B_CS_H: Message Buffer 1 CS Register
/// MB36_8B_WORD0: Message Buffer 36 WORD_8B Register
/// MB3_16B_CS_H: Message Buffer 3 CS Register
/// WORD036: Message Buffer 36 WORD0 Register
pub mod MB1_32B_WORD6_H {
    pub use super::MB1::BRS;
    pub use super::MB1::CODE;
    pub use super::MB1::DATA_BYTE_0;
    pub use super::MB1::DATA_BYTE_1;
    pub use super::MB1::DATA_BYTE_2;
    pub use super::MB1::DATA_BYTE_24;
    pub use super::MB1::DATA_BYTE_25;
    pub use super::MB1::DATA_BYTE_26;
    pub use super::MB1::DATA_BYTE_27;
    pub use super::MB1::DATA_BYTE_3;
    pub use super::MB1::DLC;
    pub use super::MB1::EDL;
    pub use super::MB1::ESI;
    pub use super::MB1::IDE;
    pub use super::MB1::RTR;
    pub use super::MB1::SRR;
    pub use super::MB1::TIME_STAMP;
}

/// MB1_32B_WORD7_H and WORD136
/// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB3_16B_ID_H
/// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB36_8B_WORD1
/// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB1_64B_ID_H
/// MB1_32B_WORD7_H: Message Buffer 1 WORD_32B Register
/// MB1_64B_ID_H: Message Buffer 1 ID Register
/// MB36_8B_WORD1: Message Buffer 36 WORD_8B Register
/// MB3_16B_ID_H: Message Buffer 3 ID Register
/// WORD136: Message Buffer 36 WORD1 Register
pub mod MB1_32B_WORD7_H {
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_28;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_29;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_30;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_31;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_4;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_5;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_6;
    pub use super::MB1_32B_WORD7_L::DATA_BYTE_7;
    pub use super::MB1_32B_WORD7_L::EXT;
    pub use super::MB1_32B_WORD7_L::PRIO;
    pub use super::MB1_32B_WORD7_L::STD;
}

/// CS37 and MB3_16B_WORD0_H
/// CS37: CS37 and MB37_8B_CS
/// CS37: CS37 and MB2_32B_CS_H
/// CS37: CS37 and MB1_64B_WORD0_H
/// CS37: Message Buffer 37 CS Register
/// MB1_64B_WORD0_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_CS_H: Message Buffer 2 CS Register
/// MB37_8B_CS: Message Buffer 37 CS Register
/// MB3_16B_WORD0_H: Message Buffer 3 WORD_16B Register
pub mod CS37 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID37 and MB3_16B_WORD1_H
/// ID37: ID37 and MB37_8B_ID
/// ID37: ID37 and MB2_32B_ID_H
/// ID37: ID37 and MB1_64B_WORD1_H
/// ID37: Message Buffer 37 ID Register
/// MB1_64B_WORD1_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_ID_H: Message Buffer 2 ID Register
/// MB37_8B_ID: Message Buffer 37 ID Register
/// MB3_16B_WORD1_H: Message Buffer 3 WORD_16B Register
pub mod ID37 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB1_64B_WORD2_H and WORD037
/// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB3_16B_WORD2_H
/// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB37_8B_WORD0
/// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB2_32B_WORD0_H
/// MB1_64B_WORD2_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD0_H: Message Buffer 2 WORD_32B Register
/// MB37_8B_WORD0: Message Buffer 37 WORD_8B Register
/// MB3_16B_WORD2_H: Message Buffer 3 WORD_16B Register
/// WORD037: Message Buffer 37 WORD0 Register
pub mod MB1_64B_WORD2_H {
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_0;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_1;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_10;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_11;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_2;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_3;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_8;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_9;
}

/// MB1_64B_WORD3_H and WORD137
/// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB3_16B_WORD3_H
/// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB37_8B_WORD1
/// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB2_32B_WORD1_H
/// MB1_64B_WORD3_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD1_H: Message Buffer 2 WORD_32B Register
/// MB37_8B_WORD1: Message Buffer 37 WORD_8B Register
/// MB3_16B_WORD3_H: Message Buffer 3 WORD_16B Register
/// WORD137: Message Buffer 37 WORD1 Register
pub mod MB1_64B_WORD3_H {
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_12;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_13;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_14;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_15;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_4;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_5;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_6;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_7;
}

/// CS38 and MB4_16B_CS_H
/// CS38: CS38 and MB38_8B_CS
/// CS38: CS38 and MB2_32B_WORD2_H
/// CS38: CS38 and MB1_64B_WORD4_H
/// CS38: Message Buffer 38 CS Register
/// MB1_64B_WORD4_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD2_H: Message Buffer 2 WORD_32B Register
/// MB38_8B_CS: Message Buffer 38 CS Register
/// MB4_16B_CS_H: Message Buffer 4 CS Register
pub mod CS38 {
    pub use super::CS6::BRS;
    pub use super::CS6::CODE;
    pub use super::CS6::DATA_BYTE_10;
    pub use super::CS6::DATA_BYTE_11;
    pub use super::CS6::DATA_BYTE_16;
    pub use super::CS6::DATA_BYTE_17;
    pub use super::CS6::DATA_BYTE_18;
    pub use super::CS6::DATA_BYTE_19;
    pub use super::CS6::DATA_BYTE_8;
    pub use super::CS6::DATA_BYTE_9;
    pub use super::CS6::DLC;
    pub use super::CS6::EDL;
    pub use super::CS6::ESI;
    pub use super::CS6::IDE;
    pub use super::CS6::RTR;
    pub use super::CS6::SRR;
    pub use super::CS6::TIME_STAMP;
}

/// ID38 and MB4_16B_ID_H
/// ID38: ID38 and MB38_8B_ID
/// ID38: ID38 and MB2_32B_WORD3_H
/// ID38: ID38 and MB1_64B_WORD5_H
/// ID38: Message Buffer 38 ID Register
/// MB1_64B_WORD5_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD3_H: Message Buffer 2 WORD_32B Register
/// MB38_8B_ID: Message Buffer 38 ID Register
/// MB4_16B_ID_H: Message Buffer 4 ID Register
pub mod ID38 {
    pub use super::ID6::DATA_BYTE_12;
    pub use super::ID6::DATA_BYTE_13;
    pub use super::ID6::DATA_BYTE_14;
    pub use super::ID6::DATA_BYTE_15;
    pub use super::ID6::DATA_BYTE_20;
    pub use super::ID6::DATA_BYTE_21;
    pub use super::ID6::DATA_BYTE_22;
    pub use super::ID6::DATA_BYTE_23;
    pub use super::ID6::EXT;
    pub use super::ID6::PRIO;
    pub use super::ID6::STD;
}

/// MB1_64B_WORD6_H and WORD038
/// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB4_16B_WORD0_H
/// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB38_8B_WORD0
/// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB2_32B_WORD4_H
/// MB1_64B_WORD6_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD4_H: Message Buffer 2 WORD_32B Register
/// MB38_8B_WORD0: Message Buffer 38 WORD_8B Register
/// MB4_16B_WORD0_H: Message Buffer 4 WORD_16B Register
/// WORD038: Message Buffer 38 WORD0 Register
pub mod MB1_64B_WORD6_H {
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_0;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_1;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_16;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_17;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_18;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_19;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_2;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_24;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_25;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_26;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_27;
    pub use super::MB1_64B_WORD6_L::DATA_BYTE_3;
}

/// MB1_64B_WORD7_H and WORD138
/// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB4_16B_WORD1_H
/// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB38_8B_WORD1
/// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB2_32B_WORD5_H
/// MB1_64B_WORD7_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD5_H: Message Buffer 2 WORD_32B Register
/// MB38_8B_WORD1: Message Buffer 38 WORD_8B Register
/// MB4_16B_WORD1_H: Message Buffer 4 WORD_16B Register
/// WORD138: Message Buffer 38 WORD1 Register
pub mod MB1_64B_WORD7_H {
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_20;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_21;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_22;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_23;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_28;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_29;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_30;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_31;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_4;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_5;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_6;
    pub use super::MB1_64B_WORD7_L::DATA_BYTE_7;
}

/// CS39 and MB4_16B_WORD2_H
/// CS39: CS39 and MB39_8B_CS
/// CS39: CS39 and MB2_32B_WORD6_H
/// CS39: CS39 and MB1_64B_WORD8_H
/// CS39: Message Buffer 39 CS Register
/// MB1_64B_WORD8_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD6_H: Message Buffer 2 WORD_32B Register
/// MB39_8B_CS: Message Buffer 39 CS Register
/// MB4_16B_WORD2_H: Message Buffer 4 WORD_16B Register
pub mod CS39 {
    pub use super::CS7::BRS;
    pub use super::CS7::CODE;
    pub use super::CS7::DATA_BYTE_10;
    pub use super::CS7::DATA_BYTE_11;
    pub use super::CS7::DATA_BYTE_24;
    pub use super::CS7::DATA_BYTE_25;
    pub use super::CS7::DATA_BYTE_26;
    pub use super::CS7::DATA_BYTE_27;
    pub use super::CS7::DATA_BYTE_32;
    pub use super::CS7::DATA_BYTE_33;
    pub use super::CS7::DATA_BYTE_34;
    pub use super::CS7::DATA_BYTE_35;
    pub use super::CS7::DATA_BYTE_8;
    pub use super::CS7::DATA_BYTE_9;
    pub use super::CS7::DLC;
    pub use super::CS7::EDL;
    pub use super::CS7::ESI;
    pub use super::CS7::IDE;
    pub use super::CS7::RTR;
    pub use super::CS7::SRR;
    pub use super::CS7::TIME_STAMP;
}

/// ID39 and MB4_16B_WORD3_H
/// ID39: ID39 and MB39_8B_ID
/// ID39: ID39 and MB2_32B_WORD7_H
/// ID39: ID39 and MB1_64B_WORD9_H
/// ID39: Message Buffer 39 ID Register
/// MB1_64B_WORD9_H: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD7_H: Message Buffer 2 WORD_32B Register
/// MB39_8B_ID: Message Buffer 39 ID Register
/// MB4_16B_WORD3_H: Message Buffer 4 WORD_16B Register
pub mod ID39 {
    pub use super::ID7::DATA_BYTE_12;
    pub use super::ID7::DATA_BYTE_13;
    pub use super::ID7::DATA_BYTE_14;
    pub use super::ID7::DATA_BYTE_15;
    pub use super::ID7::DATA_BYTE_28;
    pub use super::ID7::DATA_BYTE_29;
    pub use super::ID7::DATA_BYTE_30;
    pub use super::ID7::DATA_BYTE_31;
    pub use super::ID7::DATA_BYTE_36;
    pub use super::ID7::DATA_BYTE_37;
    pub use super::ID7::DATA_BYTE_38;
    pub use super::ID7::DATA_BYTE_39;
    pub use super::ID7::EXT;
    pub use super::ID7::PRIO;
    pub use super::ID7::STD;
}

/// MB1_64B_WORD10_H and WORD039
/// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB5_16B_CS_H
/// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB3_32B_CS_H
/// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB39_8B_WORD0
/// MB1_64B_WORD10_H: Message Buffer 1 WORD_64B Register
/// MB39_8B_WORD0: Message Buffer 39 WORD_8B Register
/// MB3_32B_CS_H: Message Buffer 3 CS Register
/// MB5_16B_CS_H: Message Buffer 5 CS Register
/// WORD039: Message Buffer 39 WORD0 Register
pub mod MB1_64B_WORD10_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD11_H and WORD139
/// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB5_16B_ID_H
/// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB3_32B_ID_H
/// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB39_8B_WORD1
/// MB1_64B_WORD11_H: Message Buffer 1 WORD_64B Register
/// MB39_8B_WORD1: Message Buffer 39 WORD_8B Register
/// MB3_32B_ID_H: Message Buffer 3 ID Register
/// MB5_16B_ID_H: Message Buffer 5 ID Register
/// WORD139: Message Buffer 39 WORD1 Register
pub mod MB1_64B_WORD11_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS40 and MB5_16B_WORD0_H
/// CS40: CS40 and MB40_8B_CS
/// CS40: CS40 and MB3_32B_WORD0_H
/// CS40: CS40 and MB1_64B_WORD12_H
/// CS40: Message Buffer 40 CS Register
/// MB1_64B_WORD12_H: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD0_H: Message Buffer 3 WORD_32B Register
/// MB40_8B_CS: Message Buffer 40 CS Register
/// MB5_16B_WORD0_H: Message Buffer 5 WORD_16B Register
pub mod CS40 {
    pub use super::CS8::BRS;
    pub use super::CS8::CODE;
    pub use super::CS8::DATA_BYTE_0;
    pub use super::CS8::DATA_BYTE_1;
    pub use super::CS8::DATA_BYTE_2;
    pub use super::CS8::DATA_BYTE_3;
    pub use super::CS8::DATA_BYTE_48;
    pub use super::CS8::DATA_BYTE_49;
    pub use super::CS8::DATA_BYTE_50;
    pub use super::CS8::DATA_BYTE_51;
    pub use super::CS8::DLC;
    pub use super::CS8::EDL;
    pub use super::CS8::ESI;
    pub use super::CS8::IDE;
    pub use super::CS8::RTR;
    pub use super::CS8::SRR;
    pub use super::CS8::TIME_STAMP;
}

/// ID40 and MB5_16B_WORD1_H
/// ID40: ID40 and MB40_8B_ID
/// ID40: ID40 and MB3_32B_WORD1_H
/// ID40: ID40 and MB1_64B_WORD13_H
/// ID40: Message Buffer 40 ID Register
/// MB1_64B_WORD13_H: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD1_H: Message Buffer 3 WORD_32B Register
/// MB40_8B_ID: Message Buffer 40 ID Register
/// MB5_16B_WORD1_H: Message Buffer 5 WORD_16B Register
pub mod ID40 {
    pub use super::ID8::DATA_BYTE_4;
    pub use super::ID8::DATA_BYTE_5;
    pub use super::ID8::DATA_BYTE_52;
    pub use super::ID8::DATA_BYTE_53;
    pub use super::ID8::DATA_BYTE_54;
    pub use super::ID8::DATA_BYTE_55;
    pub use super::ID8::DATA_BYTE_6;
    pub use super::ID8::DATA_BYTE_7;
    pub use super::ID8::EXT;
    pub use super::ID8::PRIO;
    pub use super::ID8::STD;
}

/// MB1_64B_WORD14_H and WORD040
/// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB5_16B_WORD2_H
/// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB40_8B_WORD0
/// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB3_32B_WORD2_H
/// MB1_64B_WORD14_H: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD2_H: Message Buffer 3 WORD_32B Register
/// MB40_8B_WORD0: Message Buffer 40 WORD_8B Register
/// MB5_16B_WORD2_H: Message Buffer 5 WORD_16B Register
/// WORD040: Message Buffer 40 WORD0 Register
pub mod MB1_64B_WORD14_H {
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_0;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_1;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_10;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_11;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_2;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_3;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_56;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_57;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_58;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_59;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_8;
    pub use super::MB1_64B_WORD14_L::DATA_BYTE_9;
}

/// MB1_64B_WORD15_H and WORD140
/// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB5_16B_WORD3_H
/// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB40_8B_WORD1
/// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB3_32B_WORD3_H
/// MB1_64B_WORD15_H: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD3_H: Message Buffer 3 WORD_32B Register
/// MB40_8B_WORD1: Message Buffer 40 WORD_8B Register
/// MB5_16B_WORD3_H: Message Buffer 5 WORD_16B Register
/// WORD140: Message Buffer 40 WORD1 Register
pub mod MB1_64B_WORD15_H {
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_12;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_13;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_14;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_15;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_4;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_5;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_6;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_60;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_61;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_62;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_63;
    pub use super::MB1_64B_WORD15_L::DATA_BYTE_7;
}

/// CS41 and MB6_16B_CS_H
/// CS41: CS41 and MB41_8B_CS
/// CS41: CS41 and MB3_32B_WORD4_H
/// CS41: CS41 and MB2_64B_CS_H
/// CS41: Message Buffer 41 CS Register
/// MB2_64B_CS_H: Message Buffer 2 CS Register
/// MB3_32B_WORD4_H: Message Buffer 3 WORD_32B Register
/// MB41_8B_CS: Message Buffer 41 CS Register
/// MB6_16B_CS_H: Message Buffer 6 CS Register
pub mod CS41 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID41 and MB6_16B_ID_H
/// ID41: ID41 and MB41_8B_ID
/// ID41: ID41 and MB3_32B_WORD5_H
/// ID41: ID41 and MB2_64B_ID_H
/// ID41: Message Buffer 41 ID Register
/// MB2_64B_ID_H: Message Buffer 2 ID Register
/// MB3_32B_WORD5_H: Message Buffer 3 WORD_32B Register
/// MB41_8B_ID: Message Buffer 41 ID Register
/// MB6_16B_ID_H: Message Buffer 6 ID Register
pub mod ID41 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB2_64B_WORD0_H and WORD041
/// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB6_16B_WORD0_H
/// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB41_8B_WORD0
/// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB3_32B_WORD6_H
/// MB2_64B_WORD0_H: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD6_H: Message Buffer 3 WORD_32B Register
/// MB41_8B_WORD0: Message Buffer 41 WORD_8B Register
/// MB6_16B_WORD0_H: Message Buffer 6 WORD_16B Register
/// WORD041: Message Buffer 41 WORD0 Register
pub mod MB2_64B_WORD0_H {
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_3;
}

/// MB2_64B_WORD1_H and WORD141
/// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB6_16B_WORD1_H
/// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB41_8B_WORD1
/// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB3_32B_WORD7_H
/// MB2_64B_WORD1_H: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD7_H: Message Buffer 3 WORD_32B Register
/// MB41_8B_WORD1: Message Buffer 41 WORD_8B Register
/// MB6_16B_WORD1_H: Message Buffer 6 WORD_16B Register
/// WORD141: Message Buffer 41 WORD1 Register
pub mod MB2_64B_WORD1_H {
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_7;
}

/// CS42 and MB6_16B_WORD2_H
/// CS42: CS42 and MB4_32B_CS_H
/// CS42: CS42 and MB42_8B_CS
/// CS42: CS42 and MB2_64B_WORD2_H
/// CS42: Message Buffer 42 CS Register
/// MB2_64B_WORD2_H: Message Buffer 2 WORD_64B Register
/// MB42_8B_CS: Message Buffer 42 CS Register
/// MB4_32B_CS_H: Message Buffer 4 CS Register
/// MB6_16B_WORD2_H: Message Buffer 6 WORD_16B Register
pub mod CS42 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID42 and MB6_16B_WORD3_H
/// ID42: ID42 and MB4_32B_ID_H
/// ID42: ID42 and MB42_8B_ID
/// ID42: ID42 and MB2_64B_WORD3_H
/// ID42: Message Buffer 42 ID Register
/// MB2_64B_WORD3_H: Message Buffer 2 WORD_64B Register
/// MB42_8B_ID: Message Buffer 42 ID Register
/// MB4_32B_ID_H: Message Buffer 4 ID Register
/// MB6_16B_WORD3_H: Message Buffer 6 WORD_16B Register
pub mod ID42 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB2_64B_WORD4_H and WORD042
/// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB7_16B_CS_H
/// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB4_32B_WORD0_H
/// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB42_8B_WORD0
/// MB2_64B_WORD4_H: Message Buffer 2 WORD_64B Register
/// MB42_8B_WORD0: Message Buffer 42 WORD_8B Register
/// MB4_32B_WORD0_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_CS_H: Message Buffer 7 CS Register
/// WORD042: Message Buffer 42 WORD0 Register
pub mod MB2_64B_WORD4_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD5_H and WORD142
/// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB7_16B_ID_H
/// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB4_32B_WORD1_H
/// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB42_8B_WORD1
/// MB2_64B_WORD5_H: Message Buffer 2 WORD_64B Register
/// MB42_8B_WORD1: Message Buffer 42 WORD_8B Register
/// MB4_32B_WORD1_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_ID_H: Message Buffer 7 ID Register
/// WORD142: Message Buffer 42 WORD1 Register
pub mod MB2_64B_WORD5_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS43 and MB7_16B_WORD0_H
/// CS43: CS43 and MB4_32B_WORD2_H
/// CS43: CS43 and MB43_8B_CS
/// CS43: CS43 and MB2_64B_WORD6_H
/// CS43: Message Buffer 43 CS Register
/// MB2_64B_WORD6_H: Message Buffer 2 WORD_64B Register
/// MB43_8B_CS: Message Buffer 43 CS Register
/// MB4_32B_WORD2_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD0_H: Message Buffer 7 WORD_16B Register
pub mod CS43 {
    pub use super::CS11::BRS;
    pub use super::CS11::CODE;
    pub use super::CS11::DATA_BYTE_0;
    pub use super::CS11::DATA_BYTE_1;
    pub use super::CS11::DATA_BYTE_10;
    pub use super::CS11::DATA_BYTE_11;
    pub use super::CS11::DATA_BYTE_2;
    pub use super::CS11::DATA_BYTE_24;
    pub use super::CS11::DATA_BYTE_25;
    pub use super::CS11::DATA_BYTE_26;
    pub use super::CS11::DATA_BYTE_27;
    pub use super::CS11::DATA_BYTE_3;
    pub use super::CS11::DATA_BYTE_8;
    pub use super::CS11::DATA_BYTE_9;
    pub use super::CS11::DLC;
    pub use super::CS11::EDL;
    pub use super::CS11::ESI;
    pub use super::CS11::IDE;
    pub use super::CS11::RTR;
    pub use super::CS11::SRR;
    pub use super::CS11::TIME_STAMP;
}

/// ID43 and MB7_16B_WORD1_H
/// ID43: ID43 and MB4_32B_WORD3_H
/// ID43: ID43 and MB43_8B_ID
/// ID43: ID43 and MB2_64B_WORD7_H
/// ID43: Message Buffer 43 ID Register
/// MB2_64B_WORD7_H: Message Buffer 2 WORD_64B Register
/// MB43_8B_ID: Message Buffer 43 ID Register
/// MB4_32B_WORD3_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD1_H: Message Buffer 7 WORD_16B Register
pub mod ID43 {
    pub use super::ID11::DATA_BYTE_12;
    pub use super::ID11::DATA_BYTE_13;
    pub use super::ID11::DATA_BYTE_14;
    pub use super::ID11::DATA_BYTE_15;
    pub use super::ID11::DATA_BYTE_28;
    pub use super::ID11::DATA_BYTE_29;
    pub use super::ID11::DATA_BYTE_30;
    pub use super::ID11::DATA_BYTE_31;
    pub use super::ID11::DATA_BYTE_4;
    pub use super::ID11::DATA_BYTE_5;
    pub use super::ID11::DATA_BYTE_6;
    pub use super::ID11::DATA_BYTE_7;
    pub use super::ID11::EXT;
    pub use super::ID11::PRIO;
    pub use super::ID11::STD;
}

/// MB2_64B_WORD8_H and WORD043
/// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB7_16B_WORD2_H
/// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB4_32B_WORD4_H
/// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB43_8B_WORD0
/// MB2_64B_WORD8_H: Message Buffer 2 WORD_64B Register
/// MB43_8B_WORD0: Message Buffer 43 WORD_8B Register
/// MB4_32B_WORD4_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD2_H: Message Buffer 7 WORD_16B Register
/// WORD043: Message Buffer 43 WORD0 Register
pub mod MB2_64B_WORD8_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD9_H and WORD143
/// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB7_16B_WORD3_H
/// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB4_32B_WORD5_H
/// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB43_8B_WORD1
/// MB2_64B_WORD9_H: Message Buffer 2 WORD_64B Register
/// MB43_8B_WORD1: Message Buffer 43 WORD_8B Register
/// MB4_32B_WORD5_H: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD3_H: Message Buffer 7 WORD_16B Register
/// WORD143: Message Buffer 43 WORD1 Register
pub mod MB2_64B_WORD9_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS44 and MB8_16B_CS_H
/// CS44: CS44 and MB4_32B_WORD6_H
/// CS44: CS44 and MB44_8B_CS
/// CS44: CS44 and MB2_64B_WORD10_H
/// CS44: Message Buffer 44 CS Register
/// MB2_64B_WORD10_H: Message Buffer 2 WORD_64B Register
/// MB44_8B_CS: Message Buffer 44 CS Register
/// MB4_32B_WORD6_H: Message Buffer 4 WORD_32B Register
/// MB8_16B_CS_H: Message Buffer 8 CS Register
pub mod CS44 {
    pub use super::CS12::BRS;
    pub use super::CS12::CODE;
    pub use super::CS12::DATA_BYTE_24;
    pub use super::CS12::DATA_BYTE_25;
    pub use super::CS12::DATA_BYTE_26;
    pub use super::CS12::DATA_BYTE_27;
    pub use super::CS12::DATA_BYTE_40;
    pub use super::CS12::DATA_BYTE_41;
    pub use super::CS12::DATA_BYTE_42;
    pub use super::CS12::DATA_BYTE_43;
    pub use super::CS12::DLC;
    pub use super::CS12::EDL;
    pub use super::CS12::ESI;
    pub use super::CS12::IDE;
    pub use super::CS12::RTR;
    pub use super::CS12::SRR;
    pub use super::CS12::TIME_STAMP;
}

/// ID44 and MB8_16B_ID_H
/// ID44: ID44 and MB4_32B_WORD7_H
/// ID44: ID44 and MB44_8B_ID
/// ID44: ID44 and MB2_64B_WORD11_H
/// ID44: Message Buffer 44 ID Register
/// MB2_64B_WORD11_H: Message Buffer 2 WORD_64B Register
/// MB44_8B_ID: Message Buffer 44 ID Register
/// MB4_32B_WORD7_H: Message Buffer 4 WORD_32B Register
/// MB8_16B_ID_H: Message Buffer 8 ID Register
pub mod ID44 {
    pub use super::ID12::DATA_BYTE_28;
    pub use super::ID12::DATA_BYTE_29;
    pub use super::ID12::DATA_BYTE_30;
    pub use super::ID12::DATA_BYTE_31;
    pub use super::ID12::DATA_BYTE_44;
    pub use super::ID12::DATA_BYTE_45;
    pub use super::ID12::DATA_BYTE_46;
    pub use super::ID12::DATA_BYTE_47;
    pub use super::ID12::EXT;
    pub use super::ID12::PRIO;
    pub use super::ID12::STD;
}

/// MB2_64B_WORD12_H and WORD044
/// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB8_16B_WORD0_H
/// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB5_32B_CS_H
/// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB44_8B_WORD0
/// MB2_64B_WORD12_H: Message Buffer 2 WORD_64B Register
/// MB44_8B_WORD0: Message Buffer 44 WORD_8B Register
/// MB5_32B_CS_H: Message Buffer 5 CS Register
/// MB8_16B_WORD0_H: Message Buffer 8 WORD_16B Register
/// WORD044: Message Buffer 44 WORD0 Register
pub mod MB2_64B_WORD12_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD13_H and WORD144
/// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB8_16B_WORD1_H
/// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB5_32B_ID_H
/// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB44_8B_WORD1
/// MB2_64B_WORD13_H: Message Buffer 2 WORD_64B Register
/// MB44_8B_WORD1: Message Buffer 44 WORD_8B Register
/// MB5_32B_ID_H: Message Buffer 5 ID Register
/// MB8_16B_WORD1_H: Message Buffer 8 WORD_16B Register
/// WORD144: Message Buffer 44 WORD1 Register
pub mod MB2_64B_WORD13_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS45 and MB8_16B_WORD2_H
/// CS45: CS45 and MB5_32B_WORD0_H
/// CS45: CS45 and MB45_8B_CS
/// CS45: CS45 and MB2_64B_WORD14_H
/// CS45: Message Buffer 45 CS Register
/// MB2_64B_WORD14_H: Message Buffer 2 WORD_64B Register
/// MB45_8B_CS: Message Buffer 45 CS Register
/// MB5_32B_WORD0_H: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD2_H: Message Buffer 8 WORD_16B Register
pub mod CS45 {
    pub use super::CS13::BRS;
    pub use super::CS13::CODE;
    pub use super::CS13::DATA_BYTE_0;
    pub use super::CS13::DATA_BYTE_1;
    pub use super::CS13::DATA_BYTE_10;
    pub use super::CS13::DATA_BYTE_11;
    pub use super::CS13::DATA_BYTE_2;
    pub use super::CS13::DATA_BYTE_3;
    pub use super::CS13::DATA_BYTE_56;
    pub use super::CS13::DATA_BYTE_57;
    pub use super::CS13::DATA_BYTE_58;
    pub use super::CS13::DATA_BYTE_59;
    pub use super::CS13::DATA_BYTE_8;
    pub use super::CS13::DATA_BYTE_9;
    pub use super::CS13::DLC;
    pub use super::CS13::EDL;
    pub use super::CS13::ESI;
    pub use super::CS13::IDE;
    pub use super::CS13::RTR;
    pub use super::CS13::SRR;
    pub use super::CS13::TIME_STAMP;
}

/// ID45 and MB8_16B_WORD3_H
/// ID45: ID45 and MB5_32B_WORD1_H
/// ID45: ID45 and MB45_8B_ID
/// ID45: ID45 and MB2_64B_WORD15_H
/// ID45: Message Buffer 45 ID Register
/// MB2_64B_WORD15_H: Message Buffer 2 WORD_64B Register
/// MB45_8B_ID: Message Buffer 45 ID Register
/// MB5_32B_WORD1_H: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD3_H: Message Buffer 8 WORD_16B Register
pub mod ID45 {
    pub use super::ID13::DATA_BYTE_12;
    pub use super::ID13::DATA_BYTE_13;
    pub use super::ID13::DATA_BYTE_14;
    pub use super::ID13::DATA_BYTE_15;
    pub use super::ID13::DATA_BYTE_4;
    pub use super::ID13::DATA_BYTE_5;
    pub use super::ID13::DATA_BYTE_6;
    pub use super::ID13::DATA_BYTE_60;
    pub use super::ID13::DATA_BYTE_61;
    pub use super::ID13::DATA_BYTE_62;
    pub use super::ID13::DATA_BYTE_63;
    pub use super::ID13::DATA_BYTE_7;
    pub use super::ID13::EXT;
    pub use super::ID13::PRIO;
    pub use super::ID13::STD;
}

/// MB3_64B_CS_H and WORD045
/// MB3_64B_CS_H: MB3_64B_CS_H and MB9_16B_CS_H
/// MB3_64B_CS_H: MB3_64B_CS_H and MB5_32B_WORD2_H
/// MB3_64B_CS_H: MB3_64B_CS_H and MB45_8B_WORD0
/// MB3_64B_CS_H: Message Buffer 3 CS Register
/// MB45_8B_WORD0: Message Buffer 45 WORD_8B Register
/// MB5_32B_WORD2_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_CS_H: Message Buffer 9 CS Register
/// WORD045: Message Buffer 45 WORD0 Register
pub mod MB3_64B_CS_H {
    pub use super::CS28::BRS;
    pub use super::CS28::CODE;
    pub use super::CS28::DATA_BYTE_0;
    pub use super::CS28::DATA_BYTE_1;
    pub use super::CS28::DATA_BYTE_10;
    pub use super::CS28::DATA_BYTE_11;
    pub use super::CS28::DATA_BYTE_2;
    pub use super::CS28::DATA_BYTE_3;
    pub use super::CS28::DATA_BYTE_8;
    pub use super::CS28::DATA_BYTE_9;
    pub use super::CS28::DLC;
    pub use super::CS28::EDL;
    pub use super::CS28::ESI;
    pub use super::CS28::IDE;
    pub use super::CS28::RTR;
    pub use super::CS28::SRR;
    pub use super::CS28::TIME_STAMP;
}

/// MB3_64B_ID_H and WORD145
/// MB3_64B_ID_H: MB3_64B_ID_H and MB9_16B_ID_H
/// MB3_64B_ID_H: MB3_64B_ID_H and MB5_32B_WORD3_H
/// MB3_64B_ID_H: MB3_64B_ID_H and MB45_8B_WORD1
/// MB3_64B_ID_H: Message Buffer 3 ID Register
/// MB45_8B_WORD1: Message Buffer 45 WORD_8B Register
/// MB5_32B_WORD3_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_ID_H: Message Buffer 9 ID Register
/// WORD145: Message Buffer 45 WORD1 Register
pub mod MB3_64B_ID_H {
    pub use super::ID28::DATA_BYTE_12;
    pub use super::ID28::DATA_BYTE_13;
    pub use super::ID28::DATA_BYTE_14;
    pub use super::ID28::DATA_BYTE_15;
    pub use super::ID28::DATA_BYTE_4;
    pub use super::ID28::DATA_BYTE_5;
    pub use super::ID28::DATA_BYTE_6;
    pub use super::ID28::DATA_BYTE_7;
    pub use super::ID28::EXT;
    pub use super::ID28::PRIO;
    pub use super::ID28::STD;
}

/// CS46 and MB9_16B_WORD0_H
/// CS46: CS46 and MB5_32B_WORD4_H
/// CS46: CS46 and MB46_8B_CS
/// CS46: CS46 and MB3_64B_WORD0_H
/// CS46: Message Buffer 46 CS Register
/// MB3_64B_WORD0_H: Message Buffer 3 WORD_64B Register
/// MB46_8B_CS: Message Buffer 46 CS Register
/// MB5_32B_WORD4_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD0_H: Message Buffer 9 WORD_16B Register
pub mod CS46 {
    pub use super::CS14::BRS;
    pub use super::CS14::CODE;
    pub use super::CS14::DATA_BYTE_0;
    pub use super::CS14::DATA_BYTE_1;
    pub use super::CS14::DATA_BYTE_16;
    pub use super::CS14::DATA_BYTE_17;
    pub use super::CS14::DATA_BYTE_18;
    pub use super::CS14::DATA_BYTE_19;
    pub use super::CS14::DATA_BYTE_2;
    pub use super::CS14::DATA_BYTE_3;
    pub use super::CS14::DLC;
    pub use super::CS14::EDL;
    pub use super::CS14::ESI;
    pub use super::CS14::IDE;
    pub use super::CS14::RTR;
    pub use super::CS14::SRR;
    pub use super::CS14::TIME_STAMP;
}

/// ID46 and MB9_16B_WORD1_H
/// ID46: ID46 and MB5_32B_WORD5_H
/// ID46: ID46 and MB46_8B_ID
/// ID46: ID46 and MB3_64B_WORD1_H
/// ID46: Message Buffer 46 ID Register
/// MB3_64B_WORD1_H: Message Buffer 3 WORD_64B Register
/// MB46_8B_ID: Message Buffer 46 ID Register
/// MB5_32B_WORD5_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD1_H: Message Buffer 9 WORD_16B Register
pub mod ID46 {
    pub use super::ID14::DATA_BYTE_20;
    pub use super::ID14::DATA_BYTE_21;
    pub use super::ID14::DATA_BYTE_22;
    pub use super::ID14::DATA_BYTE_23;
    pub use super::ID14::DATA_BYTE_4;
    pub use super::ID14::DATA_BYTE_5;
    pub use super::ID14::DATA_BYTE_6;
    pub use super::ID14::DATA_BYTE_7;
    pub use super::ID14::EXT;
    pub use super::ID14::PRIO;
    pub use super::ID14::STD;
}

/// MB3_64B_WORD2_H and WORD046
/// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB9_16B_WORD2_H
/// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB5_32B_WORD6_H
/// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB46_8B_WORD0
/// MB3_64B_WORD2_H: Message Buffer 3 WORD_64B Register
/// MB46_8B_WORD0: Message Buffer 46 WORD_8B Register
/// MB5_32B_WORD6_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD2_H: Message Buffer 9 WORD_16B Register
/// WORD046: Message Buffer 46 WORD0 Register
pub mod MB3_64B_WORD2_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB3_64B_WORD3_H and WORD146
/// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB9_16B_WORD3_H
/// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB5_32B_WORD7_H
/// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB46_8B_WORD1
/// MB3_64B_WORD3_H: Message Buffer 3 WORD_64B Register
/// MB46_8B_WORD1: Message Buffer 46 WORD_8B Register
/// MB5_32B_WORD7_H: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD3_H: Message Buffer 9 WORD_16B Register
/// WORD146: Message Buffer 46 WORD1 Register
pub mod MB3_64B_WORD3_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS47 and MB6_32B_CS_H
/// CS47: CS47 and MB47_8B_CS
/// CS47: CS47 and MB3_64B_WORD4_H
/// CS47: CS47 and MB10_16B_CS_H
/// CS47: Message Buffer 47 CS Register
/// MB10_16B_CS_H: Message Buffer 10 CS Register
/// MB3_64B_WORD4_H: Message Buffer 3 WORD_64B Register
/// MB47_8B_CS: Message Buffer 47 CS Register
/// MB6_32B_CS_H: Message Buffer 6 CS Register
pub mod CS47 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID47 and MB6_32B_ID_H
/// ID47: ID47 and MB47_8B_ID
/// ID47: ID47 and MB3_64B_WORD5_H
/// ID47: ID47 and MB10_16B_ID_H
/// ID47: Message Buffer 47 ID Register
/// MB10_16B_ID_H: Message Buffer 10 ID Register
/// MB3_64B_WORD5_H: Message Buffer 3 WORD_64B Register
/// MB47_8B_ID: Message Buffer 47 ID Register
/// MB6_32B_ID_H: Message Buffer 6 ID Register
pub mod ID47 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB10_16B_WORD0_H and WORD047
/// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB6_32B_WORD0_H
/// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB47_8B_WORD0
/// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB3_64B_WORD6_H
/// MB10_16B_WORD0_H: Message Buffer 10 WORD_16B Register
/// MB3_64B_WORD6_H: Message Buffer 3 WORD_64B Register
/// MB47_8B_WORD0: Message Buffer 47 WORD_8B Register
/// MB6_32B_WORD0_H: Message Buffer 6 WORD_32B Register
/// WORD047: Message Buffer 47 WORD0 Register
pub mod MB10_16B_WORD0_H {
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_3;
}

/// MB10_16B_WORD1_H and WORD147
/// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB6_32B_WORD1_H
/// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB47_8B_WORD1
/// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB3_64B_WORD7_H
/// MB10_16B_WORD1_H: Message Buffer 10 WORD_16B Register
/// MB3_64B_WORD7_H: Message Buffer 3 WORD_64B Register
/// MB47_8B_WORD1: Message Buffer 47 WORD_8B Register
/// MB6_32B_WORD1_H: Message Buffer 6 WORD_32B Register
/// WORD147: Message Buffer 47 WORD1 Register
pub mod MB10_16B_WORD1_H {
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_7;
}

/// CS48 and MB6_32B_WORD2_H
/// CS48: CS48 and MB48_8B_CS
/// CS48: CS48 and MB3_64B_WORD8_H
/// CS48: CS48 and MB10_16B_WORD2_H
/// CS48: Message Buffer 48 CS Register
/// MB10_16B_WORD2_H: Message Buffer 10 WORD_16B Register
/// MB3_64B_WORD8_H: Message Buffer 3 WORD_64B Register
/// MB48_8B_CS: Message Buffer 48 CS Register
/// MB6_32B_WORD2_H: Message Buffer 6 WORD_32B Register
pub mod CS48 {
    pub use super::CS16::BRS;
    pub use super::CS16::CODE;
    pub use super::CS16::DATA_BYTE_10;
    pub use super::CS16::DATA_BYTE_11;
    pub use super::CS16::DATA_BYTE_32;
    pub use super::CS16::DATA_BYTE_33;
    pub use super::CS16::DATA_BYTE_34;
    pub use super::CS16::DATA_BYTE_35;
    pub use super::CS16::DATA_BYTE_8;
    pub use super::CS16::DATA_BYTE_9;
    pub use super::CS16::DLC;
    pub use super::CS16::EDL;
    pub use super::CS16::ESI;
    pub use super::CS16::IDE;
    pub use super::CS16::RTR;
    pub use super::CS16::SRR;
    pub use super::CS16::TIME_STAMP;
}

/// ID48 and MB6_32B_WORD3_H
/// ID48: ID48 and MB48_8B_ID
/// ID48: ID48 and MB3_64B_WORD9_H
/// ID48: ID48 and MB10_16B_WORD3_H
/// ID48: Message Buffer 48 ID Register
/// MB10_16B_WORD3_H: Message Buffer 10 WORD_16B Register
/// MB3_64B_WORD9_H: Message Buffer 3 WORD_64B Register
/// MB48_8B_ID: Message Buffer 48 ID Register
/// MB6_32B_WORD3_H: Message Buffer 6 WORD_32B Register
pub mod ID48 {
    pub use super::ID16::DATA_BYTE_12;
    pub use super::ID16::DATA_BYTE_13;
    pub use super::ID16::DATA_BYTE_14;
    pub use super::ID16::DATA_BYTE_15;
    pub use super::ID16::DATA_BYTE_36;
    pub use super::ID16::DATA_BYTE_37;
    pub use super::ID16::DATA_BYTE_38;
    pub use super::ID16::DATA_BYTE_39;
    pub use super::ID16::EXT;
    pub use super::ID16::PRIO;
    pub use super::ID16::STD;
}

/// MB11_16B_CS_H and WORD048
/// MB11_16B_CS_H: MB11_16B_CS_H and MB6_32B_WORD4_H
/// MB11_16B_CS_H: MB11_16B_CS_H and MB48_8B_WORD0
/// MB11_16B_CS_H: MB11_16B_CS_H and MB3_64B_WORD10_H
/// MB11_16B_CS_H: Message Buffer 11 CS Register
/// MB3_64B_WORD10_H: Message Buffer 3 WORD_64B Register
/// MB48_8B_WORD0: Message Buffer 48 WORD_8B Register
/// MB6_32B_WORD4_H: Message Buffer 6 WORD_32B Register
/// WORD048: Message Buffer 48 WORD0 Register
pub mod MB11_16B_CS_H {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_ID_H and WORD148
/// MB11_16B_ID_H: MB11_16B_ID_H and MB6_32B_WORD5_H
/// MB11_16B_ID_H: MB11_16B_ID_H and MB48_8B_WORD1
/// MB11_16B_ID_H: MB11_16B_ID_H and MB3_64B_WORD11_H
/// MB11_16B_ID_H: Message Buffer 11 ID Register
/// MB3_64B_WORD11_H: Message Buffer 3 WORD_64B Register
/// MB48_8B_WORD1: Message Buffer 48 WORD_8B Register
/// MB6_32B_WORD5_H: Message Buffer 6 WORD_32B Register
/// WORD148: Message Buffer 48 WORD1 Register
pub mod MB11_16B_ID_H {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS49 and MB6_32B_WORD6_H
/// CS49: CS49 and MB49_8B_CS
/// CS49: CS49 and MB3_64B_WORD12_H
/// CS49: CS49 and MB11_16B_WORD0_H
/// CS49: Message Buffer 49 CS Register
/// MB11_16B_WORD0_H: Message Buffer 11 WORD_16B Register
/// MB3_64B_WORD12_H: Message Buffer 3 WORD_64B Register
/// MB49_8B_CS: Message Buffer 49 CS Register
/// MB6_32B_WORD6_H: Message Buffer 6 WORD_32B Register
pub mod CS49 {
    pub use super::CS17::BRS;
    pub use super::CS17::CODE;
    pub use super::CS17::DATA_BYTE_0;
    pub use super::CS17::DATA_BYTE_1;
    pub use super::CS17::DATA_BYTE_2;
    pub use super::CS17::DATA_BYTE_24;
    pub use super::CS17::DATA_BYTE_25;
    pub use super::CS17::DATA_BYTE_26;
    pub use super::CS17::DATA_BYTE_27;
    pub use super::CS17::DATA_BYTE_3;
    pub use super::CS17::DATA_BYTE_48;
    pub use super::CS17::DATA_BYTE_49;
    pub use super::CS17::DATA_BYTE_50;
    pub use super::CS17::DATA_BYTE_51;
    pub use super::CS17::DLC;
    pub use super::CS17::EDL;
    pub use super::CS17::ESI;
    pub use super::CS17::IDE;
    pub use super::CS17::RTR;
    pub use super::CS17::SRR;
    pub use super::CS17::TIME_STAMP;
}

/// ID49 and MB6_32B_WORD7_H
/// ID49: ID49 and MB49_8B_ID
/// ID49: ID49 and MB3_64B_WORD13_H
/// ID49: ID49 and MB11_16B_WORD1_H
/// ID49: Message Buffer 49 ID Register
/// MB11_16B_WORD1_H: Message Buffer 11 WORD_16B Register
/// MB3_64B_WORD13_H: Message Buffer 3 WORD_64B Register
/// MB49_8B_ID: Message Buffer 49 ID Register
/// MB6_32B_WORD7_H: Message Buffer 6 WORD_32B Register
pub mod ID49 {
    pub use super::ID17::DATA_BYTE_28;
    pub use super::ID17::DATA_BYTE_29;
    pub use super::ID17::DATA_BYTE_30;
    pub use super::ID17::DATA_BYTE_31;
    pub use super::ID17::DATA_BYTE_4;
    pub use super::ID17::DATA_BYTE_5;
    pub use super::ID17::DATA_BYTE_52;
    pub use super::ID17::DATA_BYTE_53;
    pub use super::ID17::DATA_BYTE_54;
    pub use super::ID17::DATA_BYTE_55;
    pub use super::ID17::DATA_BYTE_6;
    pub use super::ID17::DATA_BYTE_7;
    pub use super::ID17::EXT;
    pub use super::ID17::PRIO;
    pub use super::ID17::STD;
}

/// MB11_16B_WORD2_H and WORD049
/// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB7_32B_CS_H
/// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB49_8B_WORD0
/// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB3_64B_WORD14_H
/// MB11_16B_WORD2_H: Message Buffer 11 WORD_16B Register
/// MB3_64B_WORD14_H: Message Buffer 3 WORD_64B Register
/// MB49_8B_WORD0: Message Buffer 49 WORD_8B Register
/// MB7_32B_CS_H: Message Buffer 7 CS Register
/// WORD049: Message Buffer 49 WORD0 Register
pub mod MB11_16B_WORD2_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_WORD3_H and WORD149
/// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB7_32B_ID_H
/// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB49_8B_WORD1
/// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB3_64B_WORD15_H
/// MB11_16B_WORD3_H: Message Buffer 11 WORD_16B Register
/// MB3_64B_WORD15_H: Message Buffer 3 WORD_64B Register
/// MB49_8B_WORD1: Message Buffer 49 WORD_8B Register
/// MB7_32B_ID_H: Message Buffer 7 ID Register
/// WORD149: Message Buffer 49 WORD1 Register
pub mod MB11_16B_WORD3_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS50 and MB7_32B_WORD0_H
/// CS50: CS50 and MB50_8B_CS
/// CS50: CS50 and MB4_64B_CS_H
/// CS50: CS50 and MB12_16B_CS_H
/// CS50: Message Buffer 50 CS Register
/// MB12_16B_CS_H: Message Buffer 12 CS Register
/// MB4_64B_CS_H: Message Buffer 4 CS Register
/// MB50_8B_CS: Message Buffer 50 CS Register
/// MB7_32B_WORD0_H: Message Buffer 7 WORD_32B Register
pub mod CS50 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID50 and MB7_32B_WORD1_H
/// ID50: ID50 and MB50_8B_ID
/// ID50: ID50 and MB4_64B_ID_H
/// ID50: ID50 and MB12_16B_ID_H
/// ID50: Message Buffer 50 ID Register
/// MB12_16B_ID_H: Message Buffer 12 ID Register
/// MB4_64B_ID_H: Message Buffer 4 ID Register
/// MB50_8B_ID: Message Buffer 50 ID Register
/// MB7_32B_WORD1_H: Message Buffer 7 WORD_32B Register
pub mod ID50 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB12_16B_WORD0_H and WORD050
/// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB7_32B_WORD2_H
/// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB50_8B_WORD0
/// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB4_64B_WORD0_H
/// MB12_16B_WORD0_H: Message Buffer 12 WORD_16B Register
/// MB4_64B_WORD0_H: Message Buffer 4 WORD_64B Register
/// MB50_8B_WORD0: Message Buffer 50 WORD_8B Register
/// MB7_32B_WORD2_H: Message Buffer 7 WORD_32B Register
/// WORD050: Message Buffer 50 WORD0 Register
pub mod MB12_16B_WORD0_H {
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_0;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_1;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_10;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_11;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_2;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_3;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_8;
    pub use super::MB12_16B_WORD0_L::DATA_BYTE_9;
}

/// MB12_16B_WORD1_H and WORD150
/// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB7_32B_WORD3_H
/// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB50_8B_WORD1
/// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB4_64B_WORD1_H
/// MB12_16B_WORD1_H: Message Buffer 12 WORD_16B Register
/// MB4_64B_WORD1_H: Message Buffer 4 WORD_64B Register
/// MB50_8B_WORD1: Message Buffer 50 WORD_8B Register
/// MB7_32B_WORD3_H: Message Buffer 7 WORD_32B Register
/// WORD150: Message Buffer 50 WORD1 Register
pub mod MB12_16B_WORD1_H {
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_12;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_13;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_14;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_15;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB12_16B_WORD1_L::DATA_BYTE_7;
}

/// CS51 and MB7_32B_WORD4_H
/// CS51: CS51 and MB51_8B_CS
/// CS51: CS51 and MB4_64B_WORD2_H
/// CS51: CS51 and MB12_16B_WORD2_H
/// CS51: Message Buffer 51 CS Register
/// MB12_16B_WORD2_H: Message Buffer 12 WORD_16B Register
/// MB4_64B_WORD2_H: Message Buffer 4 WORD_64B Register
/// MB51_8B_CS: Message Buffer 51 CS Register
/// MB7_32B_WORD4_H: Message Buffer 7 WORD_32B Register
pub mod CS51 {
    pub use super::CS19::BRS;
    pub use super::CS19::CODE;
    pub use super::CS19::DATA_BYTE_10;
    pub use super::CS19::DATA_BYTE_11;
    pub use super::CS19::DATA_BYTE_16;
    pub use super::CS19::DATA_BYTE_17;
    pub use super::CS19::DATA_BYTE_18;
    pub use super::CS19::DATA_BYTE_19;
    pub use super::CS19::DATA_BYTE_8;
    pub use super::CS19::DATA_BYTE_9;
    pub use super::CS19::DLC;
    pub use super::CS19::EDL;
    pub use super::CS19::ESI;
    pub use super::CS19::IDE;
    pub use super::CS19::RTR;
    pub use super::CS19::SRR;
    pub use super::CS19::TIME_STAMP;
}

/// ID51 and MB7_32B_WORD5_H
/// ID51: ID51 and MB51_8B_ID
/// ID51: ID51 and MB4_64B_WORD3_H
/// ID51: ID51 and MB12_16B_WORD3_H
/// ID51: Message Buffer 51 ID Register
/// MB12_16B_WORD3_H: Message Buffer 12 WORD_16B Register
/// MB4_64B_WORD3_H: Message Buffer 4 WORD_64B Register
/// MB51_8B_ID: Message Buffer 51 ID Register
/// MB7_32B_WORD5_H: Message Buffer 7 WORD_32B Register
pub mod ID51 {
    pub use super::ID19::DATA_BYTE_12;
    pub use super::ID19::DATA_BYTE_13;
    pub use super::ID19::DATA_BYTE_14;
    pub use super::ID19::DATA_BYTE_15;
    pub use super::ID19::DATA_BYTE_20;
    pub use super::ID19::DATA_BYTE_21;
    pub use super::ID19::DATA_BYTE_22;
    pub use super::ID19::DATA_BYTE_23;
    pub use super::ID19::EXT;
    pub use super::ID19::PRIO;
    pub use super::ID19::STD;
}

/// MB13_16B_CS_H and WORD051
/// MB13_16B_CS_H: MB13_16B_CS_H and MB7_32B_WORD6_H
/// MB13_16B_CS_H: MB13_16B_CS_H and MB51_8B_WORD0
/// MB13_16B_CS_H: MB13_16B_CS_H and MB4_64B_WORD4_H
/// MB13_16B_CS_H: Message Buffer 13 CS Register
/// MB4_64B_WORD4_H: Message Buffer 4 WORD_64B Register
/// MB51_8B_WORD0: Message Buffer 51 WORD_8B Register
/// MB7_32B_WORD6_H: Message Buffer 7 WORD_32B Register
/// WORD051: Message Buffer 51 WORD0 Register
pub mod MB13_16B_CS_H {
    pub use super::CS29::BRS;
    pub use super::CS29::CODE;
    pub use super::CS29::DATA_BYTE_0;
    pub use super::CS29::DATA_BYTE_1;
    pub use super::CS29::DATA_BYTE_16;
    pub use super::CS29::DATA_BYTE_17;
    pub use super::CS29::DATA_BYTE_18;
    pub use super::CS29::DATA_BYTE_19;
    pub use super::CS29::DATA_BYTE_2;
    pub use super::CS29::DATA_BYTE_24;
    pub use super::CS29::DATA_BYTE_25;
    pub use super::CS29::DATA_BYTE_26;
    pub use super::CS29::DATA_BYTE_27;
    pub use super::CS29::DATA_BYTE_3;
    pub use super::CS29::DLC;
    pub use super::CS29::EDL;
    pub use super::CS29::ESI;
    pub use super::CS29::IDE;
    pub use super::CS29::RTR;
    pub use super::CS29::SRR;
    pub use super::CS29::TIME_STAMP;
}

/// MB13_16B_ID_H and WORD151
/// MB13_16B_ID_H: MB13_16B_ID_H and MB7_32B_WORD7_H
/// MB13_16B_ID_H: MB13_16B_ID_H and MB51_8B_WORD1
/// MB13_16B_ID_H: MB13_16B_ID_H and MB4_64B_WORD5_H
/// MB13_16B_ID_H: Message Buffer 13 ID Register
/// MB4_64B_WORD5_H: Message Buffer 4 WORD_64B Register
/// MB51_8B_WORD1: Message Buffer 51 WORD_8B Register
/// MB7_32B_WORD7_H: Message Buffer 7 WORD_32B Register
/// WORD151: Message Buffer 51 WORD1 Register
pub mod MB13_16B_ID_H {
    pub use super::ID29::DATA_BYTE_20;
    pub use super::ID29::DATA_BYTE_21;
    pub use super::ID29::DATA_BYTE_22;
    pub use super::ID29::DATA_BYTE_23;
    pub use super::ID29::DATA_BYTE_28;
    pub use super::ID29::DATA_BYTE_29;
    pub use super::ID29::DATA_BYTE_30;
    pub use super::ID29::DATA_BYTE_31;
    pub use super::ID29::DATA_BYTE_4;
    pub use super::ID29::DATA_BYTE_5;
    pub use super::ID29::DATA_BYTE_6;
    pub use super::ID29::DATA_BYTE_7;
    pub use super::ID29::EXT;
    pub use super::ID29::PRIO;
    pub use super::ID29::STD;
}

/// CS52 and MB8_32B_CS_H
/// CS52: CS52 and MB52_8B_CS
/// CS52: CS52 and MB4_64B_WORD6_H
/// CS52: CS52 and MB13_16B_WORD0_H
/// CS52: Message Buffer 52 CS Register
/// MB13_16B_WORD0_H: Message Buffer 13 WORD_16B Register
/// MB4_64B_WORD6_H: Message Buffer 4 WORD_64B Register
/// MB52_8B_CS: Message Buffer 52 CS Register
/// MB8_32B_CS_H: Message Buffer 8 CS Register
pub mod CS52 {
    pub use super::CS20::BRS;
    pub use super::CS20::CODE;
    pub use super::CS20::DATA_BYTE_0;
    pub use super::CS20::DATA_BYTE_1;
    pub use super::CS20::DATA_BYTE_2;
    pub use super::CS20::DATA_BYTE_24;
    pub use super::CS20::DATA_BYTE_25;
    pub use super::CS20::DATA_BYTE_26;
    pub use super::CS20::DATA_BYTE_27;
    pub use super::CS20::DATA_BYTE_3;
    pub use super::CS20::DLC;
    pub use super::CS20::EDL;
    pub use super::CS20::ESI;
    pub use super::CS20::IDE;
    pub use super::CS20::RTR;
    pub use super::CS20::SRR;
    pub use super::CS20::TIME_STAMP;
}

/// ID52 and MB8_32B_ID_H
/// ID52: ID52 and MB52_8B_ID
/// ID52: ID52 and MB4_64B_WORD7_H
/// ID52: ID52 and MB13_16B_WORD1_H
/// ID52: Message Buffer 52 ID Register
/// MB13_16B_WORD1_H: Message Buffer 13 WORD_16B Register
/// MB4_64B_WORD7_H: Message Buffer 4 WORD_64B Register
/// MB52_8B_ID: Message Buffer 52 ID Register
/// MB8_32B_ID_H: Message Buffer 8 ID Register
pub mod ID52 {
    pub use super::ID20::DATA_BYTE_28;
    pub use super::ID20::DATA_BYTE_29;
    pub use super::ID20::DATA_BYTE_30;
    pub use super::ID20::DATA_BYTE_31;
    pub use super::ID20::DATA_BYTE_4;
    pub use super::ID20::DATA_BYTE_5;
    pub use super::ID20::DATA_BYTE_6;
    pub use super::ID20::DATA_BYTE_7;
    pub use super::ID20::EXT;
    pub use super::ID20::PRIO;
    pub use super::ID20::STD;
}

/// MB13_16B_WORD2_H and WORD052
/// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB8_32B_WORD0_H
/// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB52_8B_WORD0
/// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB4_64B_WORD8_H
/// MB13_16B_WORD2_H: Message Buffer 13 WORD_16B Register
/// MB4_64B_WORD8_H: Message Buffer 4 WORD_64B Register
/// MB52_8B_WORD0: Message Buffer 52 WORD_8B Register
/// MB8_32B_WORD0_H: Message Buffer 8 WORD_32B Register
/// WORD052: Message Buffer 52 WORD0 Register
pub mod MB13_16B_WORD2_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_WORD3_H and WORD152
/// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB8_32B_WORD1_H
/// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB52_8B_WORD1
/// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB4_64B_WORD9_H
/// MB13_16B_WORD3_H: Message Buffer 13 WORD_16B Register
/// MB4_64B_WORD9_H: Message Buffer 4 WORD_64B Register
/// MB52_8B_WORD1: Message Buffer 52 WORD_8B Register
/// MB8_32B_WORD1_H: Message Buffer 8 WORD_32B Register
/// WORD152: Message Buffer 52 WORD1 Register
pub mod MB13_16B_WORD3_H {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS53 and MB8_32B_WORD2_H
/// CS53: CS53 and MB53_8B_CS
/// CS53: CS53 and MB4_64B_WORD10_H
/// CS53: CS53 and MB14_16B_CS_H
/// CS53: Message Buffer 53 CS Register
/// MB14_16B_CS_H: Message Buffer 14 CS Register
/// MB4_64B_WORD10_H: Message Buffer 4 WORD_64B Register
/// MB53_8B_CS: Message Buffer 53 CS Register
/// MB8_32B_WORD2_H: Message Buffer 8 WORD_32B Register
pub mod CS53 {
    pub use super::CS21::BRS;
    pub use super::CS21::CODE;
    pub use super::CS21::DATA_BYTE_10;
    pub use super::CS21::DATA_BYTE_11;
    pub use super::CS21::DATA_BYTE_40;
    pub use super::CS21::DATA_BYTE_41;
    pub use super::CS21::DATA_BYTE_42;
    pub use super::CS21::DATA_BYTE_43;
    pub use super::CS21::DATA_BYTE_8;
    pub use super::CS21::DATA_BYTE_9;
    pub use super::CS21::DLC;
    pub use super::CS21::EDL;
    pub use super::CS21::ESI;
    pub use super::CS21::IDE;
    pub use super::CS21::RTR;
    pub use super::CS21::SRR;
    pub use super::CS21::TIME_STAMP;
}

/// ID53 and MB8_32B_WORD3_H
/// ID53: ID53 and MB53_8B_ID
/// ID53: ID53 and MB4_64B_WORD11_H
/// ID53: ID53 and MB14_16B_ID_H
/// ID53: Message Buffer 53 ID Register
/// MB14_16B_ID_H: Message Buffer 14 ID Register
/// MB4_64B_WORD11_H: Message Buffer 4 WORD_64B Register
/// MB53_8B_ID: Message Buffer 53 ID Register
/// MB8_32B_WORD3_H: Message Buffer 8 WORD_32B Register
pub mod ID53 {
    pub use super::ID21::DATA_BYTE_12;
    pub use super::ID21::DATA_BYTE_13;
    pub use super::ID21::DATA_BYTE_14;
    pub use super::ID21::DATA_BYTE_15;
    pub use super::ID21::DATA_BYTE_44;
    pub use super::ID21::DATA_BYTE_45;
    pub use super::ID21::DATA_BYTE_46;
    pub use super::ID21::DATA_BYTE_47;
    pub use super::ID21::EXT;
    pub use super::ID21::PRIO;
    pub use super::ID21::STD;
}

/// MB14_16B_WORD0_H and WORD053
/// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB8_32B_WORD4_H
/// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB53_8B_WORD0
/// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB4_64B_WORD12_H
/// MB14_16B_WORD0_H: Message Buffer 14 WORD_16B Register
/// MB4_64B_WORD12_H: Message Buffer 4 WORD_64B Register
/// MB53_8B_WORD0: Message Buffer 53 WORD_8B Register
/// MB8_32B_WORD4_H: Message Buffer 8 WORD_32B Register
/// WORD053: Message Buffer 53 WORD0 Register
pub mod MB14_16B_WORD0_H {
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_0;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_1;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_16;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_17;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_18;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_19;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_2;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_3;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_48;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_49;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_50;
    pub use super::MB14_16B_WORD0_L::DATA_BYTE_51;
}

/// MB14_16B_WORD1_H and WORD153
/// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB8_32B_WORD5_H
/// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB53_8B_WORD1
/// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB4_64B_WORD13_H
/// MB14_16B_WORD1_H: Message Buffer 14 WORD_16B Register
/// MB4_64B_WORD13_H: Message Buffer 4 WORD_64B Register
/// MB53_8B_WORD1: Message Buffer 53 WORD_8B Register
/// MB8_32B_WORD5_H: Message Buffer 8 WORD_32B Register
/// WORD153: Message Buffer 53 WORD1 Register
pub mod MB14_16B_WORD1_H {
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_20;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_21;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_22;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_23;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_52;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_53;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_54;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_55;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB14_16B_WORD1_L::DATA_BYTE_7;
}

/// CS54 and MB8_32B_WORD6_H
/// CS54: CS54 and MB54_8B_CS
/// CS54: CS54 and MB4_64B_WORD14_H
/// CS54: CS54 and MB14_16B_WORD2_H
/// CS54: Message Buffer 54 CS Register
/// MB14_16B_WORD2_H: Message Buffer 14 WORD_16B Register
/// MB4_64B_WORD14_H: Message Buffer 4 WORD_64B Register
/// MB54_8B_CS: Message Buffer 54 CS Register
/// MB8_32B_WORD6_H: Message Buffer 8 WORD_32B Register
pub mod CS54 {
    pub use super::CS22::BRS;
    pub use super::CS22::CODE;
    pub use super::CS22::DATA_BYTE_10;
    pub use super::CS22::DATA_BYTE_11;
    pub use super::CS22::DATA_BYTE_24;
    pub use super::CS22::DATA_BYTE_25;
    pub use super::CS22::DATA_BYTE_26;
    pub use super::CS22::DATA_BYTE_27;
    pub use super::CS22::DATA_BYTE_56;
    pub use super::CS22::DATA_BYTE_57;
    pub use super::CS22::DATA_BYTE_58;
    pub use super::CS22::DATA_BYTE_59;
    pub use super::CS22::DATA_BYTE_8;
    pub use super::CS22::DATA_BYTE_9;
    pub use super::CS22::DLC;
    pub use super::CS22::EDL;
    pub use super::CS22::ESI;
    pub use super::CS22::IDE;
    pub use super::CS22::RTR;
    pub use super::CS22::SRR;
    pub use super::CS22::TIME_STAMP;
}

/// ID54 and MB8_32B_WORD7_H
/// ID54: ID54 and MB54_8B_ID
/// ID54: ID54 and MB4_64B_WORD15_H
/// ID54: ID54 and MB14_16B_WORD3_H
/// ID54: Message Buffer 54 ID Register
/// MB14_16B_WORD3_H: Message Buffer 14 WORD_16B Register
/// MB4_64B_WORD15_H: Message Buffer 4 WORD_64B Register
/// MB54_8B_ID: Message Buffer 54 ID Register
/// MB8_32B_WORD7_H: Message Buffer 8 WORD_32B Register
pub mod ID54 {
    pub use super::ID22::DATA_BYTE_12;
    pub use super::ID22::DATA_BYTE_13;
    pub use super::ID22::DATA_BYTE_14;
    pub use super::ID22::DATA_BYTE_15;
    pub use super::ID22::DATA_BYTE_28;
    pub use super::ID22::DATA_BYTE_29;
    pub use super::ID22::DATA_BYTE_30;
    pub use super::ID22::DATA_BYTE_31;
    pub use super::ID22::DATA_BYTE_60;
    pub use super::ID22::DATA_BYTE_61;
    pub use super::ID22::DATA_BYTE_62;
    pub use super::ID22::DATA_BYTE_63;
    pub use super::ID22::EXT;
    pub use super::ID22::PRIO;
    pub use super::ID22::STD;
}

/// MB15_16B_CS_H and WORD054
/// MB15_16B_CS_H: MB15_16B_CS_H and MB9_32B_CS_H
/// MB15_16B_CS_H: MB15_16B_CS_H and MB5_64B_CS_H
/// MB15_16B_CS_H: MB15_16B_CS_H and MB54_8B_WORD0
/// MB15_16B_CS_H: Message Buffer 15 CS Register
/// MB54_8B_WORD0: Message Buffer 54 WORD_8B Register
/// MB5_64B_CS_H: Message Buffer 5 CS Register
/// MB9_32B_CS_H: Message Buffer 9 CS Register
/// WORD054: Message Buffer 54 WORD0 Register
pub mod MB15_16B_CS_H {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB15_16B_ID_H and WORD154
/// MB15_16B_ID_H: MB15_16B_ID_H and MB9_32B_ID_H
/// MB15_16B_ID_H: MB15_16B_ID_H and MB5_64B_ID_H
/// MB15_16B_ID_H: MB15_16B_ID_H and MB54_8B_WORD1
/// MB15_16B_ID_H: Message Buffer 15 ID Register
/// MB54_8B_WORD1: Message Buffer 54 WORD_8B Register
/// MB5_64B_ID_H: Message Buffer 5 ID Register
/// MB9_32B_ID_H: Message Buffer 9 ID Register
/// WORD154: Message Buffer 54 WORD1 Register
pub mod MB15_16B_ID_H {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS55 and MB9_32B_WORD0_H
/// CS55: CS55 and MB5_64B_WORD0_H
/// CS55: CS55 and MB55_8B_CS
/// CS55: CS55 and MB15_16B_WORD0_H
/// CS55: Message Buffer 55 CS Register
/// MB15_16B_WORD0_H: Message Buffer 15 WORD_16B Register
/// MB55_8B_CS: Message Buffer 55 CS Register
/// MB5_64B_WORD0_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD0_H: Message Buffer 9 WORD_32B Register
pub mod CS55 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID55 and MB9_32B_WORD1_H
/// ID55: ID55 and MB5_64B_WORD1_H
/// ID55: ID55 and MB55_8B_ID
/// ID55: ID55 and MB15_16B_WORD1_H
/// ID55: Message Buffer 55 ID Register
/// MB15_16B_WORD1_H: Message Buffer 15 WORD_16B Register
/// MB55_8B_ID: Message Buffer 55 ID Register
/// MB5_64B_WORD1_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD1_H: Message Buffer 9 WORD_32B Register
pub mod ID55 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB15_16B_WORD2_H and WORD055
/// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB9_32B_WORD2_H
/// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB5_64B_WORD2_H
/// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB55_8B_WORD0
/// MB15_16B_WORD2_H: Message Buffer 15 WORD_16B Register
/// MB55_8B_WORD0: Message Buffer 55 WORD_8B Register
/// MB5_64B_WORD2_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD2_H: Message Buffer 9 WORD_32B Register
/// WORD055: Message Buffer 55 WORD0 Register
pub mod MB15_16B_WORD2_H {
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_0;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_1;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_10;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_11;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_2;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_3;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_8;
    pub use super::MB1_64B_WORD2_L::DATA_BYTE_9;
}

/// MB15_16B_WORD3_H and WORD155
/// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB9_32B_WORD3_H
/// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB5_64B_WORD3_H
/// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB55_8B_WORD1
/// MB15_16B_WORD3_H: Message Buffer 15 WORD_16B Register
/// MB55_8B_WORD1: Message Buffer 55 WORD_8B Register
/// MB5_64B_WORD3_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD3_H: Message Buffer 9 WORD_32B Register
/// WORD155: Message Buffer 55 WORD1 Register
pub mod MB15_16B_WORD3_H {
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_12;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_13;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_14;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_15;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_4;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_5;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_6;
    pub use super::MB1_64B_WORD3_L::DATA_BYTE_7;
}

/// CS56 and MB9_32B_WORD4_H
/// CS56: CS56 and MB5_64B_WORD4_H
/// CS56: CS56 and MB56_8B_CS
/// CS56: CS56 and MB16_16B_CS_H
/// CS56: Message Buffer 56 CS Register
/// MB16_16B_CS_H: Message Buffer 16 CS Register
/// MB56_8B_CS: Message Buffer 56 CS Register
/// MB5_64B_WORD4_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD4_H: Message Buffer 9 WORD_32B Register
pub mod CS56 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID56 and MB9_32B_WORD5_H
/// ID56: ID56 and MB5_64B_WORD5_H
/// ID56: ID56 and MB56_8B_ID
/// ID56: ID56 and MB16_16B_ID_H
/// ID56: Message Buffer 56 ID Register
/// MB16_16B_ID_H: Message Buffer 16 ID Register
/// MB56_8B_ID: Message Buffer 56 ID Register
/// MB5_64B_WORD5_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD5_H: Message Buffer 9 WORD_32B Register
pub mod ID56 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB16_16B_WORD0_H and WORD056
/// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB9_32B_WORD6_H
/// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB5_64B_WORD6_H
/// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB56_8B_WORD0
/// MB16_16B_WORD0_H: Message Buffer 16 WORD_16B Register
/// MB56_8B_WORD0: Message Buffer 56 WORD_8B Register
/// MB5_64B_WORD6_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD6_H: Message Buffer 9 WORD_32B Register
/// WORD056: Message Buffer 56 WORD0 Register
pub mod MB16_16B_WORD0_H {
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0_L::DATA_BYTE_3;
}

/// MB16_16B_WORD1_H and WORD156
/// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB9_32B_WORD7_H
/// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB5_64B_WORD7_H
/// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB56_8B_WORD1
/// MB16_16B_WORD1_H: Message Buffer 16 WORD_16B Register
/// MB56_8B_WORD1: Message Buffer 56 WORD_8B Register
/// MB5_64B_WORD7_H: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD7_H: Message Buffer 9 WORD_32B Register
/// WORD156: Message Buffer 56 WORD1 Register
pub mod MB16_16B_WORD1_H {
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1_L::DATA_BYTE_7;
}

/// CS57 and MB5_64B_WORD8_H
/// CS57: CS57 and MB57_8B_CS
/// CS57: CS57 and MB16_16B_WORD2_H
/// CS57: CS57 and MB10_32B_CS_H
/// CS57: Message Buffer 57 CS Register
/// MB10_32B_CS_H: Message Buffer 10 CS Register
/// MB16_16B_WORD2_H: Message Buffer 16 WORD_16B Register
/// MB57_8B_CS: Message Buffer 57 CS Register
/// MB5_64B_WORD8_H: Message Buffer 5 WORD_64B Register
pub mod CS57 {
    pub use super::CS16::BRS;
    pub use super::CS16::CODE;
    pub use super::CS16::DATA_BYTE_10;
    pub use super::CS16::DATA_BYTE_11;
    pub use super::CS16::DATA_BYTE_32;
    pub use super::CS16::DATA_BYTE_33;
    pub use super::CS16::DATA_BYTE_34;
    pub use super::CS16::DATA_BYTE_35;
    pub use super::CS16::DATA_BYTE_8;
    pub use super::CS16::DATA_BYTE_9;
    pub use super::CS16::DLC;
    pub use super::CS16::EDL;
    pub use super::CS16::ESI;
    pub use super::CS16::IDE;
    pub use super::CS16::RTR;
    pub use super::CS16::SRR;
    pub use super::CS16::TIME_STAMP;
}

/// ID57 and MB5_64B_WORD9_H
/// ID57: ID57 and MB57_8B_ID
/// ID57: ID57 and MB16_16B_WORD3_H
/// ID57: ID57 and MB10_32B_ID_H
/// ID57: Message Buffer 57 ID Register
/// MB10_32B_ID_H: Message Buffer 10 ID Register
/// MB16_16B_WORD3_H: Message Buffer 16 WORD_16B Register
/// MB57_8B_ID: Message Buffer 57 ID Register
/// MB5_64B_WORD9_H: Message Buffer 5 WORD_64B Register
pub mod ID57 {
    pub use super::ID16::DATA_BYTE_12;
    pub use super::ID16::DATA_BYTE_13;
    pub use super::ID16::DATA_BYTE_14;
    pub use super::ID16::DATA_BYTE_15;
    pub use super::ID16::DATA_BYTE_36;
    pub use super::ID16::DATA_BYTE_37;
    pub use super::ID16::DATA_BYTE_38;
    pub use super::ID16::DATA_BYTE_39;
    pub use super::ID16::EXT;
    pub use super::ID16::PRIO;
    pub use super::ID16::STD;
}

/// MB10_32B_WORD0_H and WORD057
/// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB5_64B_WORD10_H
/// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB57_8B_WORD0
/// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB17_16B_CS_H
/// MB10_32B_WORD0_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_CS_H: Message Buffer 17 CS Register
/// MB57_8B_WORD0: Message Buffer 57 WORD_8B Register
/// MB5_64B_WORD10_H: Message Buffer 5 WORD_64B Register
/// WORD057: Message Buffer 57 WORD0 Register
pub mod MB10_32B_WORD0_H {
    pub use super::MB10_32B_WORD0_L::BRS;
    pub use super::MB10_32B_WORD0_L::CODE;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_0;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_1;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_2;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_3;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_40;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_41;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_42;
    pub use super::MB10_32B_WORD0_L::DATA_BYTE_43;
    pub use super::MB10_32B_WORD0_L::DLC;
    pub use super::MB10_32B_WORD0_L::EDL;
    pub use super::MB10_32B_WORD0_L::ESI;
    pub use super::MB10_32B_WORD0_L::IDE;
    pub use super::MB10_32B_WORD0_L::RTR;
    pub use super::MB10_32B_WORD0_L::SRR;
    pub use super::MB10_32B_WORD0_L::TIME_STAMP;
}

/// MB10_32B_WORD1_H and WORD157
/// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB5_64B_WORD11_H
/// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB57_8B_WORD1
/// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB17_16B_ID_H
/// MB10_32B_WORD1_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_ID_H: Message Buffer 17 ID Register
/// MB57_8B_WORD1: Message Buffer 57 WORD_8B Register
/// MB5_64B_WORD11_H: Message Buffer 5 WORD_64B Register
/// WORD157: Message Buffer 57 WORD1 Register
pub mod MB10_32B_WORD1_H {
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_4;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_44;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_45;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_46;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_47;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_5;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_6;
    pub use super::MB10_32B_WORD1_L::DATA_BYTE_7;
    pub use super::MB10_32B_WORD1_L::EXT;
    pub use super::MB10_32B_WORD1_L::PRIO;
    pub use super::MB10_32B_WORD1_L::STD;
}

/// CS58 and MB5_64B_WORD12_H
/// CS58: CS58 and MB58_8B_CS
/// CS58: CS58 and MB17_16B_WORD0_H
/// CS58: CS58 and MB10_32B_WORD2_H
/// CS58: Message Buffer 58 CS Register
/// MB10_32B_WORD2_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD0_H: Message Buffer 17 WORD_16B Register
/// MB58_8B_CS: Message Buffer 58 CS Register
/// MB5_64B_WORD12_H: Message Buffer 5 WORD_64B Register
pub mod CS58 {
    pub use super::CS26::BRS;
    pub use super::CS26::CODE;
    pub use super::CS26::DATA_BYTE_0;
    pub use super::CS26::DATA_BYTE_1;
    pub use super::CS26::DATA_BYTE_10;
    pub use super::CS26::DATA_BYTE_11;
    pub use super::CS26::DATA_BYTE_2;
    pub use super::CS26::DATA_BYTE_3;
    pub use super::CS26::DATA_BYTE_48;
    pub use super::CS26::DATA_BYTE_49;
    pub use super::CS26::DATA_BYTE_50;
    pub use super::CS26::DATA_BYTE_51;
    pub use super::CS26::DATA_BYTE_8;
    pub use super::CS26::DATA_BYTE_9;
    pub use super::CS26::DLC;
    pub use super::CS26::EDL;
    pub use super::CS26::ESI;
    pub use super::CS26::IDE;
    pub use super::CS26::RTR;
    pub use super::CS26::SRR;
    pub use super::CS26::TIME_STAMP;
}

/// ID58 and MB5_64B_WORD13_H
/// ID58: ID58 and MB58_8B_ID
/// ID58: ID58 and MB17_16B_WORD1_H
/// ID58: ID58 and MB10_32B_WORD3_H
/// ID58: Message Buffer 58 ID Register
/// MB10_32B_WORD3_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD1_H: Message Buffer 17 WORD_16B Register
/// MB58_8B_ID: Message Buffer 58 ID Register
/// MB5_64B_WORD13_H: Message Buffer 5 WORD_64B Register
pub mod ID58 {
    pub use super::ID26::DATA_BYTE_12;
    pub use super::ID26::DATA_BYTE_13;
    pub use super::ID26::DATA_BYTE_14;
    pub use super::ID26::DATA_BYTE_15;
    pub use super::ID26::DATA_BYTE_4;
    pub use super::ID26::DATA_BYTE_5;
    pub use super::ID26::DATA_BYTE_52;
    pub use super::ID26::DATA_BYTE_53;
    pub use super::ID26::DATA_BYTE_54;
    pub use super::ID26::DATA_BYTE_55;
    pub use super::ID26::DATA_BYTE_6;
    pub use super::ID26::DATA_BYTE_7;
    pub use super::ID26::EXT;
    pub use super::ID26::PRIO;
    pub use super::ID26::STD;
}

/// MB10_32B_WORD4_H and WORD058
/// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB5_64B_WORD14_H
/// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB58_8B_WORD0
/// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB17_16B_WORD2_H
/// MB10_32B_WORD4_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD2_H: Message Buffer 17 WORD_16B Register
/// MB58_8B_WORD0: Message Buffer 58 WORD_8B Register
/// MB5_64B_WORD14_H: Message Buffer 5 WORD_64B Register
/// WORD058: Message Buffer 58 WORD0 Register
pub mod MB10_32B_WORD4_H {
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_0;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_1;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_10;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_11;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_16;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_17;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_18;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_19;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_2;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_3;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_56;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_57;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_58;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_59;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_8;
    pub use super::MB10_32B_WORD4_L::DATA_BYTE_9;
}

/// MB10_32B_WORD5_H and WORD158
/// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB5_64B_WORD15_H
/// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB58_8B_WORD1
/// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB17_16B_WORD3_H
/// MB10_32B_WORD5_H: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD3_H: Message Buffer 17 WORD_16B Register
/// MB58_8B_WORD1: Message Buffer 58 WORD_8B Register
/// MB5_64B_WORD15_H: Message Buffer 5 WORD_64B Register
/// WORD158: Message Buffer 58 WORD1 Register
pub mod MB10_32B_WORD5_H {
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_12;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_13;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_14;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_15;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_20;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_21;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_22;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_23;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_4;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_5;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_6;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_60;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_61;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_62;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_63;
    pub use super::MB10_32B_WORD5_L::DATA_BYTE_7;
}

/// CS59 and MB6_64B_CS_H
/// CS59: CS59 and MB59_8B_CS
/// CS59: CS59 and MB18_16B_CS_H
/// CS59: CS59 and MB10_32B_WORD6_H
/// CS59: Message Buffer 59 CS Register
/// MB10_32B_WORD6_H: Message Buffer 10 WORD_32B Register
/// MB18_16B_CS_H: Message Buffer 18 CS Register
/// MB59_8B_CS: Message Buffer 59 CS Register
/// MB6_64B_CS_H: Message Buffer 6 CS Register
pub mod CS59 {
    pub use super::CS27::BRS;
    pub use super::CS27::CODE;
    pub use super::CS27::DATA_BYTE_24;
    pub use super::CS27::DATA_BYTE_25;
    pub use super::CS27::DATA_BYTE_26;
    pub use super::CS27::DATA_BYTE_27;
    pub use super::CS27::DLC;
    pub use super::CS27::EDL;
    pub use super::CS27::ESI;
    pub use super::CS27::IDE;
    pub use super::CS27::RTR;
    pub use super::CS27::SRR;
    pub use super::CS27::TIME_STAMP;
}

/// ID59 and MB6_64B_ID_H
/// ID59: ID59 and MB59_8B_ID
/// ID59: ID59 and MB18_16B_ID_H
/// ID59: ID59 and MB10_32B_WORD7_H
/// ID59: Message Buffer 59 ID Register
/// MB10_32B_WORD7_H: Message Buffer 10 WORD_32B Register
/// MB18_16B_ID_H: Message Buffer 18 ID Register
/// MB59_8B_ID: Message Buffer 59 ID Register
/// MB6_64B_ID_H: Message Buffer 6 ID Register
pub mod ID59 {
    pub use super::ID27::DATA_BYTE_28;
    pub use super::ID27::DATA_BYTE_29;
    pub use super::ID27::DATA_BYTE_30;
    pub use super::ID27::DATA_BYTE_31;
    pub use super::ID27::EXT;
    pub use super::ID27::PRIO;
    pub use super::ID27::STD;
}

/// MB11_32B_CS_H and WORD059
/// MB11_32B_CS_H: MB11_32B_CS_H and MB6_64B_WORD0_H
/// MB11_32B_CS_H: MB11_32B_CS_H and MB59_8B_WORD0
/// MB11_32B_CS_H: MB11_32B_CS_H and MB18_16B_WORD0_H
/// MB11_32B_CS_H: Message Buffer 11 CS Register
/// MB18_16B_WORD0_H: Message Buffer 18 WORD_16B Register
/// MB59_8B_WORD0: Message Buffer 59 WORD_8B Register
/// MB6_64B_WORD0_H: Message Buffer 6 WORD_64B Register
/// WORD059: Message Buffer 59 WORD0 Register
pub mod MB11_32B_CS_H {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB11_32B_ID_H and WORD159
/// MB11_32B_ID_H: MB11_32B_ID_H and MB6_64B_WORD1_H
/// MB11_32B_ID_H: MB11_32B_ID_H and MB59_8B_WORD1
/// MB11_32B_ID_H: MB11_32B_ID_H and MB18_16B_WORD1_H
/// MB11_32B_ID_H: Message Buffer 11 ID Register
/// MB18_16B_WORD1_H: Message Buffer 18 WORD_16B Register
/// MB59_8B_WORD1: Message Buffer 59 WORD_8B Register
/// MB6_64B_WORD1_H: Message Buffer 6 WORD_64B Register
/// WORD159: Message Buffer 59 WORD1 Register
pub mod MB11_32B_ID_H {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS60 and MB6_64B_WORD2_H
/// CS60: CS60 and MB60_8B_CS
/// CS60: CS60 and MB18_16B_WORD2_H
/// CS60: CS60 and MB11_32B_WORD0_H
/// CS60: Message Buffer 60 CS Register
/// MB11_32B_WORD0_H: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD2_H: Message Buffer 18 WORD_16B Register
/// MB60_8B_CS: Message Buffer 60 CS Register
/// MB6_64B_WORD2_H: Message Buffer 6 WORD_64B Register
pub mod CS60 {
    pub use super::CS28::BRS;
    pub use super::CS28::CODE;
    pub use super::CS28::DATA_BYTE_0;
    pub use super::CS28::DATA_BYTE_1;
    pub use super::CS28::DATA_BYTE_10;
    pub use super::CS28::DATA_BYTE_11;
    pub use super::CS28::DATA_BYTE_2;
    pub use super::CS28::DATA_BYTE_3;
    pub use super::CS28::DATA_BYTE_8;
    pub use super::CS28::DATA_BYTE_9;
    pub use super::CS28::DLC;
    pub use super::CS28::EDL;
    pub use super::CS28::ESI;
    pub use super::CS28::IDE;
    pub use super::CS28::RTR;
    pub use super::CS28::SRR;
    pub use super::CS28::TIME_STAMP;
}

/// ID60 and MB6_64B_WORD3_H
/// ID60: ID60 and MB60_8B_ID
/// ID60: ID60 and MB18_16B_WORD3_H
/// ID60: ID60 and MB11_32B_WORD1_H
/// ID60: Message Buffer 60 ID Register
/// MB11_32B_WORD1_H: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD3_H: Message Buffer 18 WORD_16B Register
/// MB60_8B_ID: Message Buffer 60 ID Register
/// MB6_64B_WORD3_H: Message Buffer 6 WORD_64B Register
pub mod ID60 {
    pub use super::ID28::DATA_BYTE_12;
    pub use super::ID28::DATA_BYTE_13;
    pub use super::ID28::DATA_BYTE_14;
    pub use super::ID28::DATA_BYTE_15;
    pub use super::ID28::DATA_BYTE_4;
    pub use super::ID28::DATA_BYTE_5;
    pub use super::ID28::DATA_BYTE_6;
    pub use super::ID28::DATA_BYTE_7;
    pub use super::ID28::EXT;
    pub use super::ID28::PRIO;
    pub use super::ID28::STD;
}

/// MB11_32B_WORD2_H and WORD060
/// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB6_64B_WORD4_H
/// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB60_8B_WORD0
/// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB19_16B_CS_H
/// MB11_32B_WORD2_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_CS_H: Message Buffer 19 CS Register
/// MB60_8B_WORD0: Message Buffer 60 WORD_8B Register
/// MB6_64B_WORD4_H: Message Buffer 6 WORD_64B Register
/// WORD060: Message Buffer 60 WORD0 Register
pub mod MB11_32B_WORD2_H {
    pub use super::MB11_32B_WORD2_L::BRS;
    pub use super::MB11_32B_WORD2_L::CODE;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_0;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_1;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_10;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_11;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_16;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_17;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_18;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_19;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_2;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_3;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_8;
    pub use super::MB11_32B_WORD2_L::DATA_BYTE_9;
    pub use super::MB11_32B_WORD2_L::DLC;
    pub use super::MB11_32B_WORD2_L::EDL;
    pub use super::MB11_32B_WORD2_L::ESI;
    pub use super::MB11_32B_WORD2_L::IDE;
    pub use super::MB11_32B_WORD2_L::RTR;
    pub use super::MB11_32B_WORD2_L::SRR;
    pub use super::MB11_32B_WORD2_L::TIME_STAMP;
}

/// MB11_32B_WORD3_H and WORD160
/// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB6_64B_WORD5_H
/// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB60_8B_WORD1
/// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB19_16B_ID_H
/// MB11_32B_WORD3_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_ID_H: Message Buffer 19 ID Register
/// MB60_8B_WORD1: Message Buffer 60 WORD_8B Register
/// MB6_64B_WORD5_H: Message Buffer 6 WORD_64B Register
/// WORD160: Message Buffer 60 WORD1 Register
pub mod MB11_32B_WORD3_H {
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_12;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_13;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_14;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_15;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_20;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_21;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_22;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_23;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_4;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_5;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_6;
    pub use super::MB11_32B_WORD3_L::DATA_BYTE_7;
    pub use super::MB11_32B_WORD3_L::EXT;
    pub use super::MB11_32B_WORD3_L::PRIO;
    pub use super::MB11_32B_WORD3_L::STD;
}

/// CS61 and MB6_64B_WORD6_H
/// CS61: CS61 and MB61_8B_CS
/// CS61: CS61 and MB19_16B_WORD0_H
/// CS61: CS61 and MB11_32B_WORD4_H
/// CS61: Message Buffer 61 CS Register
/// MB11_32B_WORD4_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD0_H: Message Buffer 19 WORD_16B Register
/// MB61_8B_CS: Message Buffer 61 CS Register
/// MB6_64B_WORD6_H: Message Buffer 6 WORD_64B Register
pub mod CS61 {
    pub use super::CS29::BRS;
    pub use super::CS29::CODE;
    pub use super::CS29::DATA_BYTE_0;
    pub use super::CS29::DATA_BYTE_1;
    pub use super::CS29::DATA_BYTE_16;
    pub use super::CS29::DATA_BYTE_17;
    pub use super::CS29::DATA_BYTE_18;
    pub use super::CS29::DATA_BYTE_19;
    pub use super::CS29::DATA_BYTE_2;
    pub use super::CS29::DATA_BYTE_24;
    pub use super::CS29::DATA_BYTE_25;
    pub use super::CS29::DATA_BYTE_26;
    pub use super::CS29::DATA_BYTE_27;
    pub use super::CS29::DATA_BYTE_3;
    pub use super::CS29::DLC;
    pub use super::CS29::EDL;
    pub use super::CS29::ESI;
    pub use super::CS29::IDE;
    pub use super::CS29::RTR;
    pub use super::CS29::SRR;
    pub use super::CS29::TIME_STAMP;
}

/// ID61 and MB6_64B_WORD7_H
/// ID61: ID61 and MB61_8B_ID
/// ID61: ID61 and MB19_16B_WORD1_H
/// ID61: ID61 and MB11_32B_WORD5_H
/// ID61: Message Buffer 61 ID Register
/// MB11_32B_WORD5_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD1_H: Message Buffer 19 WORD_16B Register
/// MB61_8B_ID: Message Buffer 61 ID Register
/// MB6_64B_WORD7_H: Message Buffer 6 WORD_64B Register
pub mod ID61 {
    pub use super::ID29::DATA_BYTE_20;
    pub use super::ID29::DATA_BYTE_21;
    pub use super::ID29::DATA_BYTE_22;
    pub use super::ID29::DATA_BYTE_23;
    pub use super::ID29::DATA_BYTE_28;
    pub use super::ID29::DATA_BYTE_29;
    pub use super::ID29::DATA_BYTE_30;
    pub use super::ID29::DATA_BYTE_31;
    pub use super::ID29::DATA_BYTE_4;
    pub use super::ID29::DATA_BYTE_5;
    pub use super::ID29::DATA_BYTE_6;
    pub use super::ID29::DATA_BYTE_7;
    pub use super::ID29::EXT;
    pub use super::ID29::PRIO;
    pub use super::ID29::STD;
}

/// MB11_32B_WORD6_H and WORD061
/// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB6_64B_WORD8_H
/// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB61_8B_WORD0
/// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB19_16B_WORD2_H
/// MB11_32B_WORD6_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD2_H: Message Buffer 19 WORD_16B Register
/// MB61_8B_WORD0: Message Buffer 61 WORD_8B Register
/// MB6_64B_WORD8_H: Message Buffer 6 WORD_64B Register
/// WORD061: Message Buffer 61 WORD0 Register
pub mod MB11_32B_WORD6_H {
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_0;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_1;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_10;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_11;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_2;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_24;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_25;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_26;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_27;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_3;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_32;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_33;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_34;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_35;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_8;
    pub use super::MB11_32B_WORD6_L::DATA_BYTE_9;
}

/// MB11_32B_WORD7_H and WORD161
/// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB6_64B_WORD9_H
/// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB61_8B_WORD1
/// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB19_16B_WORD3_H
/// MB11_32B_WORD7_H: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD3_H: Message Buffer 19 WORD_16B Register
/// MB61_8B_WORD1: Message Buffer 61 WORD_8B Register
/// MB6_64B_WORD9_H: Message Buffer 6 WORD_64B Register
/// WORD161: Message Buffer 61 WORD1 Register
pub mod MB11_32B_WORD7_H {
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_12;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_13;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_14;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_15;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_28;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_29;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_30;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_31;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_36;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_37;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_38;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_39;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_4;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_5;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_6;
    pub use super::MB11_32B_WORD7_L::DATA_BYTE_7;
}

/// CS62 and MB6_64B_WORD10_H
/// CS62: CS62 and MB62_8B_CS
/// CS62: CS62 and MB20_16B_CS_H
/// CS62: Message Buffer 62 CS Register
/// MB20_16B_CS_H: Message Buffer 20 CS Register
/// MB62_8B_CS: Message Buffer 62 CS Register
/// MB6_64B_WORD10_H: Message Buffer 6 WORD_64B Register
pub mod CS62 {
    pub use super::CS30::BRS;
    pub use super::CS30::CODE;
    pub use super::CS30::DATA_BYTE_40;
    pub use super::CS30::DATA_BYTE_41;
    pub use super::CS30::DATA_BYTE_42;
    pub use super::CS30::DATA_BYTE_43;
    pub use super::CS30::DLC;
    pub use super::CS30::EDL;
    pub use super::CS30::ESI;
    pub use super::CS30::IDE;
    pub use super::CS30::RTR;
    pub use super::CS30::SRR;
    pub use super::CS30::TIME_STAMP;
}

/// ID62 and MB6_64B_WORD11_H
/// ID62: ID62 and MB62_8B_ID
/// ID62: ID62 and MB20_16B_ID_H
/// ID62: Message Buffer 62 ID Register
/// MB20_16B_ID_H: Message Buffer 20 ID Register
/// MB62_8B_ID: Message Buffer 62 ID Register
/// MB6_64B_WORD11_H: Message Buffer 6 WORD_64B Register
pub mod ID62 {
    pub use super::ID30::DATA_BYTE_44;
    pub use super::ID30::DATA_BYTE_45;
    pub use super::ID30::DATA_BYTE_46;
    pub use super::ID30::DATA_BYTE_47;
    pub use super::ID30::EXT;
    pub use super::ID30::PRIO;
    pub use super::ID30::STD;
}

/// MB20_16B_WORD0_H and WORD062
/// MB20_16B_WORD0_H: MB20_16B_WORD0_H and MB6_64B_WORD12_H
/// MB20_16B_WORD0_H: MB20_16B_WORD0_H and MB62_8B_WORD0
/// MB20_16B_WORD0_H: Message Buffer 20 WORD_16B Register
/// MB62_8B_WORD0: Message Buffer 62 WORD_8B Register
/// MB6_64B_WORD12_H: Message Buffer 6 WORD_64B Register
/// WORD062: Message Buffer 62 WORD0 Register
pub mod MB20_16B_WORD0_H {
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_0;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_1;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_2;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_3;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_48;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_49;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_50;
    pub use super::MB20_16B_WORD0_L::DATA_BYTE_51;
}

/// MB20_16B_WORD1_H and WORD162
/// MB20_16B_WORD1_H: MB20_16B_WORD1_H and MB6_64B_WORD13_H
/// MB20_16B_WORD1_H: MB20_16B_WORD1_H and MB62_8B_WORD1
/// MB20_16B_WORD1_H: Message Buffer 20 WORD_16B Register
/// MB62_8B_WORD1: Message Buffer 62 WORD_8B Register
/// MB6_64B_WORD13_H: Message Buffer 6 WORD_64B Register
/// WORD162: Message Buffer 62 WORD1 Register
pub mod MB20_16B_WORD1_H {
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_52;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_53;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_54;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_55;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB20_16B_WORD1_L::DATA_BYTE_7;
}

/// CS63 and MB6_64B_WORD14_H
/// CS63: CS63 and MB63_8B_CS
/// CS63: CS63 and MB20_16B_WORD2_H
/// CS63: Message Buffer 63 CS Register
/// MB20_16B_WORD2_H: Message Buffer 20 WORD_16B Register
/// MB63_8B_CS: Message Buffer 63 CS Register
/// MB6_64B_WORD14_H: Message Buffer 6 WORD_64B Register
pub mod CS63 {
    pub use super::CS31::BRS;
    pub use super::CS31::CODE;
    pub use super::CS31::DATA_BYTE_10;
    pub use super::CS31::DATA_BYTE_11;
    pub use super::CS31::DATA_BYTE_56;
    pub use super::CS31::DATA_BYTE_57;
    pub use super::CS31::DATA_BYTE_58;
    pub use super::CS31::DATA_BYTE_59;
    pub use super::CS31::DATA_BYTE_8;
    pub use super::CS31::DATA_BYTE_9;
    pub use super::CS31::DLC;
    pub use super::CS31::EDL;
    pub use super::CS31::ESI;
    pub use super::CS31::IDE;
    pub use super::CS31::RTR;
    pub use super::CS31::SRR;
    pub use super::CS31::TIME_STAMP;
}

/// ID63 and MB6_64B_WORD15_H
/// ID63: ID63 and MB63_8B_ID
/// ID63: ID63 and MB20_16B_WORD3_H
/// ID63: Message Buffer 63 ID Register
/// MB20_16B_WORD3_H: Message Buffer 20 WORD_16B Register
/// MB63_8B_ID: Message Buffer 63 ID Register
/// MB6_64B_WORD15_H: Message Buffer 6 WORD_64B Register
pub mod ID63 {
    pub use super::ID31::DATA_BYTE_12;
    pub use super::ID31::DATA_BYTE_13;
    pub use super::ID31::DATA_BYTE_14;
    pub use super::ID31::DATA_BYTE_15;
    pub use super::ID31::DATA_BYTE_60;
    pub use super::ID31::DATA_BYTE_61;
    pub use super::ID31::DATA_BYTE_62;
    pub use super::ID31::DATA_BYTE_63;
    pub use super::ID31::EXT;
    pub use super::ID31::PRIO;
    pub use super::ID31::STD;
}

/// MB63_8B_WORD0 and WORD063
/// MB63_8B_WORD0: Message Buffer 63 WORD_8B Register
/// WORD063: Message Buffer 63 WORD0 Register
pub mod MB63_8B_WORD0 {
    pub use super::MB0::DATA_BYTE_0;
    pub use super::MB0::DATA_BYTE_1;
    pub use super::MB0::DATA_BYTE_2;
    pub use super::MB0::DATA_BYTE_3;
}

/// MB63_8B_WORD1 and WORD163
/// MB63_8B_WORD1: Message Buffer 63 WORD_8B Register
/// WORD163: Message Buffer 63 WORD1 Register
pub mod MB63_8B_WORD1 {
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_4;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_5;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_6;
    pub use super::MB0_16B_WORD1_L::DATA_BYTE_7;
}

/// Rx Individual Mask registers
pub mod RXIMR0 {

    /// Individual Mask Bits
    pub mod MI {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx Individual Mask registers
pub mod RXIMR1 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR2 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR3 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR4 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR5 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR6 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR7 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR8 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR9 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR10 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR11 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR12 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR13 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR14 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR15 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR16 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR17 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR18 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR19 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR20 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR21 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR22 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR23 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR24 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR25 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR26 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR27 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR28 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR29 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR30 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR31 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR32 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR33 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR34 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR35 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR36 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR37 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR38 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR39 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR40 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR41 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR42 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR43 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR44 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR45 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR46 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR47 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR48 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR49 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR50 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR51 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR52 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR53 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR54 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR55 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR56 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR57 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR58 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR59 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR60 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR61 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR62 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask registers
pub mod RXIMR63 {
    pub use super::RXIMR0::MI;
}

/// Memory Error Control register
pub mod MECR {

    /// Non-Correctable Errors In FlexCAN Access Put Device In Freeze Mode
    pub mod NCEFAFRZ {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Keep normal operation.
            pub const normal: u32 = 0b0;

            /// 0b1: Put FlexCAN in Freeze mode (see section "Freeze mode").
            pub const freeze: u32 = 0b1;
        }
    }

    /// Error Correction Disable
    pub mod ECCDIS {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enable memory error correction.
            pub const ENABLE: u32 = 0b0;

            /// 0b1: Disable memory error correction.
            pub const DISABLE: u32 = 0b1;
        }
    }

    /// Error Report Disable
    pub mod RERRDIS {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enable updates of the error report registers.
            pub const ENABLE: u32 = 0b0;

            /// 0b1: Disable updates of the error report registers.
            pub const DISABLE: u32 = 0b1;
        }
    }

    /// Extended Error Injection Enable
    pub mod EXTERRIE {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Error injection is applied only to the 32-bit word.
            pub const inject_32_bit: u32 = 0b0;

            /// 0b1: Error injection is applied to the 64-bit word.
            pub const inject_64_bit: u32 = 0b1;
        }
    }

    /// FlexCAN Access Error Injection Enable
    pub mod FAERRIE {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Injection is disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Injection is enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Host Access Error Injection Enable
    pub mod HAERRIE {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::FAERRIE::RW;
    }

    /// Correctable Errors Interrupt Mask
    pub mod CEI_MSK {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Interrupt is disabled.
            pub const DISABLE: u32 = 0b0;

            /// 0b1: Interrupt is enabled.
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// FlexCAN Access With Non-Correctable Errors Interrupt Mask
    pub mod FANCEI_MSK {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::CEI_MSK::RW;
    }

    /// Host Access With Non-Correctable Errors Interrupt Mask
    pub mod HANCEI_MSK {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::CEI_MSK::RW;
    }

    /// Error Configuration Register Write Disable
    pub mod ECRWRDIS {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Write is enabled.
            pub const ENABLE: u32 = 0b0;

            /// 0b1: Write is disabled.
            pub const DISABLE: u32 = 0b1;
        }
    }
}

/// Error Injection Address register
pub mod ERRIAR {

    /// Error Injection Address Low
    pub mod INJADDR_L {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (2 bits: 0b11 << 0)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error Injection Address High
    pub mod INJADDR_H {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (12 bits: 0xfff << 2)
        pub const mask: u32 = 0xfff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Injection Data Pattern register
pub mod ERRIDPR {

    /// Data flip pattern
    pub mod DFLIP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Injection Parity Pattern register
pub mod ERRIPPR {

    /// Parity Flip Pattern For Byte 0 (Least Significant)
    pub mod PFLIP0 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Parity Flip Pattern For Byte 1
    pub mod PFLIP1 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (5 bits: 0b11111 << 8)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Parity Flip Pattern For Byte 2
    pub mod PFLIP2 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (5 bits: 0b11111 << 16)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Parity Flip Pattern For Byte 3 (most significant)
    pub mod PFLIP3 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (5 bits: 0b11111 << 24)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Report Address register
pub mod RERRAR {

    /// Address Where Error Detected
    pub mod ERRADDR {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (14 bits: 0x3fff << 0)
        pub const mask: u32 = 0x3fff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SAID
    pub mod SAID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (3 bits: 0b111 << 16)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Non-Correctable Error
    pub mod NCE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (1 bit: 1 << 24)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Reporting a correctable error
            pub const correctable: u32 = 0b0;

            /// 0b1: Reporting a non-correctable error
            pub const non_correctable: u32 = 0b1;
        }
    }
}

/// Error Report Data register
pub mod RERRDR {

    /// Raw data word read from memory with error
    pub mod RDATA {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Report Syndrome register
pub mod RERRSYNR {

    /// Error Syndrome For Byte 0 (least significant)
    pub mod SYND0 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Byte Enabled For Byte 0 (least significant)
    pub mod BE0 {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The byte was not read.
            pub const not_read: u32 = 0b0;

            /// 0b1: The byte was read.
            pub const read: u32 = 0b1;
        }
    }

    /// Error Syndrome for Byte 1
    pub mod SYND1 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (5 bits: 0b11111 << 8)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Byte Enabled For Byte 1
    pub mod BE1 {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::BE0::RW;
    }

    /// Error Syndrome For Byte 2
    pub mod SYND2 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (5 bits: 0b11111 << 16)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Byte Enabled For Byte 2
    pub mod BE2 {
        /// Offset (23 bits)
        pub const offset: u32 = 23;
        /// Mask (1 bit: 1 << 23)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::BE0::RW;
    }

    /// Error Syndrome For Byte 3 (most significant)
    pub mod SYND3 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (5 bits: 0b11111 << 24)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Byte Enabled For Byte 3 (most significant)
    pub mod BE3 {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        pub use super::BE0::RW;
    }
}

/// Error Status register
pub mod ERRSR {

    /// Correctable Error Interrupt Overrun Flag
    pub mod CEIOF {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No overrun on correctable errors
            pub const no_overrun: u32 = 0b0;

            /// 0b1: Overrun on correctable errors
            pub const overrun: u32 = 0b1;
        }
    }

    /// FlexCAN Access With Non-Correctable Error Interrupt Overrun Flag
    pub mod FANCEIOF {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No overrun on non-correctable errors in FlexCAN access
            pub const no_overrun: u32 = 0b0;

            /// 0b1: Overrun on non-correctable errors in FlexCAN access
            pub const overrun: u32 = 0b1;
        }
    }

    /// Host Access With Non-Correctable Error Interrupt Overrun Flag
    pub mod HANCEIOF {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No overrun on non-correctable errors in host access
            pub const no_overrun: u32 = 0b0;

            /// 0b1: Overrun on non-correctable errors in host access
            pub const overrun: u32 = 0b1;
        }
    }

    /// Correctable Error Interrupt Flag
    pub mod CEIF {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No correctable errors were detected so far.
            pub const no_errors: u32 = 0b0;

            /// 0b1: A correctable error was detected.
            pub const errors: u32 = 0b1;
        }
    }

    /// FlexCAN Access With Non-Correctable Error Interrupt Flag
    pub mod FANCEIF {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No non-correctable errors were detected in FlexCAN accesses so far.
            pub const not_found: u32 = 0b0;

            /// 0b1: A non-correctable error was detected in a FlexCAN access.
            pub const found: u32 = 0b1;
        }
    }

    /// Host Access With Non-Correctable Error Interrupt Flag
    pub mod HANCEIF {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No non-correctable errors were detected in host accesses so far.
            pub const not_found: u32 = 0b0;

            /// 0b1: A non-correctable error was detected in a host access.
            pub const found: u32 = 0b1;
        }
    }
}

/// CAN FD Control register
pub mod FDCTRL {

    /// Transceiver Delay Compensation Value
    pub mod TDCVAL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (6 bits: 0x3f << 0)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transceiver Delay Compensation Offset
    pub mod TDCOFF {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (5 bits: 0b11111 << 8)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transceiver Delay Compensation Fail
    pub mod TDCFAIL {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Measured loop delay is in range.
            pub const in_range: u32 = 0b0;

            /// 0b1: Measured loop delay is out of range.
            pub const out_of_range: u32 = 0b1;
        }
    }

    /// Transceiver Delay Compensation Enable
    pub mod TDCEN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: TDC is disabled
            pub const DISABLE: u32 = 0b0;

            /// 0b1: TDC is enabled
            pub const ENABLE: u32 = 0b1;
        }
    }

    /// Message Buffer Data Size for Region 0
    pub mod MBDSR0 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (2 bits: 0b11 << 16)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Selects 8 bytes per message buffer.
            pub const R0_8_bytes: u32 = 0b00;

            /// 0b01: Selects 16 bytes per message buffer.
            pub const R0_16_bytes: u32 = 0b01;

            /// 0b10: Selects 32 bytes per message buffer.
            pub const R0_32_bytes: u32 = 0b10;

            /// 0b11: Selects 64 bytes per message buffer.
            pub const R0_64_bytes: u32 = 0b11;
        }
    }

    /// Message Buffer Data Size for Region 1
    pub mod MBDSR1 {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (2 bits: 0b11 << 19)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Selects 8 bytes per message buffer.
            pub const R1_8_bytes: u32 = 0b00;

            /// 0b01: Selects 16 bytes per message buffer.
            pub const R1_16_bytes: u32 = 0b01;

            /// 0b10: Selects 32 bytes per message buffer.
            pub const R1_32_bytes: u32 = 0b10;

            /// 0b11: Selects 64 bytes per message buffer.
            pub const R1_64_bytes: u32 = 0b11;
        }
    }

    /// Bit Rate Switch Enable
    pub mod FDRATE {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Transmit a frame in nominal rate. The BRS bit in the Tx MB has no effect.
            pub const nominal: u32 = 0b0;

            /// 0b1: Transmit a frame with bit rate switching if the BRS bit in the Tx MB is recessive.
            pub const bit_rate_switching: u32 = 0b1;
        }
    }
}

/// CAN FD Bit Timing register
pub mod FDCBT {

    /// Fast Phase Segment 2
    pub mod FPSEG2 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (3 bits: 0b111 << 0)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Phase Segment 1
    pub mod FPSEG1 {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (3 bits: 0b111 << 5)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Propagation Segment
    pub mod FPROPSEG {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (5 bits: 0b11111 << 10)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Resync Jump Width
    pub mod FRJW {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (3 bits: 0b111 << 16)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Prescaler Division Factor
    pub mod FPRESDIV {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (10 bits: 0x3ff << 20)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CAN FD CRC register
pub mod FDCRC {

    /// Extended Transmitted CRC value
    pub mod FD_TXCRC {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (21 bits: 0x1fffff << 0)
        pub const mask: u32 = 0x1fffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CRC Mailbox Number for FD_TXCRC
    pub mod FD_MBCRC {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (7 bits: 0x7f << 24)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}
#[repr(C)]
pub struct RegisterBlock {
    /// Module Configuration register
    pub MCR: RWRegister<u32>,

    /// Control 1 register
    pub CTRL1: RWRegister<u32>,

    /// Free Running Timer
    pub TIMER: RWRegister<u32>,

    _reserved1: [u32; 1],

    /// Rx Mailboxes Global Mask register
    pub RXMGMASK: RWRegister<u32>,

    /// Rx 14 Mask register
    pub RX14MASK: RWRegister<u32>,

    /// Rx 15 Mask register
    pub RX15MASK: RWRegister<u32>,

    /// Error Counter
    pub ECR: RWRegister<u32>,

    /// Error and Status 1 register
    pub ESR1: RWRegister<u32>,

    /// Interrupt Masks 2 register
    pub IMASK2: RWRegister<u32>,

    /// Interrupt Masks 1 register
    pub IMASK1: RWRegister<u32>,

    /// Interrupt Flags 2 register
    pub IFLAG2: RWRegister<u32>,

    /// Interrupt Flags 1 register
    pub IFLAG1: RWRegister<u32>,

    /// Control 2 register
    pub CTRL2: RWRegister<u32>,

    /// Error and Status 2 register
    pub ESR2: RORegister<u32>,

    _reserved2: [u32; 2],

    /// CRC register
    pub CRCR: RORegister<u32>,

    /// Rx FIFO Global Mask register
    pub RXFGMASK: RWRegister<u32>,

    /// Rx FIFO Information register
    pub RXFIR: RORegister<u32>,

    /// CAN Bit Timing register
    pub CBT: RWRegister<u32>,

    _reserved3: [u32; 11],

    /// CS0 and MB0_8B_CS
    /// CS0: CS0 and MB0_64B_CS_L
    /// CS0: CS0 and MB0_32B_CS_L
    /// CS0: CS0 and MB0_16B_CS_L
    /// CS0: Message Buffer 0 CS Register
    /// MB0_16B_CS_L: Message Buffer 0 CS Register
    /// MB0_32B_CS_L: Message Buffer 0 CS Register
    /// MB0_64B_CS_L: Message Buffer 0 CS Register
    /// MB0_8B_CS: Message Buffer 0 CS Register
    pub CS0: RWRegister<u32>,

    /// ID0 and MB0_8B_ID
    /// ID0: ID0 and MB0_64B_ID_L
    /// ID0: ID0 and MB0_32B_ID_L
    /// ID0: ID0 and MB0_16B_ID_L
    /// ID0: Message Buffer 0 ID Register
    /// MB0_16B_ID_L: Message Buffer 0 ID Register
    /// MB0_32B_ID_L: Message Buffer 0 ID Register
    /// MB0_64B_ID_L: Message Buffer 0 ID Register
    /// MB0_8B_ID: Message Buffer 0 ID Register
    pub ID0: RWRegister<u32>,

    /// MB0 and WORD00
    /// MB0: MB0 and MB0_8B_WORD0
    /// MB0: MB0 and MB0_64B_WORD0_L
    /// MB0: MB0_16B_WORD0_L and MB0_32B_WORD0_L
    /// MB0_16B_WORD0_L: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD0_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD0_L: Message Buffer 0 WORD_64B Register
    /// MB0_8B_WORD0: Message Buffer 0 WORD_8B Register
    /// WORD00: Message Buffer 0 WORD0 Register
    pub MB0: RWRegister<u32>,

    /// MB0_16B_WORD1_L and WORD10
    /// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_8B_WORD1
    /// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_64B_WORD1_L
    /// MB0_16B_WORD1_L: MB0_16B_WORD1_L and MB0_32B_WORD1_L
    /// MB0_16B_WORD1_L: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD1_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD1_L: Message Buffer 0 WORD_64B Register
    /// MB0_8B_WORD1: Message Buffer 0 WORD_8B Register
    /// WORD10: Message Buffer 0 WORD1 Register
    pub MB0_16B_WORD1_L: RWRegister<u32>,

    /// CS1 and MB1_8B_CS
    /// CS1: CS1 and MB0_64B_WORD2_L
    /// CS1: CS1 and MB0_32B_WORD2_L
    /// CS1: CS1 and MB0_16B_WORD2_L
    /// CS1: Message Buffer 1 CS Register
    /// MB0_16B_WORD2_L: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD2_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD2_L: Message Buffer 0 WORD_64B Register
    /// MB1_8B_CS: Message Buffer 1 CS Register
    pub CS1: RWRegister<u32>,

    /// ID1 and MB1_8B_ID
    /// ID1: ID1 and MB0_64B_WORD3_L
    /// ID1: ID1 and MB0_32B_WORD3_L
    /// ID1: ID1 and MB0_16B_WORD3_L
    /// ID1: Message Buffer 1 ID Register
    /// MB0_16B_WORD3_L: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD3_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD3_L: Message Buffer 0 WORD_64B Register
    /// MB1_8B_ID: Message Buffer 1 ID Register
    pub ID1: RWRegister<u32>,

    /// MB and WORD01
    /// MB: MB and MB1_8B_WORD0
    /// MB: MB0_32B_WORD4_L and MB1_16B_CS_L
    /// MB0_32B_WORD4_L: MB0_32B_WORD4_L and MB0_64B_WORD4_L
    /// MB0_32B_WORD4_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD4_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_CS_L: Message Buffer 1 CS Register
    /// MB1_8B_WORD0: Message Buffer 1 WORD_8B Register
    /// WORD01: Message Buffer 1 WORD0 Register
    pub MB: RWRegister<u32>,

    /// MB0_32B_WORD5_L and WORD11
    /// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB1_8B_WORD1
    /// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB1_16B_ID_L
    /// MB0_32B_WORD5_L: MB0_32B_WORD5_L and MB0_64B_WORD5_L
    /// MB0_32B_WORD5_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD5_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_ID_L: Message Buffer 1 ID Register
    /// MB1_8B_WORD1: Message Buffer 1 WORD_8B Register
    /// WORD11: Message Buffer 1 WORD1 Register
    pub MB0_32B_WORD5_L: RWRegister<u32>,

    /// CS2 and MB2_8B_CS
    /// CS2: CS2 and MB1_16B_WORD0_L
    /// CS2: CS2 and MB0_64B_WORD6_L
    /// CS2: CS2 and MB0_32B_WORD6_L
    /// CS2: Message Buffer 2 CS Register
    /// MB0_32B_WORD6_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD6_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD0_L: Message Buffer 1 WORD_16B Register
    /// MB2_8B_CS: Message Buffer 2 CS Register
    pub CS2: RWRegister<u32>,

    /// ID2 and MB2_8B_ID
    /// ID2: ID2 and MB1_16B_WORD1_L
    /// ID2: ID2 and MB0_64B_WORD7_L
    /// ID2: ID2 and MB0_32B_WORD7_L
    /// ID2: Message Buffer 2 ID Register
    /// MB0_32B_WORD7_L: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD7_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD1_L: Message Buffer 1 WORD_16B Register
    /// MB2_8B_ID: Message Buffer 2 ID Register
    pub ID2: RWRegister<u32>,

    /// MB0_64B_WORD8_L and WORD02
    /// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB2_8B_WORD0
    /// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB1_32B_CS_L
    /// MB0_64B_WORD8_L: MB0_64B_WORD8_L and MB1_16B_WORD2_L
    /// MB0_64B_WORD8_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD2_L: Message Buffer 1 WORD_16B Register
    /// MB1_32B_CS_L: Message Buffer 1 CS Register
    /// MB2_8B_WORD0: Message Buffer 2 WORD_8B Register
    /// WORD02: Message Buffer 2 WORD0 Register
    pub MB0_64B_WORD8_L: RWRegister<u32>,

    /// MB0_64B_WORD9_L and WORD12
    /// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB2_8B_WORD1
    /// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB1_32B_ID_L
    /// MB0_64B_WORD9_L: MB0_64B_WORD9_L and MB1_16B_WORD3_L
    /// MB0_64B_WORD9_L: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD3_L: Message Buffer 1 WORD_16B Register
    /// MB1_32B_ID_L: Message Buffer 1 ID Register
    /// MB2_8B_WORD1: Message Buffer 2 WORD_8B Register
    /// WORD12: Message Buffer 2 WORD1 Register
    pub MB0_64B_WORD9_L: RWRegister<u32>,

    /// CS3 and MB3_8B_CS
    /// CS3: CS3 and MB2_16B_CS_L
    /// CS3: CS3 and MB1_32B_WORD0_L
    /// CS3: CS3 and MB0_64B_WORD10_L
    /// CS3: Message Buffer 3 CS Register
    /// MB0_64B_WORD10_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD0_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_CS_L: Message Buffer 2 CS Register
    /// MB3_8B_CS: Message Buffer 3 CS Register
    pub CS3: RWRegister<u32>,

    /// ID3 and MB3_8B_ID
    /// ID3: ID3 and MB2_16B_ID_L
    /// ID3: ID3 and MB1_32B_WORD1_L
    /// ID3: ID3 and MB0_64B_WORD11_L
    /// ID3: Message Buffer 3 ID Register
    /// MB0_64B_WORD11_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD1_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_ID_L: Message Buffer 2 ID Register
    /// MB3_8B_ID: Message Buffer 3 ID Register
    pub ID3: RWRegister<u32>,

    /// MB0_64B_WORD12_L and WORD03
    /// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB3_8B_WORD0
    /// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB2_16B_WORD0_L
    /// MB0_64B_WORD12_L: MB0_64B_WORD12_L and MB1_32B_WORD2_L
    /// MB0_64B_WORD12_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD2_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD0_L: Message Buffer 2 WORD_16B Register
    /// MB3_8B_WORD0: Message Buffer 3 WORD_8B Register
    /// WORD03: Message Buffer 3 WORD0 Register
    pub MB0_64B_WORD12_L: RWRegister<u32>,

    /// MB0_64B_WORD13_L and WORD13
    /// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB3_8B_WORD1
    /// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB2_16B_WORD1_L
    /// MB0_64B_WORD13_L: MB0_64B_WORD13_L and MB1_32B_WORD3_L
    /// MB0_64B_WORD13_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD3_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD1_L: Message Buffer 2 WORD_16B Register
    /// MB3_8B_WORD1: Message Buffer 3 WORD_8B Register
    /// WORD13: Message Buffer 3 WORD1 Register
    pub MB0_64B_WORD13_L: RWRegister<u32>,

    /// CS4 and MB4_8B_CS
    /// CS4: CS4 and MB2_16B_WORD2_L
    /// CS4: CS4 and MB1_32B_WORD4_L
    /// CS4: CS4 and MB0_64B_WORD14_L
    /// CS4: Message Buffer 4 CS Register
    /// MB0_64B_WORD14_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD4_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD2_L: Message Buffer 2 WORD_16B Register
    /// MB4_8B_CS: Message Buffer 4 CS Register
    pub CS4: RWRegister<u32>,

    /// ID4 and MB4_8B_ID
    /// ID4: ID4 and MB2_16B_WORD3_L
    /// ID4: ID4 and MB1_32B_WORD5_L
    /// ID4: ID4 and MB0_64B_WORD15_L
    /// ID4: Message Buffer 4 ID Register
    /// MB0_64B_WORD15_L: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD5_L: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD3_L: Message Buffer 2 WORD_16B Register
    /// MB4_8B_ID: Message Buffer 4 ID Register
    pub ID4: RWRegister<u32>,

    /// MB1 and WORD04
    /// MB1: MB1 and MB4_8B_WORD0
    /// MB1: MB1 and MB3_16B_CS_L
    /// MB1: MB1_32B_WORD6_L and MB1_64B_CS_L
    /// MB1_32B_WORD6_L: Message Buffer 1 WORD_32B Register
    /// MB1_64B_CS_L: Message Buffer 1 CS Register
    /// MB3_16B_CS_L: Message Buffer 3 CS Register
    /// MB4_8B_WORD0: Message Buffer 4 WORD_8B Register
    /// WORD04: Message Buffer 4 WORD0 Register
    pub MB1: RWRegister<u32>,

    /// MB1_32B_WORD7_L and WORD14
    /// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB4_8B_WORD1
    /// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB3_16B_ID_L
    /// MB1_32B_WORD7_L: MB1_32B_WORD7_L and MB1_64B_ID_L
    /// MB1_32B_WORD7_L: Message Buffer 1 WORD_32B Register
    /// MB1_64B_ID_L: Message Buffer 1 ID Register
    /// MB3_16B_ID_L: Message Buffer 3 ID Register
    /// MB4_8B_WORD1: Message Buffer 4 WORD_8B Register
    /// WORD14: Message Buffer 4 WORD1 Register
    pub MB1_32B_WORD7_L: RWRegister<u32>,

    /// CS5 and MB5_8B_CS
    /// CS5: CS5 and MB3_16B_WORD0_L
    /// CS5: CS5 and MB2_32B_CS_L
    /// CS5: CS5 and MB1_64B_WORD0_L
    /// CS5: Message Buffer 5 CS Register
    /// MB1_64B_WORD0_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_CS_L: Message Buffer 2 CS Register
    /// MB3_16B_WORD0_L: Message Buffer 3 WORD_16B Register
    /// MB5_8B_CS: Message Buffer 5 CS Register
    pub CS5: RWRegister<u32>,

    /// ID5 and MB5_8B_ID
    /// ID5: ID5 and MB3_16B_WORD1_L
    /// ID5: ID5 and MB2_32B_ID_L
    /// ID5: ID5 and MB1_64B_WORD1_L
    /// ID5: Message Buffer 5 ID Register
    /// MB1_64B_WORD1_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_ID_L: Message Buffer 2 ID Register
    /// MB3_16B_WORD1_L: Message Buffer 3 WORD_16B Register
    /// MB5_8B_ID: Message Buffer 5 ID Register
    pub ID5: RWRegister<u32>,

    /// MB1_64B_WORD2_L and WORD05
    /// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB5_8B_WORD0
    /// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB3_16B_WORD2_L
    /// MB1_64B_WORD2_L: MB1_64B_WORD2_L and MB2_32B_WORD0_L
    /// MB1_64B_WORD2_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD0_L: Message Buffer 2 WORD_32B Register
    /// MB3_16B_WORD2_L: Message Buffer 3 WORD_16B Register
    /// MB5_8B_WORD0: Message Buffer 5 WORD_8B Register
    /// WORD05: Message Buffer 5 WORD0 Register
    pub MB1_64B_WORD2_L: RWRegister<u32>,

    /// MB1_64B_WORD3_L and WORD15
    /// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB5_8B_WORD1
    /// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB3_16B_WORD3_L
    /// MB1_64B_WORD3_L: MB1_64B_WORD3_L and MB2_32B_WORD1_L
    /// MB1_64B_WORD3_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD1_L: Message Buffer 2 WORD_32B Register
    /// MB3_16B_WORD3_L: Message Buffer 3 WORD_16B Register
    /// MB5_8B_WORD1: Message Buffer 5 WORD_8B Register
    /// WORD15: Message Buffer 5 WORD1 Register
    pub MB1_64B_WORD3_L: RWRegister<u32>,

    /// CS6 and MB6_8B_CS
    /// CS6: CS6 and MB4_16B_CS_L
    /// CS6: CS6 and MB2_32B_WORD2_L
    /// CS6: CS6 and MB1_64B_WORD4_L
    /// CS6: Message Buffer 6 CS Register
    /// MB1_64B_WORD4_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD2_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_CS_L: Message Buffer 4 CS Register
    /// MB6_8B_CS: Message Buffer 6 CS Register
    pub CS6: RWRegister<u32>,

    /// ID6 and MB6_8B_ID
    /// ID6: ID6 and MB4_16B_ID_L
    /// ID6: ID6 and MB2_32B_WORD3_L
    /// ID6: ID6 and MB1_64B_WORD5_L
    /// ID6: Message Buffer 6 ID Register
    /// MB1_64B_WORD5_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD3_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_ID_L: Message Buffer 4 ID Register
    /// MB6_8B_ID: Message Buffer 6 ID Register
    pub ID6: RWRegister<u32>,

    /// MB1_64B_WORD6_L and WORD06
    /// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB6_8B_WORD0
    /// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB4_16B_WORD0_L
    /// MB1_64B_WORD6_L: MB1_64B_WORD6_L and MB2_32B_WORD4_L
    /// MB1_64B_WORD6_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD4_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD0_L: Message Buffer 4 WORD_16B Register
    /// MB6_8B_WORD0: Message Buffer 6 WORD_8B Register
    /// WORD06: Message Buffer 6 WORD0 Register
    pub MB1_64B_WORD6_L: RWRegister<u32>,

    /// MB1_64B_WORD7_L and WORD16
    /// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB6_8B_WORD1
    /// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB4_16B_WORD1_L
    /// MB1_64B_WORD7_L: MB1_64B_WORD7_L and MB2_32B_WORD5_L
    /// MB1_64B_WORD7_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD5_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD1_L: Message Buffer 4 WORD_16B Register
    /// MB6_8B_WORD1: Message Buffer 6 WORD_8B Register
    /// WORD16: Message Buffer 6 WORD1 Register
    pub MB1_64B_WORD7_L: RWRegister<u32>,

    /// CS7 and MB7_8B_CS
    /// CS7: CS7 and MB4_16B_WORD2_L
    /// CS7: CS7 and MB2_32B_WORD6_L
    /// CS7: CS7 and MB1_64B_WORD8_L
    /// CS7: Message Buffer 7 CS Register
    /// MB1_64B_WORD8_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD6_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD2_L: Message Buffer 4 WORD_16B Register
    /// MB7_8B_CS: Message Buffer 7 CS Register
    pub CS7: RWRegister<u32>,

    /// ID7 and MB7_8B_ID
    /// ID7: ID7 and MB4_16B_WORD3_L
    /// ID7: ID7 and MB2_32B_WORD7_L
    /// ID7: ID7 and MB1_64B_WORD9_L
    /// ID7: Message Buffer 7 ID Register
    /// MB1_64B_WORD9_L: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD7_L: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD3_L: Message Buffer 4 WORD_16B Register
    /// MB7_8B_ID: Message Buffer 7 ID Register
    pub ID7: RWRegister<u32>,

    /// MB1_64B_WORD10_L and WORD07
    /// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB7_8B_WORD0
    /// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB5_16B_CS_L
    /// MB1_64B_WORD10_L: MB1_64B_WORD10_L and MB3_32B_CS_L
    /// MB1_64B_WORD10_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_CS_L: Message Buffer 3 CS Register
    /// MB5_16B_CS_L: Message Buffer 5 CS Register
    /// MB7_8B_WORD0: Message Buffer 7 WORD_8B Register
    /// WORD07: Message Buffer 7 WORD0 Register
    pub MB1_64B_WORD10_L: RWRegister<u32>,

    /// MB1_64B_WORD11_L and WORD17
    /// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB7_8B_WORD1
    /// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB5_16B_ID_L
    /// MB1_64B_WORD11_L: MB1_64B_WORD11_L and MB3_32B_ID_L
    /// MB1_64B_WORD11_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_ID_L: Message Buffer 3 ID Register
    /// MB5_16B_ID_L: Message Buffer 5 ID Register
    /// MB7_8B_WORD1: Message Buffer 7 WORD_8B Register
    /// WORD17: Message Buffer 7 WORD1 Register
    pub MB1_64B_WORD11_L: RWRegister<u32>,

    /// CS8 and MB8_8B_CS
    /// CS8: CS8 and MB5_16B_WORD0_L
    /// CS8: CS8 and MB3_32B_WORD0_L
    /// CS8: CS8 and MB1_64B_WORD12_L
    /// CS8: Message Buffer 8 CS Register
    /// MB1_64B_WORD12_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD0_L: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD0_L: Message Buffer 5 WORD_16B Register
    /// MB8_8B_CS: Message Buffer 8 CS Register
    pub CS8: RWRegister<u32>,

    /// ID8 and MB8_8B_ID
    /// ID8: ID8 and MB5_16B_WORD1_L
    /// ID8: ID8 and MB3_32B_WORD1_L
    /// ID8: ID8 and MB1_64B_WORD13_L
    /// ID8: Message Buffer 8 ID Register
    /// MB1_64B_WORD13_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD1_L: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD1_L: Message Buffer 5 WORD_16B Register
    /// MB8_8B_ID: Message Buffer 8 ID Register
    pub ID8: RWRegister<u32>,

    /// MB1_64B_WORD14_L and WORD08
    /// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB8_8B_WORD0
    /// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB5_16B_WORD2_L
    /// MB1_64B_WORD14_L: MB1_64B_WORD14_L and MB3_32B_WORD2_L
    /// MB1_64B_WORD14_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD2_L: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD2_L: Message Buffer 5 WORD_16B Register
    /// MB8_8B_WORD0: Message Buffer 8 WORD_8B Register
    /// WORD08: Message Buffer 8 WORD0 Register
    pub MB1_64B_WORD14_L: RWRegister<u32>,

    /// MB1_64B_WORD15_L and WORD18
    /// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB8_8B_WORD1
    /// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB5_16B_WORD3_L
    /// MB1_64B_WORD15_L: MB1_64B_WORD15_L and MB3_32B_WORD3_L
    /// MB1_64B_WORD15_L: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD3_L: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD3_L: Message Buffer 5 WORD_16B Register
    /// MB8_8B_WORD1: Message Buffer 8 WORD_8B Register
    /// WORD18: Message Buffer 8 WORD1 Register
    pub MB1_64B_WORD15_L: RWRegister<u32>,

    /// CS9 and MB9_8B_CS
    /// CS9: CS9 and MB6_16B_CS_L
    /// CS9: CS9 and MB3_32B_WORD4_L
    /// CS9: CS9 and MB2_64B_CS_L
    /// CS9: Message Buffer 9 CS Register
    /// MB2_64B_CS_L: Message Buffer 2 CS Register
    /// MB3_32B_WORD4_L: Message Buffer 3 WORD_32B Register
    /// MB6_16B_CS_L: Message Buffer 6 CS Register
    /// MB9_8B_CS: Message Buffer 9 CS Register
    pub CS9: RWRegister<u32>,

    /// ID9 and MB9_8B_ID
    /// ID9: ID9 and MB6_16B_ID_L
    /// ID9: ID9 and MB3_32B_WORD5_L
    /// ID9: ID9 and MB2_64B_ID_L
    /// ID9: Message Buffer 9 ID Register
    /// MB2_64B_ID_L: Message Buffer 2 ID Register
    /// MB3_32B_WORD5_L: Message Buffer 3 WORD_32B Register
    /// MB6_16B_ID_L: Message Buffer 6 ID Register
    /// MB9_8B_ID: Message Buffer 9 ID Register
    pub ID9: RWRegister<u32>,

    /// MB2_64B_WORD0_L and WORD09
    /// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB9_8B_WORD0
    /// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB6_16B_WORD0_L
    /// MB2_64B_WORD0_L: MB2_64B_WORD0_L and MB3_32B_WORD6_L
    /// MB2_64B_WORD0_L: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD6_L: Message Buffer 3 WORD_32B Register
    /// MB6_16B_WORD0_L: Message Buffer 6 WORD_16B Register
    /// MB9_8B_WORD0: Message Buffer 9 WORD_8B Register
    /// WORD09: Message Buffer 9 WORD0 Register
    pub MB2_64B_WORD0_L: RWRegister<u32>,

    /// MB2_64B_WORD1_L and WORD19
    /// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB9_8B_WORD1
    /// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB6_16B_WORD1_L
    /// MB2_64B_WORD1_L: MB2_64B_WORD1_L and MB3_32B_WORD7_L
    /// MB2_64B_WORD1_L: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD7_L: Message Buffer 3 WORD_32B Register
    /// MB6_16B_WORD1_L: Message Buffer 6 WORD_16B Register
    /// MB9_8B_WORD1: Message Buffer 9 WORD_8B Register
    /// WORD19: Message Buffer 9 WORD1 Register
    pub MB2_64B_WORD1_L: RWRegister<u32>,

    /// CS10 and MB6_16B_WORD2_L
    /// CS10: CS10 and MB4_32B_CS_L
    /// CS10: CS10 and MB2_64B_WORD2_L
    /// CS10: CS10 and MB10_8B_CS
    /// CS10: Message Buffer 10 CS Register
    /// MB10_8B_CS: Message Buffer 10 CS Register
    /// MB2_64B_WORD2_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_CS_L: Message Buffer 4 CS Register
    /// MB6_16B_WORD2_L: Message Buffer 6 WORD_16B Register
    pub CS10: RWRegister<u32>,

    /// ID10 and MB6_16B_WORD3_L
    /// ID10: ID10 and MB4_32B_ID_L
    /// ID10: ID10 and MB2_64B_WORD3_L
    /// ID10: ID10 and MB10_8B_ID
    /// ID10: Message Buffer 10 ID Register
    /// MB10_8B_ID: Message Buffer 10 ID Register
    /// MB2_64B_WORD3_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_ID_L: Message Buffer 4 ID Register
    /// MB6_16B_WORD3_L: Message Buffer 6 WORD_16B Register
    pub ID10: RWRegister<u32>,

    /// MB10_8B_WORD0 and WORD010
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB7_16B_CS_L
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB4_32B_WORD0_L
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB2_64B_WORD4_L
    /// MB10_8B_WORD0: Message Buffer 10 WORD_8B Register
    /// MB2_64B_WORD4_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD0_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_CS_L: Message Buffer 7 CS Register
    /// WORD010: Message Buffer 10 WORD0 Register
    pub MB10_8B_WORD0: RWRegister<u32>,

    /// MB10_8B_WORD1 and WORD110
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB7_16B_ID_L
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB4_32B_WORD1_L
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB2_64B_WORD5_L
    /// MB10_8B_WORD1: Message Buffer 10 WORD_8B Register
    /// MB2_64B_WORD5_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD1_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_ID_L: Message Buffer 7 ID Register
    /// WORD110: Message Buffer 10 WORD1 Register
    pub MB10_8B_WORD1: RWRegister<u32>,

    /// CS11 and MB7_16B_WORD0_L
    /// CS11: CS11 and MB4_32B_WORD2_L
    /// CS11: CS11 and MB2_64B_WORD6_L
    /// CS11: CS11 and MB11_8B_CS
    /// CS11: Message Buffer 11 CS Register
    /// MB11_8B_CS: Message Buffer 11 CS Register
    /// MB2_64B_WORD6_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD2_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD0_L: Message Buffer 7 WORD_16B Register
    pub CS11: RWRegister<u32>,

    /// ID11 and MB7_16B_WORD1_L
    /// ID11: ID11 and MB4_32B_WORD3_L
    /// ID11: ID11 and MB2_64B_WORD7_L
    /// ID11: ID11 and MB11_8B_ID
    /// ID11: Message Buffer 11 ID Register
    /// MB11_8B_ID: Message Buffer 11 ID Register
    /// MB2_64B_WORD7_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD3_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD1_L: Message Buffer 7 WORD_16B Register
    pub ID11: RWRegister<u32>,

    /// MB11_8B_WORD0 and WORD011
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB7_16B_WORD2_L
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB4_32B_WORD4_L
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB2_64B_WORD8_L
    /// MB11_8B_WORD0: Message Buffer 11 WORD_8B Register
    /// MB2_64B_WORD8_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD4_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD2_L: Message Buffer 7 WORD_16B Register
    /// WORD011: Message Buffer 11 WORD0 Register
    pub MB11_8B_WORD0: RWRegister<u32>,

    /// MB11_8B_WORD1 and WORD111
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB7_16B_WORD3_L
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB4_32B_WORD5_L
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB2_64B_WORD9_L
    /// MB11_8B_WORD1: Message Buffer 11 WORD_8B Register
    /// MB2_64B_WORD9_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD5_L: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD3_L: Message Buffer 7 WORD_16B Register
    /// WORD111: Message Buffer 11 WORD1 Register
    pub MB11_8B_WORD1: RWRegister<u32>,

    /// CS12 and MB8_16B_CS_L
    /// CS12: CS12 and MB4_32B_WORD6_L
    /// CS12: CS12 and MB2_64B_WORD10_L
    /// CS12: CS12 and MB12_8B_CS
    /// CS12: Message Buffer 12 CS Register
    /// MB12_8B_CS: Message Buffer 12 CS Register
    /// MB2_64B_WORD10_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD6_L: Message Buffer 4 WORD_32B Register
    /// MB8_16B_CS_L: Message Buffer 8 CS Register
    pub CS12: RWRegister<u32>,

    /// ID12 and MB8_16B_ID_L
    /// ID12: ID12 and MB4_32B_WORD7_L
    /// ID12: ID12 and MB2_64B_WORD11_L
    /// ID12: ID12 and MB12_8B_ID
    /// ID12: Message Buffer 12 ID Register
    /// MB12_8B_ID: Message Buffer 12 ID Register
    /// MB2_64B_WORD11_L: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD7_L: Message Buffer 4 WORD_32B Register
    /// MB8_16B_ID_L: Message Buffer 8 ID Register
    pub ID12: RWRegister<u32>,

    /// MB12_8B_WORD0 and WORD012
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB8_16B_WORD0_L
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB5_32B_CS_L
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB2_64B_WORD12_L
    /// MB12_8B_WORD0: Message Buffer 12 WORD_8B Register
    /// MB2_64B_WORD12_L: Message Buffer 2 WORD_64B Register
    /// MB5_32B_CS_L: Message Buffer 5 CS Register
    /// MB8_16B_WORD0_L: Message Buffer 8 WORD_16B Register
    /// WORD012: Message Buffer 12 WORD0 Register
    pub MB12_8B_WORD0: RWRegister<u32>,

    /// MB12_8B_WORD1 and WORD112
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB8_16B_WORD1_L
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB5_32B_ID_L
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB2_64B_WORD13_L
    /// MB12_8B_WORD1: Message Buffer 12 WORD_8B Register
    /// MB2_64B_WORD13_L: Message Buffer 2 WORD_64B Register
    /// MB5_32B_ID_L: Message Buffer 5 ID Register
    /// MB8_16B_WORD1_L: Message Buffer 8 WORD_16B Register
    /// WORD112: Message Buffer 12 WORD1 Register
    pub MB12_8B_WORD1: RWRegister<u32>,

    /// CS13 and MB8_16B_WORD2_L
    /// CS13: CS13 and MB5_32B_WORD0_L
    /// CS13: CS13 and MB2_64B_WORD14_L
    /// CS13: CS13 and MB13_8B_CS
    /// CS13: Message Buffer 13 CS Register
    /// MB13_8B_CS: Message Buffer 13 CS Register
    /// MB2_64B_WORD14_L: Message Buffer 2 WORD_64B Register
    /// MB5_32B_WORD0_L: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD2_L: Message Buffer 8 WORD_16B Register
    pub CS13: RWRegister<u32>,

    /// ID13 and MB8_16B_WORD3_L
    /// ID13: ID13 and MB5_32B_WORD1_L
    /// ID13: ID13 and MB2_64B_WORD15_L
    /// ID13: ID13 and MB13_8B_ID
    /// ID13: Message Buffer 13 ID Register
    /// MB13_8B_ID: Message Buffer 13 ID Register
    /// MB2_64B_WORD15_L: Message Buffer 2 WORD_64B Register
    /// MB5_32B_WORD1_L: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD3_L: Message Buffer 8 WORD_16B Register
    pub ID13: RWRegister<u32>,

    /// MB13_8B_WORD0 and WORD013
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB9_16B_CS_L
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB5_32B_WORD2_L
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB3_64B_CS_L
    /// MB13_8B_WORD0: Message Buffer 13 WORD_8B Register
    /// MB3_64B_CS_L: Message Buffer 3 CS Register
    /// MB5_32B_WORD2_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_CS_L: Message Buffer 9 CS Register
    /// WORD013: Message Buffer 13 WORD0 Register
    pub MB13_8B_WORD0: RWRegister<u32>,

    /// MB13_8B_WORD1 and WORD113
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB9_16B_ID_L
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB5_32B_WORD3_L
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB3_64B_ID_L
    /// MB13_8B_WORD1: Message Buffer 13 WORD_8B Register
    /// MB3_64B_ID_L: Message Buffer 3 ID Register
    /// MB5_32B_WORD3_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_ID_L: Message Buffer 9 ID Register
    /// WORD113: Message Buffer 13 WORD1 Register
    pub MB13_8B_WORD1: RWRegister<u32>,

    /// CS14 and MB9_16B_WORD0_L
    /// CS14: CS14 and MB5_32B_WORD4_L
    /// CS14: CS14 and MB3_64B_WORD0_L
    /// CS14: CS14 and MB14_8B_CS
    /// CS14: Message Buffer 14 CS Register
    /// MB14_8B_CS: Message Buffer 14 CS Register
    /// MB3_64B_WORD0_L: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD4_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD0_L: Message Buffer 9 WORD_16B Register
    pub CS14: RWRegister<u32>,

    /// ID14 and MB9_16B_WORD1_L
    /// ID14: ID14 and MB5_32B_WORD5_L
    /// ID14: ID14 and MB3_64B_WORD1_L
    /// ID14: ID14 and MB14_8B_ID
    /// ID14: Message Buffer 14 ID Register
    /// MB14_8B_ID: Message Buffer 14 ID Register
    /// MB3_64B_WORD1_L: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD5_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD1_L: Message Buffer 9 WORD_16B Register
    pub ID14: RWRegister<u32>,

    /// MB14_8B_WORD0 and WORD014
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB9_16B_WORD2_L
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB5_32B_WORD6_L
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB3_64B_WORD2_L
    /// MB14_8B_WORD0: Message Buffer 14 WORD_8B Register
    /// MB3_64B_WORD2_L: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD6_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD2_L: Message Buffer 9 WORD_16B Register
    /// WORD014: Message Buffer 14 WORD0 Register
    pub MB14_8B_WORD0: RWRegister<u32>,

    /// MB14_8B_WORD1 and WORD114
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB9_16B_WORD3_L
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB5_32B_WORD7_L
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB3_64B_WORD3_L
    /// MB14_8B_WORD1: Message Buffer 14 WORD_8B Register
    /// MB3_64B_WORD3_L: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD7_L: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD3_L: Message Buffer 9 WORD_16B Register
    /// WORD114: Message Buffer 14 WORD1 Register
    pub MB14_8B_WORD1: RWRegister<u32>,

    /// CS15 and MB6_32B_CS_L
    /// CS15: CS15 and MB3_64B_WORD4_L
    /// CS15: CS15 and MB15_8B_CS
    /// CS15: CS15 and MB10_16B_CS_L
    /// CS15: Message Buffer 15 CS Register
    /// MB10_16B_CS_L: Message Buffer 10 CS Register
    /// MB15_8B_CS: Message Buffer 15 CS Register
    /// MB3_64B_WORD4_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_CS_L: Message Buffer 6 CS Register
    pub CS15: RWRegister<u32>,

    /// ID15 and MB6_32B_ID_L
    /// ID15: ID15 and MB3_64B_WORD5_L
    /// ID15: ID15 and MB15_8B_ID
    /// ID15: ID15 and MB10_16B_ID_L
    /// ID15: Message Buffer 15 ID Register
    /// MB10_16B_ID_L: Message Buffer 10 ID Register
    /// MB15_8B_ID: Message Buffer 15 ID Register
    /// MB3_64B_WORD5_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_ID_L: Message Buffer 6 ID Register
    pub ID15: RWRegister<u32>,

    /// MB10_16B_WORD0_L and WORD015
    /// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB6_32B_WORD0_L
    /// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB3_64B_WORD6_L
    /// MB10_16B_WORD0_L: MB10_16B_WORD0_L and MB15_8B_WORD0
    /// MB10_16B_WORD0_L: Message Buffer 10 WORD_16B Register
    /// MB15_8B_WORD0: Message Buffer 15 WORD_8B Register
    /// MB3_64B_WORD6_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD0_L: Message Buffer 6 WORD_32B Register
    /// WORD015: Message Buffer 15 WORD0 Register
    pub MB10_16B_WORD0_L: RWRegister<u32>,

    /// MB10_16B_WORD1_L and WORD115
    /// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB6_32B_WORD1_L
    /// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB3_64B_WORD7_L
    /// MB10_16B_WORD1_L: MB10_16B_WORD1_L and MB15_8B_WORD1
    /// MB10_16B_WORD1_L: Message Buffer 10 WORD_16B Register
    /// MB15_8B_WORD1: Message Buffer 15 WORD_8B Register
    /// MB3_64B_WORD7_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD1_L: Message Buffer 6 WORD_32B Register
    /// WORD115: Message Buffer 15 WORD1 Register
    pub MB10_16B_WORD1_L: RWRegister<u32>,

    /// CS16 and MB6_32B_WORD2_L
    /// CS16: CS16 and MB3_64B_WORD8_L
    /// CS16: CS16 and MB16_8B_CS
    /// CS16: CS16 and MB10_16B_WORD2_L
    /// CS16: Message Buffer 16 CS Register
    /// MB10_16B_WORD2_L: Message Buffer 10 WORD_16B Register
    /// MB16_8B_CS: Message Buffer 16 CS Register
    /// MB3_64B_WORD8_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD2_L: Message Buffer 6 WORD_32B Register
    pub CS16: RWRegister<u32>,

    /// ID16 and MB6_32B_WORD3_L
    /// ID16: ID16 and MB3_64B_WORD9_L
    /// ID16: ID16 and MB16_8B_ID
    /// ID16: ID16 and MB10_16B_WORD3_L
    /// ID16: Message Buffer 16 ID Register
    /// MB10_16B_WORD3_L: Message Buffer 10 WORD_16B Register
    /// MB16_8B_ID: Message Buffer 16 ID Register
    /// MB3_64B_WORD9_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD3_L: Message Buffer 6 WORD_32B Register
    pub ID16: RWRegister<u32>,

    /// MB11_16B_CS_L and WORD016
    /// MB11_16B_CS_L: MB11_16B_CS_L and MB6_32B_WORD4_L
    /// MB11_16B_CS_L: MB11_16B_CS_L and MB3_64B_WORD10_L
    /// MB11_16B_CS_L: MB11_16B_CS_L and MB16_8B_WORD0
    /// MB11_16B_CS_L: Message Buffer 11 CS Register
    /// MB16_8B_WORD0: Message Buffer 16 WORD_8B Register
    /// MB3_64B_WORD10_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD4_L: Message Buffer 6 WORD_32B Register
    /// WORD016: Message Buffer 16 WORD0 Register
    pub MB11_16B_CS_L: RWRegister<u32>,

    /// MB11_16B_ID_L and WORD116
    /// MB11_16B_ID_L: MB11_16B_ID_L and MB6_32B_WORD5_L
    /// MB11_16B_ID_L: MB11_16B_ID_L and MB3_64B_WORD11_L
    /// MB11_16B_ID_L: MB11_16B_ID_L and MB16_8B_WORD1
    /// MB11_16B_ID_L: Message Buffer 11 ID Register
    /// MB16_8B_WORD1: Message Buffer 16 WORD_8B Register
    /// MB3_64B_WORD11_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD5_L: Message Buffer 6 WORD_32B Register
    /// WORD116: Message Buffer 16 WORD1 Register
    pub MB11_16B_ID_L: RWRegister<u32>,

    /// CS17 and MB6_32B_WORD6_L
    /// CS17: CS17 and MB3_64B_WORD12_L
    /// CS17: CS17 and MB17_8B_CS
    /// CS17: CS17 and MB11_16B_WORD0_L
    /// CS17: Message Buffer 17 CS Register
    /// MB11_16B_WORD0_L: Message Buffer 11 WORD_16B Register
    /// MB17_8B_CS: Message Buffer 17 CS Register
    /// MB3_64B_WORD12_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD6_L: Message Buffer 6 WORD_32B Register
    pub CS17: RWRegister<u32>,

    /// ID17 and MB6_32B_WORD7_L
    /// ID17: ID17 and MB3_64B_WORD13_L
    /// ID17: ID17 and MB17_8B_ID
    /// ID17: ID17 and MB11_16B_WORD1_L
    /// ID17: Message Buffer 17 ID Register
    /// MB11_16B_WORD1_L: Message Buffer 11 WORD_16B Register
    /// MB17_8B_ID: Message Buffer 17 ID Register
    /// MB3_64B_WORD13_L: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD7_L: Message Buffer 6 WORD_32B Register
    pub ID17: RWRegister<u32>,

    /// MB11_16B_WORD2_L and WORD017
    /// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB7_32B_CS_L
    /// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB3_64B_WORD14_L
    /// MB11_16B_WORD2_L: MB11_16B_WORD2_L and MB17_8B_WORD0
    /// MB11_16B_WORD2_L: Message Buffer 11 WORD_16B Register
    /// MB17_8B_WORD0: Message Buffer 17 WORD_8B Register
    /// MB3_64B_WORD14_L: Message Buffer 3 WORD_64B Register
    /// MB7_32B_CS_L: Message Buffer 7 CS Register
    /// WORD017: Message Buffer 17 WORD0 Register
    pub MB11_16B_WORD2_L: RWRegister<u32>,

    /// MB11_16B_WORD3_L and WORD117
    /// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB7_32B_ID_L
    /// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB3_64B_WORD15_L
    /// MB11_16B_WORD3_L: MB11_16B_WORD3_L and MB17_8B_WORD1
    /// MB11_16B_WORD3_L: Message Buffer 11 WORD_16B Register
    /// MB17_8B_WORD1: Message Buffer 17 WORD_8B Register
    /// MB3_64B_WORD15_L: Message Buffer 3 WORD_64B Register
    /// MB7_32B_ID_L: Message Buffer 7 ID Register
    /// WORD117: Message Buffer 17 WORD1 Register
    pub MB11_16B_WORD3_L: RWRegister<u32>,

    /// CS18 and MB7_32B_WORD0_L
    /// CS18: CS18 and MB4_64B_CS_L
    /// CS18: CS18 and MB18_8B_CS
    /// CS18: CS18 and MB12_16B_CS_L
    /// CS18: Message Buffer 18 CS Register
    /// MB12_16B_CS_L: Message Buffer 12 CS Register
    /// MB18_8B_CS: Message Buffer 18 CS Register
    /// MB4_64B_CS_L: Message Buffer 4 CS Register
    /// MB7_32B_WORD0_L: Message Buffer 7 WORD_32B Register
    pub CS18: RWRegister<u32>,

    /// ID18 and MB7_32B_WORD1_L
    /// ID18: ID18 and MB4_64B_ID_L
    /// ID18: ID18 and MB18_8B_ID
    /// ID18: ID18 and MB12_16B_ID_L
    /// ID18: Message Buffer 18 ID Register
    /// MB12_16B_ID_L: Message Buffer 12 ID Register
    /// MB18_8B_ID: Message Buffer 18 ID Register
    /// MB4_64B_ID_L: Message Buffer 4 ID Register
    /// MB7_32B_WORD1_L: Message Buffer 7 WORD_32B Register
    pub ID18: RWRegister<u32>,

    /// MB12_16B_WORD0_L and WORD018
    /// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB7_32B_WORD2_L
    /// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB4_64B_WORD0_L
    /// MB12_16B_WORD0_L: MB12_16B_WORD0_L and MB18_8B_WORD0
    /// MB12_16B_WORD0_L: Message Buffer 12 WORD_16B Register
    /// MB18_8B_WORD0: Message Buffer 18 WORD_8B Register
    /// MB4_64B_WORD0_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD2_L: Message Buffer 7 WORD_32B Register
    /// WORD018: Message Buffer 18 WORD0 Register
    pub MB12_16B_WORD0_L: RWRegister<u32>,

    /// MB12_16B_WORD1_L and WORD118
    /// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB7_32B_WORD3_L
    /// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB4_64B_WORD1_L
    /// MB12_16B_WORD1_L: MB12_16B_WORD1_L and MB18_8B_WORD1
    /// MB12_16B_WORD1_L: Message Buffer 12 WORD_16B Register
    /// MB18_8B_WORD1: Message Buffer 18 WORD_8B Register
    /// MB4_64B_WORD1_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD3_L: Message Buffer 7 WORD_32B Register
    /// WORD118: Message Buffer 18 WORD1 Register
    pub MB12_16B_WORD1_L: RWRegister<u32>,

    /// CS19 and MB7_32B_WORD4_L
    /// CS19: CS19 and MB4_64B_WORD2_L
    /// CS19: CS19 and MB19_8B_CS
    /// CS19: CS19 and MB12_16B_WORD2_L
    /// CS19: Message Buffer 19 CS Register
    /// MB12_16B_WORD2_L: Message Buffer 12 WORD_16B Register
    /// MB19_8B_CS: Message Buffer 19 CS Register
    /// MB4_64B_WORD2_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD4_L: Message Buffer 7 WORD_32B Register
    pub CS19: RWRegister<u32>,

    /// ID19 and MB7_32B_WORD5_L
    /// ID19: ID19 and MB4_64B_WORD3_L
    /// ID19: ID19 and MB19_8B_ID
    /// ID19: ID19 and MB12_16B_WORD3_L
    /// ID19: Message Buffer 19 ID Register
    /// MB12_16B_WORD3_L: Message Buffer 12 WORD_16B Register
    /// MB19_8B_ID: Message Buffer 19 ID Register
    /// MB4_64B_WORD3_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD5_L: Message Buffer 7 WORD_32B Register
    pub ID19: RWRegister<u32>,

    /// MB13_16B_CS_L and WORD019
    /// MB13_16B_CS_L: MB13_16B_CS_L and MB7_32B_WORD6_L
    /// MB13_16B_CS_L: MB13_16B_CS_L and MB4_64B_WORD4_L
    /// MB13_16B_CS_L: MB13_16B_CS_L and MB19_8B_WORD0
    /// MB13_16B_CS_L: Message Buffer 13 CS Register
    /// MB19_8B_WORD0: Message Buffer 19 WORD_8B Register
    /// MB4_64B_WORD4_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD6_L: Message Buffer 7 WORD_32B Register
    /// WORD019: Message Buffer 19 WORD0 Register
    pub MB13_16B_CS_L: RWRegister<u32>,

    /// MB13_16B_ID_L and WORD119
    /// MB13_16B_ID_L: MB13_16B_ID_L and MB7_32B_WORD7_L
    /// MB13_16B_ID_L: MB13_16B_ID_L and MB4_64B_WORD5_L
    /// MB13_16B_ID_L: MB13_16B_ID_L and MB19_8B_WORD1
    /// MB13_16B_ID_L: Message Buffer 13 ID Register
    /// MB19_8B_WORD1: Message Buffer 19 WORD_8B Register
    /// MB4_64B_WORD5_L: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD7_L: Message Buffer 7 WORD_32B Register
    /// WORD119: Message Buffer 19 WORD1 Register
    pub MB13_16B_ID_L: RWRegister<u32>,

    /// CS20 and MB8_32B_CS_L
    /// CS20: CS20 and MB4_64B_WORD6_L
    /// CS20: CS20 and MB20_8B_CS
    /// CS20: CS20 and MB13_16B_WORD0_L
    /// CS20: Message Buffer 20 CS Register
    /// MB13_16B_WORD0_L: Message Buffer 13 WORD_16B Register
    /// MB20_8B_CS: Message Buffer 20 CS Register
    /// MB4_64B_WORD6_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_CS_L: Message Buffer 8 CS Register
    pub CS20: RWRegister<u32>,

    /// ID20 and MB8_32B_ID_L
    /// ID20: ID20 and MB4_64B_WORD7_L
    /// ID20: ID20 and MB20_8B_ID
    /// ID20: ID20 and MB13_16B_WORD1_L
    /// ID20: Message Buffer 20 ID Register
    /// MB13_16B_WORD1_L: Message Buffer 13 WORD_16B Register
    /// MB20_8B_ID: Message Buffer 20 ID Register
    /// MB4_64B_WORD7_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_ID_L: Message Buffer 8 ID Register
    pub ID20: RWRegister<u32>,

    /// MB13_16B_WORD2_L and WORD020
    /// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB8_32B_WORD0_L
    /// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB4_64B_WORD8_L
    /// MB13_16B_WORD2_L: MB13_16B_WORD2_L and MB20_8B_WORD0
    /// MB13_16B_WORD2_L: Message Buffer 13 WORD_16B Register
    /// MB20_8B_WORD0: Message Buffer 20 WORD_8B Register
    /// MB4_64B_WORD8_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD0_L: Message Buffer 8 WORD_32B Register
    /// WORD020: Message Buffer 20 WORD0 Register
    pub MB13_16B_WORD2_L: RWRegister<u32>,

    /// MB13_16B_WORD3_L and WORD120
    /// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB8_32B_WORD1_L
    /// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB4_64B_WORD9_L
    /// MB13_16B_WORD3_L: MB13_16B_WORD3_L and MB20_8B_WORD1
    /// MB13_16B_WORD3_L: Message Buffer 13 WORD_16B Register
    /// MB20_8B_WORD1: Message Buffer 20 WORD_8B Register
    /// MB4_64B_WORD9_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD1_L: Message Buffer 8 WORD_32B Register
    /// WORD120: Message Buffer 20 WORD1 Register
    pub MB13_16B_WORD3_L: RWRegister<u32>,

    /// CS21 and MB8_32B_WORD2_L
    /// CS21: CS21 and MB4_64B_WORD10_L
    /// CS21: CS21 and MB21_8B_CS
    /// CS21: CS21 and MB14_16B_CS_L
    /// CS21: Message Buffer 21 CS Register
    /// MB14_16B_CS_L: Message Buffer 14 CS Register
    /// MB21_8B_CS: Message Buffer 21 CS Register
    /// MB4_64B_WORD10_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD2_L: Message Buffer 8 WORD_32B Register
    pub CS21: RWRegister<u32>,

    /// ID21 and MB8_32B_WORD3_L
    /// ID21: ID21 and MB4_64B_WORD11_L
    /// ID21: ID21 and MB21_8B_ID
    /// ID21: ID21 and MB14_16B_ID_L
    /// ID21: Message Buffer 21 ID Register
    /// MB14_16B_ID_L: Message Buffer 14 ID Register
    /// MB21_8B_ID: Message Buffer 21 ID Register
    /// MB4_64B_WORD11_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD3_L: Message Buffer 8 WORD_32B Register
    pub ID21: RWRegister<u32>,

    /// MB14_16B_WORD0_L and WORD021
    /// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB8_32B_WORD4_L
    /// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB4_64B_WORD12_L
    /// MB14_16B_WORD0_L: MB14_16B_WORD0_L and MB21_8B_WORD0
    /// MB14_16B_WORD0_L: Message Buffer 14 WORD_16B Register
    /// MB21_8B_WORD0: Message Buffer 21 WORD_8B Register
    /// MB4_64B_WORD12_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD4_L: Message Buffer 8 WORD_32B Register
    /// WORD021: Message Buffer 21 WORD0 Register
    pub MB14_16B_WORD0_L: RWRegister<u32>,

    /// MB14_16B_WORD1_L and WORD121
    /// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB8_32B_WORD5_L
    /// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB4_64B_WORD13_L
    /// MB14_16B_WORD1_L: MB14_16B_WORD1_L and MB21_8B_WORD1
    /// MB14_16B_WORD1_L: Message Buffer 14 WORD_16B Register
    /// MB21_8B_WORD1: Message Buffer 21 WORD_8B Register
    /// MB4_64B_WORD13_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD5_L: Message Buffer 8 WORD_32B Register
    /// WORD121: Message Buffer 21 WORD1 Register
    pub MB14_16B_WORD1_L: RWRegister<u32>,

    /// CS22 and MB8_32B_WORD6_L
    /// CS22: CS22 and MB4_64B_WORD14_L
    /// CS22: CS22 and MB22_8B_CS
    /// CS22: CS22 and MB14_16B_WORD2_L
    /// CS22: Message Buffer 22 CS Register
    /// MB14_16B_WORD2_L: Message Buffer 14 WORD_16B Register
    /// MB22_8B_CS: Message Buffer 22 CS Register
    /// MB4_64B_WORD14_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD6_L: Message Buffer 8 WORD_32B Register
    pub CS22: RWRegister<u32>,

    /// ID22 and MB8_32B_WORD7_L
    /// ID22: ID22 and MB4_64B_WORD15_L
    /// ID22: ID22 and MB22_8B_ID
    /// ID22: ID22 and MB14_16B_WORD3_L
    /// ID22: Message Buffer 22 ID Register
    /// MB14_16B_WORD3_L: Message Buffer 14 WORD_16B Register
    /// MB22_8B_ID: Message Buffer 22 ID Register
    /// MB4_64B_WORD15_L: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD7_L: Message Buffer 8 WORD_32B Register
    pub ID22: RWRegister<u32>,

    /// MB15_16B_CS_L and WORD022
    /// MB15_16B_CS_L: MB15_16B_CS_L and MB9_32B_CS_L
    /// MB15_16B_CS_L: MB15_16B_CS_L and MB5_64B_CS_L
    /// MB15_16B_CS_L: MB15_16B_CS_L and MB22_8B_WORD0
    /// MB15_16B_CS_L: Message Buffer 15 CS Register
    /// MB22_8B_WORD0: Message Buffer 22 WORD_8B Register
    /// MB5_64B_CS_L: Message Buffer 5 CS Register
    /// MB9_32B_CS_L: Message Buffer 9 CS Register
    /// WORD022: Message Buffer 22 WORD0 Register
    pub MB15_16B_CS_L: RWRegister<u32>,

    /// MB15_16B_ID_L and WORD122
    /// MB15_16B_ID_L: MB15_16B_ID_L and MB9_32B_ID_L
    /// MB15_16B_ID_L: MB15_16B_ID_L and MB5_64B_ID_L
    /// MB15_16B_ID_L: MB15_16B_ID_L and MB22_8B_WORD1
    /// MB15_16B_ID_L: Message Buffer 15 ID Register
    /// MB22_8B_WORD1: Message Buffer 22 WORD_8B Register
    /// MB5_64B_ID_L: Message Buffer 5 ID Register
    /// MB9_32B_ID_L: Message Buffer 9 ID Register
    /// WORD122: Message Buffer 22 WORD1 Register
    pub MB15_16B_ID_L: RWRegister<u32>,

    /// CS23 and MB9_32B_WORD0_L
    /// CS23: CS23 and MB5_64B_WORD0_L
    /// CS23: CS23 and MB23_8B_CS
    /// CS23: CS23 and MB15_16B_WORD0_L
    /// CS23: Message Buffer 23 CS Register
    /// MB15_16B_WORD0_L: Message Buffer 15 WORD_16B Register
    /// MB23_8B_CS: Message Buffer 23 CS Register
    /// MB5_64B_WORD0_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD0_L: Message Buffer 9 WORD_32B Register
    pub CS23: RWRegister<u32>,

    /// ID23 and MB9_32B_WORD1_L
    /// ID23: ID23 and MB5_64B_WORD1_L
    /// ID23: ID23 and MB23_8B_ID
    /// ID23: ID23 and MB15_16B_WORD1_L
    /// ID23: Message Buffer 23 ID Register
    /// MB15_16B_WORD1_L: Message Buffer 15 WORD_16B Register
    /// MB23_8B_ID: Message Buffer 23 ID Register
    /// MB5_64B_WORD1_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD1_L: Message Buffer 9 WORD_32B Register
    pub ID23: RWRegister<u32>,

    /// MB15_16B_WORD2_L and WORD023
    /// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB9_32B_WORD2_L
    /// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB5_64B_WORD2_L
    /// MB15_16B_WORD2_L: MB15_16B_WORD2_L and MB23_8B_WORD0
    /// MB15_16B_WORD2_L: Message Buffer 15 WORD_16B Register
    /// MB23_8B_WORD0: Message Buffer 23 WORD_8B Register
    /// MB5_64B_WORD2_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD2_L: Message Buffer 9 WORD_32B Register
    /// WORD023: Message Buffer 23 WORD0 Register
    pub MB15_16B_WORD2_L: RWRegister<u32>,

    /// MB15_16B_WORD3_L and WORD123
    /// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB9_32B_WORD3_L
    /// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB5_64B_WORD3_L
    /// MB15_16B_WORD3_L: MB15_16B_WORD3_L and MB23_8B_WORD1
    /// MB15_16B_WORD3_L: Message Buffer 15 WORD_16B Register
    /// MB23_8B_WORD1: Message Buffer 23 WORD_8B Register
    /// MB5_64B_WORD3_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD3_L: Message Buffer 9 WORD_32B Register
    /// WORD123: Message Buffer 23 WORD1 Register
    pub MB15_16B_WORD3_L: RWRegister<u32>,

    /// CS24 and MB9_32B_WORD4_L
    /// CS24: CS24 and MB5_64B_WORD4_L
    /// CS24: CS24 and MB24_8B_CS
    /// CS24: CS24 and MB16_16B_CS_L
    /// CS24: Message Buffer 24 CS Register
    /// MB16_16B_CS_L: Message Buffer 16 CS Register
    /// MB24_8B_CS: Message Buffer 24 CS Register
    /// MB5_64B_WORD4_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD4_L: Message Buffer 9 WORD_32B Register
    pub CS24: RWRegister<u32>,

    /// ID24 and MB9_32B_WORD5_L
    /// ID24: ID24 and MB5_64B_WORD5_L
    /// ID24: ID24 and MB24_8B_ID
    /// ID24: ID24 and MB16_16B_ID_L
    /// ID24: Message Buffer 24 ID Register
    /// MB16_16B_ID_L: Message Buffer 16 ID Register
    /// MB24_8B_ID: Message Buffer 24 ID Register
    /// MB5_64B_WORD5_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD5_L: Message Buffer 9 WORD_32B Register
    pub ID24: RWRegister<u32>,

    /// MB16_16B_WORD0_L and WORD024
    /// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB9_32B_WORD6_L
    /// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB5_64B_WORD6_L
    /// MB16_16B_WORD0_L: MB16_16B_WORD0_L and MB24_8B_WORD0
    /// MB16_16B_WORD0_L: Message Buffer 16 WORD_16B Register
    /// MB24_8B_WORD0: Message Buffer 24 WORD_8B Register
    /// MB5_64B_WORD6_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD6_L: Message Buffer 9 WORD_32B Register
    /// WORD024: Message Buffer 24 WORD0 Register
    pub MB16_16B_WORD0_L: RWRegister<u32>,

    /// MB16_16B_WORD1_L and WORD124
    /// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB9_32B_WORD7_L
    /// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB5_64B_WORD7_L
    /// MB16_16B_WORD1_L: MB16_16B_WORD1_L and MB24_8B_WORD1
    /// MB16_16B_WORD1_L: Message Buffer 16 WORD_16B Register
    /// MB24_8B_WORD1: Message Buffer 24 WORD_8B Register
    /// MB5_64B_WORD7_L: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD7_L: Message Buffer 9 WORD_32B Register
    /// WORD124: Message Buffer 24 WORD1 Register
    pub MB16_16B_WORD1_L: RWRegister<u32>,

    /// CS25 and MB5_64B_WORD8_L
    /// CS25: CS25 and MB25_8B_CS
    /// CS25: CS25 and MB16_16B_WORD2_L
    /// CS25: CS25 and MB10_32B_CS_L
    /// CS25: Message Buffer 25 CS Register
    /// MB10_32B_CS_L: Message Buffer 10 CS Register
    /// MB16_16B_WORD2_L: Message Buffer 16 WORD_16B Register
    /// MB25_8B_CS: Message Buffer 25 CS Register
    /// MB5_64B_WORD8_L: Message Buffer 5 WORD_64B Register
    pub CS25: RWRegister<u32>,

    /// ID25 and MB5_64B_WORD9_L
    /// ID25: ID25 and MB25_8B_ID
    /// ID25: ID25 and MB16_16B_WORD3_L
    /// ID25: ID25 and MB10_32B_ID_L
    /// ID25: Message Buffer 25 ID Register
    /// MB10_32B_ID_L: Message Buffer 10 ID Register
    /// MB16_16B_WORD3_L: Message Buffer 16 WORD_16B Register
    /// MB25_8B_ID: Message Buffer 25 ID Register
    /// MB5_64B_WORD9_L: Message Buffer 5 WORD_64B Register
    pub ID25: RWRegister<u32>,

    /// MB10_32B_WORD0_L and WORD025
    /// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB5_64B_WORD10_L
    /// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB25_8B_WORD0
    /// MB10_32B_WORD0_L: MB10_32B_WORD0_L and MB17_16B_CS_L
    /// MB10_32B_WORD0_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_CS_L: Message Buffer 17 CS Register
    /// MB25_8B_WORD0: Message Buffer 25 WORD_8B Register
    /// MB5_64B_WORD10_L: Message Buffer 5 WORD_64B Register
    /// WORD025: Message Buffer 25 WORD0 Register
    pub MB10_32B_WORD0_L: RWRegister<u32>,

    /// MB10_32B_WORD1_L and WORD125
    /// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB5_64B_WORD11_L
    /// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB25_8B_WORD1
    /// MB10_32B_WORD1_L: MB10_32B_WORD1_L and MB17_16B_ID_L
    /// MB10_32B_WORD1_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_ID_L: Message Buffer 17 ID Register
    /// MB25_8B_WORD1: Message Buffer 25 WORD_8B Register
    /// MB5_64B_WORD11_L: Message Buffer 5 WORD_64B Register
    /// WORD125: Message Buffer 25 WORD1 Register
    pub MB10_32B_WORD1_L: RWRegister<u32>,

    /// CS26 and MB5_64B_WORD12_L
    /// CS26: CS26 and MB26_8B_CS
    /// CS26: CS26 and MB17_16B_WORD0_L
    /// CS26: CS26 and MB10_32B_WORD2_L
    /// CS26: Message Buffer 26 CS Register
    /// MB10_32B_WORD2_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD0_L: Message Buffer 17 WORD_16B Register
    /// MB26_8B_CS: Message Buffer 26 CS Register
    /// MB5_64B_WORD12_L: Message Buffer 5 WORD_64B Register
    pub CS26: RWRegister<u32>,

    /// ID26 and MB5_64B_WORD13_L
    /// ID26: ID26 and MB26_8B_ID
    /// ID26: ID26 and MB17_16B_WORD1_L
    /// ID26: ID26 and MB10_32B_WORD3_L
    /// ID26: Message Buffer 26 ID Register
    /// MB10_32B_WORD3_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD1_L: Message Buffer 17 WORD_16B Register
    /// MB26_8B_ID: Message Buffer 26 ID Register
    /// MB5_64B_WORD13_L: Message Buffer 5 WORD_64B Register
    pub ID26: RWRegister<u32>,

    /// MB10_32B_WORD4_L and WORD026
    /// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB5_64B_WORD14_L
    /// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB26_8B_WORD0
    /// MB10_32B_WORD4_L: MB10_32B_WORD4_L and MB17_16B_WORD2_L
    /// MB10_32B_WORD4_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD2_L: Message Buffer 17 WORD_16B Register
    /// MB26_8B_WORD0: Message Buffer 26 WORD_8B Register
    /// MB5_64B_WORD14_L: Message Buffer 5 WORD_64B Register
    /// WORD026: Message Buffer 26 WORD0 Register
    pub MB10_32B_WORD4_L: RWRegister<u32>,

    /// MB10_32B_WORD5_L and WORD126
    /// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB5_64B_WORD15_L
    /// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB26_8B_WORD1
    /// MB10_32B_WORD5_L: MB10_32B_WORD5_L and MB17_16B_WORD3_L
    /// MB10_32B_WORD5_L: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD3_L: Message Buffer 17 WORD_16B Register
    /// MB26_8B_WORD1: Message Buffer 26 WORD_8B Register
    /// MB5_64B_WORD15_L: Message Buffer 5 WORD_64B Register
    /// WORD126: Message Buffer 26 WORD1 Register
    pub MB10_32B_WORD5_L: RWRegister<u32>,

    /// CS27 and MB6_64B_CS_L
    /// CS27: CS27 and MB27_8B_CS
    /// CS27: CS27 and MB18_16B_CS_L
    /// CS27: CS27 and MB10_32B_WORD6_L
    /// CS27: Message Buffer 27 CS Register
    /// MB10_32B_WORD6_L: Message Buffer 10 WORD_32B Register
    /// MB18_16B_CS_L: Message Buffer 18 CS Register
    /// MB27_8B_CS: Message Buffer 27 CS Register
    /// MB6_64B_CS_L: Message Buffer 6 CS Register
    pub CS27: RWRegister<u32>,

    /// ID27 and MB6_64B_ID_L
    /// ID27: ID27 and MB27_8B_ID
    /// ID27: ID27 and MB18_16B_ID_L
    /// ID27: ID27 and MB10_32B_WORD7_L
    /// ID27: Message Buffer 27 ID Register
    /// MB10_32B_WORD7_L: Message Buffer 10 WORD_32B Register
    /// MB18_16B_ID_L: Message Buffer 18 ID Register
    /// MB27_8B_ID: Message Buffer 27 ID Register
    /// MB6_64B_ID_L: Message Buffer 6 ID Register
    pub ID27: RWRegister<u32>,

    /// MB11_32B_CS_L and WORD027
    /// MB11_32B_CS_L: MB11_32B_CS_L and MB6_64B_WORD0_L
    /// MB11_32B_CS_L: MB11_32B_CS_L and MB27_8B_WORD0
    /// MB11_32B_CS_L: MB11_32B_CS_L and MB18_16B_WORD0_L
    /// MB11_32B_CS_L: Message Buffer 11 CS Register
    /// MB18_16B_WORD0_L: Message Buffer 18 WORD_16B Register
    /// MB27_8B_WORD0: Message Buffer 27 WORD_8B Register
    /// MB6_64B_WORD0_L: Message Buffer 6 WORD_64B Register
    /// WORD027: Message Buffer 27 WORD0 Register
    pub MB11_32B_CS_L: RWRegister<u32>,

    /// MB11_32B_ID_L and WORD127
    /// MB11_32B_ID_L: MB11_32B_ID_L and MB6_64B_WORD1_L
    /// MB11_32B_ID_L: MB11_32B_ID_L and MB27_8B_WORD1
    /// MB11_32B_ID_L: MB11_32B_ID_L and MB18_16B_WORD1_L
    /// MB11_32B_ID_L: Message Buffer 11 ID Register
    /// MB18_16B_WORD1_L: Message Buffer 18 WORD_16B Register
    /// MB27_8B_WORD1: Message Buffer 27 WORD_8B Register
    /// MB6_64B_WORD1_L: Message Buffer 6 WORD_64B Register
    /// WORD127: Message Buffer 27 WORD1 Register
    pub MB11_32B_ID_L: RWRegister<u32>,

    /// CS28 and MB6_64B_WORD2_L
    /// CS28: CS28 and MB28_8B_CS
    /// CS28: CS28 and MB18_16B_WORD2_L
    /// CS28: CS28 and MB11_32B_WORD0_L
    /// CS28: Message Buffer 28 CS Register
    /// MB11_32B_WORD0_L: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD2_L: Message Buffer 18 WORD_16B Register
    /// MB28_8B_CS: Message Buffer 28 CS Register
    /// MB6_64B_WORD2_L: Message Buffer 6 WORD_64B Register
    pub CS28: RWRegister<u32>,

    /// ID28 and MB6_64B_WORD3_L
    /// ID28: ID28 and MB28_8B_ID
    /// ID28: ID28 and MB18_16B_WORD3_L
    /// ID28: ID28 and MB11_32B_WORD1_L
    /// ID28: Message Buffer 28 ID Register
    /// MB11_32B_WORD1_L: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD3_L: Message Buffer 18 WORD_16B Register
    /// MB28_8B_ID: Message Buffer 28 ID Register
    /// MB6_64B_WORD3_L: Message Buffer 6 WORD_64B Register
    pub ID28: RWRegister<u32>,

    /// MB11_32B_WORD2_L and WORD028
    /// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB6_64B_WORD4_L
    /// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB28_8B_WORD0
    /// MB11_32B_WORD2_L: MB11_32B_WORD2_L and MB19_16B_CS_L
    /// MB11_32B_WORD2_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_CS_L: Message Buffer 19 CS Register
    /// MB28_8B_WORD0: Message Buffer 28 WORD_8B Register
    /// MB6_64B_WORD4_L: Message Buffer 6 WORD_64B Register
    /// WORD028: Message Buffer 28 WORD0 Register
    pub MB11_32B_WORD2_L: RWRegister<u32>,

    /// MB11_32B_WORD3_L and WORD128
    /// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB6_64B_WORD5_L
    /// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB28_8B_WORD1
    /// MB11_32B_WORD3_L: MB11_32B_WORD3_L and MB19_16B_ID_L
    /// MB11_32B_WORD3_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_ID_L: Message Buffer 19 ID Register
    /// MB28_8B_WORD1: Message Buffer 28 WORD_8B Register
    /// MB6_64B_WORD5_L: Message Buffer 6 WORD_64B Register
    /// WORD128: Message Buffer 28 WORD1 Register
    pub MB11_32B_WORD3_L: RWRegister<u32>,

    /// CS29 and MB6_64B_WORD6_L
    /// CS29: CS29 and MB29_8B_CS
    /// CS29: CS29 and MB19_16B_WORD0_L
    /// CS29: CS29 and MB11_32B_WORD4_L
    /// CS29: Message Buffer 29 CS Register
    /// MB11_32B_WORD4_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD0_L: Message Buffer 19 WORD_16B Register
    /// MB29_8B_CS: Message Buffer 29 CS Register
    /// MB6_64B_WORD6_L: Message Buffer 6 WORD_64B Register
    pub CS29: RWRegister<u32>,

    /// ID29 and MB6_64B_WORD7_L
    /// ID29: ID29 and MB29_8B_ID
    /// ID29: ID29 and MB19_16B_WORD1_L
    /// ID29: ID29 and MB11_32B_WORD5_L
    /// ID29: Message Buffer 29 ID Register
    /// MB11_32B_WORD5_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD1_L: Message Buffer 19 WORD_16B Register
    /// MB29_8B_ID: Message Buffer 29 ID Register
    /// MB6_64B_WORD7_L: Message Buffer 6 WORD_64B Register
    pub ID29: RWRegister<u32>,

    /// MB11_32B_WORD6_L and WORD029
    /// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB6_64B_WORD8_L
    /// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB29_8B_WORD0
    /// MB11_32B_WORD6_L: MB11_32B_WORD6_L and MB19_16B_WORD2_L
    /// MB11_32B_WORD6_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD2_L: Message Buffer 19 WORD_16B Register
    /// MB29_8B_WORD0: Message Buffer 29 WORD_8B Register
    /// MB6_64B_WORD8_L: Message Buffer 6 WORD_64B Register
    /// WORD029: Message Buffer 29 WORD0 Register
    pub MB11_32B_WORD6_L: RWRegister<u32>,

    /// MB11_32B_WORD7_L and WORD129
    /// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB6_64B_WORD9_L
    /// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB29_8B_WORD1
    /// MB11_32B_WORD7_L: MB11_32B_WORD7_L and MB19_16B_WORD3_L
    /// MB11_32B_WORD7_L: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD3_L: Message Buffer 19 WORD_16B Register
    /// MB29_8B_WORD1: Message Buffer 29 WORD_8B Register
    /// MB6_64B_WORD9_L: Message Buffer 6 WORD_64B Register
    /// WORD129: Message Buffer 29 WORD1 Register
    pub MB11_32B_WORD7_L: RWRegister<u32>,

    /// CS30 and MB6_64B_WORD10_L
    /// CS30: CS30 and MB30_8B_CS
    /// CS30: CS30 and MB20_16B_CS_L
    /// CS30: Message Buffer 30 CS Register
    /// MB20_16B_CS_L: Message Buffer 20 CS Register
    /// MB30_8B_CS: Message Buffer 30 CS Register
    /// MB6_64B_WORD10_L: Message Buffer 6 WORD_64B Register
    pub CS30: RWRegister<u32>,

    /// ID30 and MB6_64B_WORD11_L
    /// ID30: ID30 and MB30_8B_ID
    /// ID30: ID30 and MB20_16B_ID_L
    /// ID30: Message Buffer 30 ID Register
    /// MB20_16B_ID_L: Message Buffer 20 ID Register
    /// MB30_8B_ID: Message Buffer 30 ID Register
    /// MB6_64B_WORD11_L: Message Buffer 6 WORD_64B Register
    pub ID30: RWRegister<u32>,

    /// MB20_16B_WORD0_L and WORD030
    /// MB20_16B_WORD0_L: MB20_16B_WORD0_L and MB6_64B_WORD12_L
    /// MB20_16B_WORD0_L: MB20_16B_WORD0_L and MB30_8B_WORD0
    /// MB20_16B_WORD0_L: Message Buffer 20 WORD_16B Register
    /// MB30_8B_WORD0: Message Buffer 30 WORD_8B Register
    /// MB6_64B_WORD12_L: Message Buffer 6 WORD_64B Register
    /// WORD030: Message Buffer 30 WORD0 Register
    pub MB20_16B_WORD0_L: RWRegister<u32>,

    /// MB20_16B_WORD1_L and WORD130
    /// MB20_16B_WORD1_L: MB20_16B_WORD1_L and MB6_64B_WORD13_L
    /// MB20_16B_WORD1_L: MB20_16B_WORD1_L and MB30_8B_WORD1
    /// MB20_16B_WORD1_L: Message Buffer 20 WORD_16B Register
    /// MB30_8B_WORD1: Message Buffer 30 WORD_8B Register
    /// MB6_64B_WORD13_L: Message Buffer 6 WORD_64B Register
    /// WORD130: Message Buffer 30 WORD1 Register
    pub MB20_16B_WORD1_L: RWRegister<u32>,

    /// CS31 and MB6_64B_WORD14_L
    /// CS31: CS31 and MB31_8B_CS
    /// CS31: CS31 and MB20_16B_WORD2_L
    /// CS31: Message Buffer 31 CS Register
    /// MB20_16B_WORD2_L: Message Buffer 20 WORD_16B Register
    /// MB31_8B_CS: Message Buffer 31 CS Register
    /// MB6_64B_WORD14_L: Message Buffer 6 WORD_64B Register
    pub CS31: RWRegister<u32>,

    /// ID31 and MB6_64B_WORD15_L
    /// ID31: ID31 and MB31_8B_ID
    /// ID31: ID31 and MB20_16B_WORD3_L
    /// ID31: Message Buffer 31 ID Register
    /// MB20_16B_WORD3_L: Message Buffer 20 WORD_16B Register
    /// MB31_8B_ID: Message Buffer 31 ID Register
    /// MB6_64B_WORD15_L: Message Buffer 6 WORD_64B Register
    pub ID31: RWRegister<u32>,

    /// MB31_8B_WORD0 and WORD031
    /// MB31_8B_WORD0: Message Buffer 31 WORD_8B Register
    /// WORD031: Message Buffer 31 WORD0 Register
    pub MB31_8B_WORD0: RWRegister<u32>,

    /// MB31_8B_WORD1 and WORD131
    /// MB31_8B_WORD1: Message Buffer 31 WORD_8B Register
    /// WORD131: Message Buffer 31 WORD1 Register
    pub MB31_8B_WORD1: RWRegister<u32>,

    /// CS32 and MB32_8B_CS
    /// CS32: CS32 and MB0_64B_CS_H
    /// CS32: CS32 and MB0_32B_CS_H
    /// CS32: CS32 and MB0_16B_CS_H
    /// CS32: Message Buffer 32 CS Register
    /// MB0_16B_CS_H: Message Buffer 0 CS Register
    /// MB0_32B_CS_H: Message Buffer 0 CS Register
    /// MB0_64B_CS_H: Message Buffer 0 CS Register
    /// MB32_8B_CS: Message Buffer 32 CS Register
    pub CS32: RWRegister<u32>,

    /// ID32 and MB32_8B_ID
    /// ID32: ID32 and MB0_64B_ID_H
    /// ID32: ID32 and MB0_32B_ID_H
    /// ID32: ID32 and MB0_16B_ID_H
    /// ID32: Message Buffer 32 ID Register
    /// MB0_16B_ID_H: Message Buffer 0 ID Register
    /// MB0_32B_ID_H: Message Buffer 0 ID Register
    /// MB0_64B_ID_H: Message Buffer 0 ID Register
    /// MB32_8B_ID: Message Buffer 32 ID Register
    pub ID32: RWRegister<u32>,

    /// MB0_16B_WORD0_H and WORD032
    /// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB32_8B_WORD0
    /// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB0_64B_WORD0_H
    /// MB0_16B_WORD0_H: MB0_16B_WORD0_H and MB0_32B_WORD0_H
    /// MB0_16B_WORD0_H: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD0_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD0_H: Message Buffer 0 WORD_64B Register
    /// MB32_8B_WORD0: Message Buffer 32 WORD_8B Register
    /// WORD032: Message Buffer 32 WORD0 Register
    pub MB0_16B_WORD0_H: RWRegister<u32>,

    /// MB0_16B_WORD1_H and WORD132
    /// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB32_8B_WORD1
    /// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB0_64B_WORD1_H
    /// MB0_16B_WORD1_H: MB0_16B_WORD1_H and MB0_32B_WORD1_H
    /// MB0_16B_WORD1_H: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD1_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD1_H: Message Buffer 0 WORD_64B Register
    /// MB32_8B_WORD1: Message Buffer 32 WORD_8B Register
    /// WORD132: Message Buffer 32 WORD1 Register
    pub MB0_16B_WORD1_H: RWRegister<u32>,

    /// CS33 and MB33_8B_CS
    /// CS33: CS33 and MB0_64B_WORD2_H
    /// CS33: CS33 and MB0_32B_WORD2_H
    /// CS33: CS33 and MB0_16B_WORD2_H
    /// CS33: Message Buffer 33 CS Register
    /// MB0_16B_WORD2_H: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD2_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD2_H: Message Buffer 0 WORD_64B Register
    /// MB33_8B_CS: Message Buffer 33 CS Register
    pub CS33: RWRegister<u32>,

    /// ID33 and MB33_8B_ID
    /// ID33: ID33 and MB0_64B_WORD3_H
    /// ID33: ID33 and MB0_32B_WORD3_H
    /// ID33: ID33 and MB0_16B_WORD3_H
    /// ID33: Message Buffer 33 ID Register
    /// MB0_16B_WORD3_H: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD3_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD3_H: Message Buffer 0 WORD_64B Register
    /// MB33_8B_ID: Message Buffer 33 ID Register
    pub ID33: RWRegister<u32>,

    /// MB0_32B_WORD4_H and WORD033
    /// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB33_8B_WORD0
    /// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB1_16B_CS_H
    /// MB0_32B_WORD4_H: MB0_32B_WORD4_H and MB0_64B_WORD4_H
    /// MB0_32B_WORD4_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD4_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_CS_H: Message Buffer 1 CS Register
    /// MB33_8B_WORD0: Message Buffer 33 WORD_8B Register
    /// WORD033: Message Buffer 33 WORD0 Register
    pub MB0_32B_WORD4_H: RWRegister<u32>,

    /// MB0_32B_WORD5_H and WORD133
    /// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB33_8B_WORD1
    /// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB1_16B_ID_H
    /// MB0_32B_WORD5_H: MB0_32B_WORD5_H and MB0_64B_WORD5_H
    /// MB0_32B_WORD5_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD5_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_ID_H: Message Buffer 1 ID Register
    /// MB33_8B_WORD1: Message Buffer 33 WORD_8B Register
    /// WORD133: Message Buffer 33 WORD1 Register
    pub MB0_32B_WORD5_H: RWRegister<u32>,

    /// CS34 and MB34_8B_CS
    /// CS34: CS34 and MB1_16B_WORD0_H
    /// CS34: CS34 and MB0_64B_WORD6_H
    /// CS34: CS34 and MB0_32B_WORD6_H
    /// CS34: Message Buffer 34 CS Register
    /// MB0_32B_WORD6_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD6_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD0_H: Message Buffer 1 WORD_16B Register
    /// MB34_8B_CS: Message Buffer 34 CS Register
    pub CS34: RWRegister<u32>,

    /// ID34 and MB34_8B_ID
    /// ID34: ID34 and MB1_16B_WORD1_H
    /// ID34: ID34 and MB0_64B_WORD7_H
    /// ID34: ID34 and MB0_32B_WORD7_H
    /// ID34: Message Buffer 34 ID Register
    /// MB0_32B_WORD7_H: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD7_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD1_H: Message Buffer 1 WORD_16B Register
    /// MB34_8B_ID: Message Buffer 34 ID Register
    pub ID34: RWRegister<u32>,

    /// MB0_64B_WORD8_H and WORD034
    /// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB34_8B_WORD0
    /// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB1_32B_CS_H
    /// MB0_64B_WORD8_H: MB0_64B_WORD8_H and MB1_16B_WORD2_H
    /// MB0_64B_WORD8_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD2_H: Message Buffer 1 WORD_16B Register
    /// MB1_32B_CS_H: Message Buffer 1 CS Register
    /// MB34_8B_WORD0: Message Buffer 34 WORD_8B Register
    /// WORD034: Message Buffer 34 WORD0 Register
    pub MB0_64B_WORD8_H: RWRegister<u32>,

    /// MB0_64B_WORD9_H and WORD134
    /// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB34_8B_WORD1
    /// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB1_32B_ID_H
    /// MB0_64B_WORD9_H: MB0_64B_WORD9_H and MB1_16B_WORD3_H
    /// MB0_64B_WORD9_H: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD3_H: Message Buffer 1 WORD_16B Register
    /// MB1_32B_ID_H: Message Buffer 1 ID Register
    /// MB34_8B_WORD1: Message Buffer 34 WORD_8B Register
    /// WORD134: Message Buffer 34 WORD1 Register
    pub MB0_64B_WORD9_H: RWRegister<u32>,

    /// CS35 and MB35_8B_CS
    /// CS35: CS35 and MB2_16B_CS_H
    /// CS35: CS35 and MB1_32B_WORD0_H
    /// CS35: CS35 and MB0_64B_WORD10_H
    /// CS35: Message Buffer 35 CS Register
    /// MB0_64B_WORD10_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD0_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_CS_H: Message Buffer 2 CS Register
    /// MB35_8B_CS: Message Buffer 35 CS Register
    pub CS35: RWRegister<u32>,

    /// ID35 and MB35_8B_ID
    /// ID35: ID35 and MB2_16B_ID_H
    /// ID35: ID35 and MB1_32B_WORD1_H
    /// ID35: ID35 and MB0_64B_WORD11_H
    /// ID35: Message Buffer 35 ID Register
    /// MB0_64B_WORD11_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD1_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_ID_H: Message Buffer 2 ID Register
    /// MB35_8B_ID: Message Buffer 35 ID Register
    pub ID35: RWRegister<u32>,

    /// MB0_64B_WORD12_H and WORD035
    /// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB35_8B_WORD0
    /// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB2_16B_WORD0_H
    /// MB0_64B_WORD12_H: MB0_64B_WORD12_H and MB1_32B_WORD2_H
    /// MB0_64B_WORD12_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD2_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD0_H: Message Buffer 2 WORD_16B Register
    /// MB35_8B_WORD0: Message Buffer 35 WORD_8B Register
    /// WORD035: Message Buffer 35 WORD0 Register
    pub MB0_64B_WORD12_H: RWRegister<u32>,

    /// MB0_64B_WORD13_H and WORD135
    /// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB35_8B_WORD1
    /// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB2_16B_WORD1_H
    /// MB0_64B_WORD13_H: MB0_64B_WORD13_H and MB1_32B_WORD3_H
    /// MB0_64B_WORD13_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD3_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD1_H: Message Buffer 2 WORD_16B Register
    /// MB35_8B_WORD1: Message Buffer 35 WORD_8B Register
    /// WORD135: Message Buffer 35 WORD1 Register
    pub MB0_64B_WORD13_H: RWRegister<u32>,

    /// CS36 and MB36_8B_CS
    /// CS36: CS36 and MB2_16B_WORD2_H
    /// CS36: CS36 and MB1_32B_WORD4_H
    /// CS36: CS36 and MB0_64B_WORD14_H
    /// CS36: Message Buffer 36 CS Register
    /// MB0_64B_WORD14_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD4_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD2_H: Message Buffer 2 WORD_16B Register
    /// MB36_8B_CS: Message Buffer 36 CS Register
    pub CS36: RWRegister<u32>,

    /// ID36 and MB36_8B_ID
    /// ID36: ID36 and MB2_16B_WORD3_H
    /// ID36: ID36 and MB1_32B_WORD5_H
    /// ID36: ID36 and MB0_64B_WORD15_H
    /// ID36: Message Buffer 36 ID Register
    /// MB0_64B_WORD15_H: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD5_H: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD3_H: Message Buffer 2 WORD_16B Register
    /// MB36_8B_ID: Message Buffer 36 ID Register
    pub ID36: RWRegister<u32>,

    /// MB1_32B_WORD6_H and WORD036
    /// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB3_16B_CS_H
    /// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB36_8B_WORD0
    /// MB1_32B_WORD6_H: MB1_32B_WORD6_H and MB1_64B_CS_H
    /// MB1_32B_WORD6_H: Message Buffer 1 WORD_32B Register
    /// MB1_64B_CS_H: Message Buffer 1 CS Register
    /// MB36_8B_WORD0: Message Buffer 36 WORD_8B Register
    /// MB3_16B_CS_H: Message Buffer 3 CS Register
    /// WORD036: Message Buffer 36 WORD0 Register
    pub MB1_32B_WORD6_H: RWRegister<u32>,

    /// MB1_32B_WORD7_H and WORD136
    /// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB3_16B_ID_H
    /// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB36_8B_WORD1
    /// MB1_32B_WORD7_H: MB1_32B_WORD7_H and MB1_64B_ID_H
    /// MB1_32B_WORD7_H: Message Buffer 1 WORD_32B Register
    /// MB1_64B_ID_H: Message Buffer 1 ID Register
    /// MB36_8B_WORD1: Message Buffer 36 WORD_8B Register
    /// MB3_16B_ID_H: Message Buffer 3 ID Register
    /// WORD136: Message Buffer 36 WORD1 Register
    pub MB1_32B_WORD7_H: RWRegister<u32>,

    /// CS37 and MB3_16B_WORD0_H
    /// CS37: CS37 and MB37_8B_CS
    /// CS37: CS37 and MB2_32B_CS_H
    /// CS37: CS37 and MB1_64B_WORD0_H
    /// CS37: Message Buffer 37 CS Register
    /// MB1_64B_WORD0_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_CS_H: Message Buffer 2 CS Register
    /// MB37_8B_CS: Message Buffer 37 CS Register
    /// MB3_16B_WORD0_H: Message Buffer 3 WORD_16B Register
    pub CS37: RWRegister<u32>,

    /// ID37 and MB3_16B_WORD1_H
    /// ID37: ID37 and MB37_8B_ID
    /// ID37: ID37 and MB2_32B_ID_H
    /// ID37: ID37 and MB1_64B_WORD1_H
    /// ID37: Message Buffer 37 ID Register
    /// MB1_64B_WORD1_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_ID_H: Message Buffer 2 ID Register
    /// MB37_8B_ID: Message Buffer 37 ID Register
    /// MB3_16B_WORD1_H: Message Buffer 3 WORD_16B Register
    pub ID37: RWRegister<u32>,

    /// MB1_64B_WORD2_H and WORD037
    /// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB3_16B_WORD2_H
    /// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB37_8B_WORD0
    /// MB1_64B_WORD2_H: MB1_64B_WORD2_H and MB2_32B_WORD0_H
    /// MB1_64B_WORD2_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD0_H: Message Buffer 2 WORD_32B Register
    /// MB37_8B_WORD0: Message Buffer 37 WORD_8B Register
    /// MB3_16B_WORD2_H: Message Buffer 3 WORD_16B Register
    /// WORD037: Message Buffer 37 WORD0 Register
    pub MB1_64B_WORD2_H: RWRegister<u32>,

    /// MB1_64B_WORD3_H and WORD137
    /// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB3_16B_WORD3_H
    /// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB37_8B_WORD1
    /// MB1_64B_WORD3_H: MB1_64B_WORD3_H and MB2_32B_WORD1_H
    /// MB1_64B_WORD3_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD1_H: Message Buffer 2 WORD_32B Register
    /// MB37_8B_WORD1: Message Buffer 37 WORD_8B Register
    /// MB3_16B_WORD3_H: Message Buffer 3 WORD_16B Register
    /// WORD137: Message Buffer 37 WORD1 Register
    pub MB1_64B_WORD3_H: RWRegister<u32>,

    /// CS38 and MB4_16B_CS_H
    /// CS38: CS38 and MB38_8B_CS
    /// CS38: CS38 and MB2_32B_WORD2_H
    /// CS38: CS38 and MB1_64B_WORD4_H
    /// CS38: Message Buffer 38 CS Register
    /// MB1_64B_WORD4_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD2_H: Message Buffer 2 WORD_32B Register
    /// MB38_8B_CS: Message Buffer 38 CS Register
    /// MB4_16B_CS_H: Message Buffer 4 CS Register
    pub CS38: RWRegister<u32>,

    /// ID38 and MB4_16B_ID_H
    /// ID38: ID38 and MB38_8B_ID
    /// ID38: ID38 and MB2_32B_WORD3_H
    /// ID38: ID38 and MB1_64B_WORD5_H
    /// ID38: Message Buffer 38 ID Register
    /// MB1_64B_WORD5_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD3_H: Message Buffer 2 WORD_32B Register
    /// MB38_8B_ID: Message Buffer 38 ID Register
    /// MB4_16B_ID_H: Message Buffer 4 ID Register
    pub ID38: RWRegister<u32>,

    /// MB1_64B_WORD6_H and WORD038
    /// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB4_16B_WORD0_H
    /// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB38_8B_WORD0
    /// MB1_64B_WORD6_H: MB1_64B_WORD6_H and MB2_32B_WORD4_H
    /// MB1_64B_WORD6_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD4_H: Message Buffer 2 WORD_32B Register
    /// MB38_8B_WORD0: Message Buffer 38 WORD_8B Register
    /// MB4_16B_WORD0_H: Message Buffer 4 WORD_16B Register
    /// WORD038: Message Buffer 38 WORD0 Register
    pub MB1_64B_WORD6_H: RWRegister<u32>,

    /// MB1_64B_WORD7_H and WORD138
    /// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB4_16B_WORD1_H
    /// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB38_8B_WORD1
    /// MB1_64B_WORD7_H: MB1_64B_WORD7_H and MB2_32B_WORD5_H
    /// MB1_64B_WORD7_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD5_H: Message Buffer 2 WORD_32B Register
    /// MB38_8B_WORD1: Message Buffer 38 WORD_8B Register
    /// MB4_16B_WORD1_H: Message Buffer 4 WORD_16B Register
    /// WORD138: Message Buffer 38 WORD1 Register
    pub MB1_64B_WORD7_H: RWRegister<u32>,

    /// CS39 and MB4_16B_WORD2_H
    /// CS39: CS39 and MB39_8B_CS
    /// CS39: CS39 and MB2_32B_WORD6_H
    /// CS39: CS39 and MB1_64B_WORD8_H
    /// CS39: Message Buffer 39 CS Register
    /// MB1_64B_WORD8_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD6_H: Message Buffer 2 WORD_32B Register
    /// MB39_8B_CS: Message Buffer 39 CS Register
    /// MB4_16B_WORD2_H: Message Buffer 4 WORD_16B Register
    pub CS39: RWRegister<u32>,

    /// ID39 and MB4_16B_WORD3_H
    /// ID39: ID39 and MB39_8B_ID
    /// ID39: ID39 and MB2_32B_WORD7_H
    /// ID39: ID39 and MB1_64B_WORD9_H
    /// ID39: Message Buffer 39 ID Register
    /// MB1_64B_WORD9_H: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD7_H: Message Buffer 2 WORD_32B Register
    /// MB39_8B_ID: Message Buffer 39 ID Register
    /// MB4_16B_WORD3_H: Message Buffer 4 WORD_16B Register
    pub ID39: RWRegister<u32>,

    /// MB1_64B_WORD10_H and WORD039
    /// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB5_16B_CS_H
    /// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB3_32B_CS_H
    /// MB1_64B_WORD10_H: MB1_64B_WORD10_H and MB39_8B_WORD0
    /// MB1_64B_WORD10_H: Message Buffer 1 WORD_64B Register
    /// MB39_8B_WORD0: Message Buffer 39 WORD_8B Register
    /// MB3_32B_CS_H: Message Buffer 3 CS Register
    /// MB5_16B_CS_H: Message Buffer 5 CS Register
    /// WORD039: Message Buffer 39 WORD0 Register
    pub MB1_64B_WORD10_H: RWRegister<u32>,

    /// MB1_64B_WORD11_H and WORD139
    /// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB5_16B_ID_H
    /// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB3_32B_ID_H
    /// MB1_64B_WORD11_H: MB1_64B_WORD11_H and MB39_8B_WORD1
    /// MB1_64B_WORD11_H: Message Buffer 1 WORD_64B Register
    /// MB39_8B_WORD1: Message Buffer 39 WORD_8B Register
    /// MB3_32B_ID_H: Message Buffer 3 ID Register
    /// MB5_16B_ID_H: Message Buffer 5 ID Register
    /// WORD139: Message Buffer 39 WORD1 Register
    pub MB1_64B_WORD11_H: RWRegister<u32>,

    /// CS40 and MB5_16B_WORD0_H
    /// CS40: CS40 and MB40_8B_CS
    /// CS40: CS40 and MB3_32B_WORD0_H
    /// CS40: CS40 and MB1_64B_WORD12_H
    /// CS40: Message Buffer 40 CS Register
    /// MB1_64B_WORD12_H: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD0_H: Message Buffer 3 WORD_32B Register
    /// MB40_8B_CS: Message Buffer 40 CS Register
    /// MB5_16B_WORD0_H: Message Buffer 5 WORD_16B Register
    pub CS40: RWRegister<u32>,

    /// ID40 and MB5_16B_WORD1_H
    /// ID40: ID40 and MB40_8B_ID
    /// ID40: ID40 and MB3_32B_WORD1_H
    /// ID40: ID40 and MB1_64B_WORD13_H
    /// ID40: Message Buffer 40 ID Register
    /// MB1_64B_WORD13_H: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD1_H: Message Buffer 3 WORD_32B Register
    /// MB40_8B_ID: Message Buffer 40 ID Register
    /// MB5_16B_WORD1_H: Message Buffer 5 WORD_16B Register
    pub ID40: RWRegister<u32>,

    /// MB1_64B_WORD14_H and WORD040
    /// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB5_16B_WORD2_H
    /// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB40_8B_WORD0
    /// MB1_64B_WORD14_H: MB1_64B_WORD14_H and MB3_32B_WORD2_H
    /// MB1_64B_WORD14_H: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD2_H: Message Buffer 3 WORD_32B Register
    /// MB40_8B_WORD0: Message Buffer 40 WORD_8B Register
    /// MB5_16B_WORD2_H: Message Buffer 5 WORD_16B Register
    /// WORD040: Message Buffer 40 WORD0 Register
    pub MB1_64B_WORD14_H: RWRegister<u32>,

    /// MB1_64B_WORD15_H and WORD140
    /// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB5_16B_WORD3_H
    /// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB40_8B_WORD1
    /// MB1_64B_WORD15_H: MB1_64B_WORD15_H and MB3_32B_WORD3_H
    /// MB1_64B_WORD15_H: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD3_H: Message Buffer 3 WORD_32B Register
    /// MB40_8B_WORD1: Message Buffer 40 WORD_8B Register
    /// MB5_16B_WORD3_H: Message Buffer 5 WORD_16B Register
    /// WORD140: Message Buffer 40 WORD1 Register
    pub MB1_64B_WORD15_H: RWRegister<u32>,

    /// CS41 and MB6_16B_CS_H
    /// CS41: CS41 and MB41_8B_CS
    /// CS41: CS41 and MB3_32B_WORD4_H
    /// CS41: CS41 and MB2_64B_CS_H
    /// CS41: Message Buffer 41 CS Register
    /// MB2_64B_CS_H: Message Buffer 2 CS Register
    /// MB3_32B_WORD4_H: Message Buffer 3 WORD_32B Register
    /// MB41_8B_CS: Message Buffer 41 CS Register
    /// MB6_16B_CS_H: Message Buffer 6 CS Register
    pub CS41: RWRegister<u32>,

    /// ID41 and MB6_16B_ID_H
    /// ID41: ID41 and MB41_8B_ID
    /// ID41: ID41 and MB3_32B_WORD5_H
    /// ID41: ID41 and MB2_64B_ID_H
    /// ID41: Message Buffer 41 ID Register
    /// MB2_64B_ID_H: Message Buffer 2 ID Register
    /// MB3_32B_WORD5_H: Message Buffer 3 WORD_32B Register
    /// MB41_8B_ID: Message Buffer 41 ID Register
    /// MB6_16B_ID_H: Message Buffer 6 ID Register
    pub ID41: RWRegister<u32>,

    /// MB2_64B_WORD0_H and WORD041
    /// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB6_16B_WORD0_H
    /// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB41_8B_WORD0
    /// MB2_64B_WORD0_H: MB2_64B_WORD0_H and MB3_32B_WORD6_H
    /// MB2_64B_WORD0_H: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD6_H: Message Buffer 3 WORD_32B Register
    /// MB41_8B_WORD0: Message Buffer 41 WORD_8B Register
    /// MB6_16B_WORD0_H: Message Buffer 6 WORD_16B Register
    /// WORD041: Message Buffer 41 WORD0 Register
    pub MB2_64B_WORD0_H: RWRegister<u32>,

    /// MB2_64B_WORD1_H and WORD141
    /// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB6_16B_WORD1_H
    /// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB41_8B_WORD1
    /// MB2_64B_WORD1_H: MB2_64B_WORD1_H and MB3_32B_WORD7_H
    /// MB2_64B_WORD1_H: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD7_H: Message Buffer 3 WORD_32B Register
    /// MB41_8B_WORD1: Message Buffer 41 WORD_8B Register
    /// MB6_16B_WORD1_H: Message Buffer 6 WORD_16B Register
    /// WORD141: Message Buffer 41 WORD1 Register
    pub MB2_64B_WORD1_H: RWRegister<u32>,

    /// CS42 and MB6_16B_WORD2_H
    /// CS42: CS42 and MB4_32B_CS_H
    /// CS42: CS42 and MB42_8B_CS
    /// CS42: CS42 and MB2_64B_WORD2_H
    /// CS42: Message Buffer 42 CS Register
    /// MB2_64B_WORD2_H: Message Buffer 2 WORD_64B Register
    /// MB42_8B_CS: Message Buffer 42 CS Register
    /// MB4_32B_CS_H: Message Buffer 4 CS Register
    /// MB6_16B_WORD2_H: Message Buffer 6 WORD_16B Register
    pub CS42: RWRegister<u32>,

    /// ID42 and MB6_16B_WORD3_H
    /// ID42: ID42 and MB4_32B_ID_H
    /// ID42: ID42 and MB42_8B_ID
    /// ID42: ID42 and MB2_64B_WORD3_H
    /// ID42: Message Buffer 42 ID Register
    /// MB2_64B_WORD3_H: Message Buffer 2 WORD_64B Register
    /// MB42_8B_ID: Message Buffer 42 ID Register
    /// MB4_32B_ID_H: Message Buffer 4 ID Register
    /// MB6_16B_WORD3_H: Message Buffer 6 WORD_16B Register
    pub ID42: RWRegister<u32>,

    /// MB2_64B_WORD4_H and WORD042
    /// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB7_16B_CS_H
    /// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB4_32B_WORD0_H
    /// MB2_64B_WORD4_H: MB2_64B_WORD4_H and MB42_8B_WORD0
    /// MB2_64B_WORD4_H: Message Buffer 2 WORD_64B Register
    /// MB42_8B_WORD0: Message Buffer 42 WORD_8B Register
    /// MB4_32B_WORD0_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_CS_H: Message Buffer 7 CS Register
    /// WORD042: Message Buffer 42 WORD0 Register
    pub MB2_64B_WORD4_H: RWRegister<u32>,

    /// MB2_64B_WORD5_H and WORD142
    /// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB7_16B_ID_H
    /// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB4_32B_WORD1_H
    /// MB2_64B_WORD5_H: MB2_64B_WORD5_H and MB42_8B_WORD1
    /// MB2_64B_WORD5_H: Message Buffer 2 WORD_64B Register
    /// MB42_8B_WORD1: Message Buffer 42 WORD_8B Register
    /// MB4_32B_WORD1_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_ID_H: Message Buffer 7 ID Register
    /// WORD142: Message Buffer 42 WORD1 Register
    pub MB2_64B_WORD5_H: RWRegister<u32>,

    /// CS43 and MB7_16B_WORD0_H
    /// CS43: CS43 and MB4_32B_WORD2_H
    /// CS43: CS43 and MB43_8B_CS
    /// CS43: CS43 and MB2_64B_WORD6_H
    /// CS43: Message Buffer 43 CS Register
    /// MB2_64B_WORD6_H: Message Buffer 2 WORD_64B Register
    /// MB43_8B_CS: Message Buffer 43 CS Register
    /// MB4_32B_WORD2_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD0_H: Message Buffer 7 WORD_16B Register
    pub CS43: RWRegister<u32>,

    /// ID43 and MB7_16B_WORD1_H
    /// ID43: ID43 and MB4_32B_WORD3_H
    /// ID43: ID43 and MB43_8B_ID
    /// ID43: ID43 and MB2_64B_WORD7_H
    /// ID43: Message Buffer 43 ID Register
    /// MB2_64B_WORD7_H: Message Buffer 2 WORD_64B Register
    /// MB43_8B_ID: Message Buffer 43 ID Register
    /// MB4_32B_WORD3_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD1_H: Message Buffer 7 WORD_16B Register
    pub ID43: RWRegister<u32>,

    /// MB2_64B_WORD8_H and WORD043
    /// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB7_16B_WORD2_H
    /// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB4_32B_WORD4_H
    /// MB2_64B_WORD8_H: MB2_64B_WORD8_H and MB43_8B_WORD0
    /// MB2_64B_WORD8_H: Message Buffer 2 WORD_64B Register
    /// MB43_8B_WORD0: Message Buffer 43 WORD_8B Register
    /// MB4_32B_WORD4_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD2_H: Message Buffer 7 WORD_16B Register
    /// WORD043: Message Buffer 43 WORD0 Register
    pub MB2_64B_WORD8_H: RWRegister<u32>,

    /// MB2_64B_WORD9_H and WORD143
    /// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB7_16B_WORD3_H
    /// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB4_32B_WORD5_H
    /// MB2_64B_WORD9_H: MB2_64B_WORD9_H and MB43_8B_WORD1
    /// MB2_64B_WORD9_H: Message Buffer 2 WORD_64B Register
    /// MB43_8B_WORD1: Message Buffer 43 WORD_8B Register
    /// MB4_32B_WORD5_H: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD3_H: Message Buffer 7 WORD_16B Register
    /// WORD143: Message Buffer 43 WORD1 Register
    pub MB2_64B_WORD9_H: RWRegister<u32>,

    /// CS44 and MB8_16B_CS_H
    /// CS44: CS44 and MB4_32B_WORD6_H
    /// CS44: CS44 and MB44_8B_CS
    /// CS44: CS44 and MB2_64B_WORD10_H
    /// CS44: Message Buffer 44 CS Register
    /// MB2_64B_WORD10_H: Message Buffer 2 WORD_64B Register
    /// MB44_8B_CS: Message Buffer 44 CS Register
    /// MB4_32B_WORD6_H: Message Buffer 4 WORD_32B Register
    /// MB8_16B_CS_H: Message Buffer 8 CS Register
    pub CS44: RWRegister<u32>,

    /// ID44 and MB8_16B_ID_H
    /// ID44: ID44 and MB4_32B_WORD7_H
    /// ID44: ID44 and MB44_8B_ID
    /// ID44: ID44 and MB2_64B_WORD11_H
    /// ID44: Message Buffer 44 ID Register
    /// MB2_64B_WORD11_H: Message Buffer 2 WORD_64B Register
    /// MB44_8B_ID: Message Buffer 44 ID Register
    /// MB4_32B_WORD7_H: Message Buffer 4 WORD_32B Register
    /// MB8_16B_ID_H: Message Buffer 8 ID Register
    pub ID44: RWRegister<u32>,

    /// MB2_64B_WORD12_H and WORD044
    /// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB8_16B_WORD0_H
    /// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB5_32B_CS_H
    /// MB2_64B_WORD12_H: MB2_64B_WORD12_H and MB44_8B_WORD0
    /// MB2_64B_WORD12_H: Message Buffer 2 WORD_64B Register
    /// MB44_8B_WORD0: Message Buffer 44 WORD_8B Register
    /// MB5_32B_CS_H: Message Buffer 5 CS Register
    /// MB8_16B_WORD0_H: Message Buffer 8 WORD_16B Register
    /// WORD044: Message Buffer 44 WORD0 Register
    pub MB2_64B_WORD12_H: RWRegister<u32>,

    /// MB2_64B_WORD13_H and WORD144
    /// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB8_16B_WORD1_H
    /// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB5_32B_ID_H
    /// MB2_64B_WORD13_H: MB2_64B_WORD13_H and MB44_8B_WORD1
    /// MB2_64B_WORD13_H: Message Buffer 2 WORD_64B Register
    /// MB44_8B_WORD1: Message Buffer 44 WORD_8B Register
    /// MB5_32B_ID_H: Message Buffer 5 ID Register
    /// MB8_16B_WORD1_H: Message Buffer 8 WORD_16B Register
    /// WORD144: Message Buffer 44 WORD1 Register
    pub MB2_64B_WORD13_H: RWRegister<u32>,

    /// CS45 and MB8_16B_WORD2_H
    /// CS45: CS45 and MB5_32B_WORD0_H
    /// CS45: CS45 and MB45_8B_CS
    /// CS45: CS45 and MB2_64B_WORD14_H
    /// CS45: Message Buffer 45 CS Register
    /// MB2_64B_WORD14_H: Message Buffer 2 WORD_64B Register
    /// MB45_8B_CS: Message Buffer 45 CS Register
    /// MB5_32B_WORD0_H: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD2_H: Message Buffer 8 WORD_16B Register
    pub CS45: RWRegister<u32>,

    /// ID45 and MB8_16B_WORD3_H
    /// ID45: ID45 and MB5_32B_WORD1_H
    /// ID45: ID45 and MB45_8B_ID
    /// ID45: ID45 and MB2_64B_WORD15_H
    /// ID45: Message Buffer 45 ID Register
    /// MB2_64B_WORD15_H: Message Buffer 2 WORD_64B Register
    /// MB45_8B_ID: Message Buffer 45 ID Register
    /// MB5_32B_WORD1_H: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD3_H: Message Buffer 8 WORD_16B Register
    pub ID45: RWRegister<u32>,

    /// MB3_64B_CS_H and WORD045
    /// MB3_64B_CS_H: MB3_64B_CS_H and MB9_16B_CS_H
    /// MB3_64B_CS_H: MB3_64B_CS_H and MB5_32B_WORD2_H
    /// MB3_64B_CS_H: MB3_64B_CS_H and MB45_8B_WORD0
    /// MB3_64B_CS_H: Message Buffer 3 CS Register
    /// MB45_8B_WORD0: Message Buffer 45 WORD_8B Register
    /// MB5_32B_WORD2_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_CS_H: Message Buffer 9 CS Register
    /// WORD045: Message Buffer 45 WORD0 Register
    pub MB3_64B_CS_H: RWRegister<u32>,

    /// MB3_64B_ID_H and WORD145
    /// MB3_64B_ID_H: MB3_64B_ID_H and MB9_16B_ID_H
    /// MB3_64B_ID_H: MB3_64B_ID_H and MB5_32B_WORD3_H
    /// MB3_64B_ID_H: MB3_64B_ID_H and MB45_8B_WORD1
    /// MB3_64B_ID_H: Message Buffer 3 ID Register
    /// MB45_8B_WORD1: Message Buffer 45 WORD_8B Register
    /// MB5_32B_WORD3_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_ID_H: Message Buffer 9 ID Register
    /// WORD145: Message Buffer 45 WORD1 Register
    pub MB3_64B_ID_H: RWRegister<u32>,

    /// CS46 and MB9_16B_WORD0_H
    /// CS46: CS46 and MB5_32B_WORD4_H
    /// CS46: CS46 and MB46_8B_CS
    /// CS46: CS46 and MB3_64B_WORD0_H
    /// CS46: Message Buffer 46 CS Register
    /// MB3_64B_WORD0_H: Message Buffer 3 WORD_64B Register
    /// MB46_8B_CS: Message Buffer 46 CS Register
    /// MB5_32B_WORD4_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD0_H: Message Buffer 9 WORD_16B Register
    pub CS46: RWRegister<u32>,

    /// ID46 and MB9_16B_WORD1_H
    /// ID46: ID46 and MB5_32B_WORD5_H
    /// ID46: ID46 and MB46_8B_ID
    /// ID46: ID46 and MB3_64B_WORD1_H
    /// ID46: Message Buffer 46 ID Register
    /// MB3_64B_WORD1_H: Message Buffer 3 WORD_64B Register
    /// MB46_8B_ID: Message Buffer 46 ID Register
    /// MB5_32B_WORD5_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD1_H: Message Buffer 9 WORD_16B Register
    pub ID46: RWRegister<u32>,

    /// MB3_64B_WORD2_H and WORD046
    /// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB9_16B_WORD2_H
    /// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB5_32B_WORD6_H
    /// MB3_64B_WORD2_H: MB3_64B_WORD2_H and MB46_8B_WORD0
    /// MB3_64B_WORD2_H: Message Buffer 3 WORD_64B Register
    /// MB46_8B_WORD0: Message Buffer 46 WORD_8B Register
    /// MB5_32B_WORD6_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD2_H: Message Buffer 9 WORD_16B Register
    /// WORD046: Message Buffer 46 WORD0 Register
    pub MB3_64B_WORD2_H: RWRegister<u32>,

    /// MB3_64B_WORD3_H and WORD146
    /// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB9_16B_WORD3_H
    /// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB5_32B_WORD7_H
    /// MB3_64B_WORD3_H: MB3_64B_WORD3_H and MB46_8B_WORD1
    /// MB3_64B_WORD3_H: Message Buffer 3 WORD_64B Register
    /// MB46_8B_WORD1: Message Buffer 46 WORD_8B Register
    /// MB5_32B_WORD7_H: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD3_H: Message Buffer 9 WORD_16B Register
    /// WORD146: Message Buffer 46 WORD1 Register
    pub MB3_64B_WORD3_H: RWRegister<u32>,

    /// CS47 and MB6_32B_CS_H
    /// CS47: CS47 and MB47_8B_CS
    /// CS47: CS47 and MB3_64B_WORD4_H
    /// CS47: CS47 and MB10_16B_CS_H
    /// CS47: Message Buffer 47 CS Register
    /// MB10_16B_CS_H: Message Buffer 10 CS Register
    /// MB3_64B_WORD4_H: Message Buffer 3 WORD_64B Register
    /// MB47_8B_CS: Message Buffer 47 CS Register
    /// MB6_32B_CS_H: Message Buffer 6 CS Register
    pub CS47: RWRegister<u32>,

    /// ID47 and MB6_32B_ID_H
    /// ID47: ID47 and MB47_8B_ID
    /// ID47: ID47 and MB3_64B_WORD5_H
    /// ID47: ID47 and MB10_16B_ID_H
    /// ID47: Message Buffer 47 ID Register
    /// MB10_16B_ID_H: Message Buffer 10 ID Register
    /// MB3_64B_WORD5_H: Message Buffer 3 WORD_64B Register
    /// MB47_8B_ID: Message Buffer 47 ID Register
    /// MB6_32B_ID_H: Message Buffer 6 ID Register
    pub ID47: RWRegister<u32>,

    /// MB10_16B_WORD0_H and WORD047
    /// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB6_32B_WORD0_H
    /// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB47_8B_WORD0
    /// MB10_16B_WORD0_H: MB10_16B_WORD0_H and MB3_64B_WORD6_H
    /// MB10_16B_WORD0_H: Message Buffer 10 WORD_16B Register
    /// MB3_64B_WORD6_H: Message Buffer 3 WORD_64B Register
    /// MB47_8B_WORD0: Message Buffer 47 WORD_8B Register
    /// MB6_32B_WORD0_H: Message Buffer 6 WORD_32B Register
    /// WORD047: Message Buffer 47 WORD0 Register
    pub MB10_16B_WORD0_H: RWRegister<u32>,

    /// MB10_16B_WORD1_H and WORD147
    /// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB6_32B_WORD1_H
    /// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB47_8B_WORD1
    /// MB10_16B_WORD1_H: MB10_16B_WORD1_H and MB3_64B_WORD7_H
    /// MB10_16B_WORD1_H: Message Buffer 10 WORD_16B Register
    /// MB3_64B_WORD7_H: Message Buffer 3 WORD_64B Register
    /// MB47_8B_WORD1: Message Buffer 47 WORD_8B Register
    /// MB6_32B_WORD1_H: Message Buffer 6 WORD_32B Register
    /// WORD147: Message Buffer 47 WORD1 Register
    pub MB10_16B_WORD1_H: RWRegister<u32>,

    /// CS48 and MB6_32B_WORD2_H
    /// CS48: CS48 and MB48_8B_CS
    /// CS48: CS48 and MB3_64B_WORD8_H
    /// CS48: CS48 and MB10_16B_WORD2_H
    /// CS48: Message Buffer 48 CS Register
    /// MB10_16B_WORD2_H: Message Buffer 10 WORD_16B Register
    /// MB3_64B_WORD8_H: Message Buffer 3 WORD_64B Register
    /// MB48_8B_CS: Message Buffer 48 CS Register
    /// MB6_32B_WORD2_H: Message Buffer 6 WORD_32B Register
    pub CS48: RWRegister<u32>,

    /// ID48 and MB6_32B_WORD3_H
    /// ID48: ID48 and MB48_8B_ID
    /// ID48: ID48 and MB3_64B_WORD9_H
    /// ID48: ID48 and MB10_16B_WORD3_H
    /// ID48: Message Buffer 48 ID Register
    /// MB10_16B_WORD3_H: Message Buffer 10 WORD_16B Register
    /// MB3_64B_WORD9_H: Message Buffer 3 WORD_64B Register
    /// MB48_8B_ID: Message Buffer 48 ID Register
    /// MB6_32B_WORD3_H: Message Buffer 6 WORD_32B Register
    pub ID48: RWRegister<u32>,

    /// MB11_16B_CS_H and WORD048
    /// MB11_16B_CS_H: MB11_16B_CS_H and MB6_32B_WORD4_H
    /// MB11_16B_CS_H: MB11_16B_CS_H and MB48_8B_WORD0
    /// MB11_16B_CS_H: MB11_16B_CS_H and MB3_64B_WORD10_H
    /// MB11_16B_CS_H: Message Buffer 11 CS Register
    /// MB3_64B_WORD10_H: Message Buffer 3 WORD_64B Register
    /// MB48_8B_WORD0: Message Buffer 48 WORD_8B Register
    /// MB6_32B_WORD4_H: Message Buffer 6 WORD_32B Register
    /// WORD048: Message Buffer 48 WORD0 Register
    pub MB11_16B_CS_H: RWRegister<u32>,

    /// MB11_16B_ID_H and WORD148
    /// MB11_16B_ID_H: MB11_16B_ID_H and MB6_32B_WORD5_H
    /// MB11_16B_ID_H: MB11_16B_ID_H and MB48_8B_WORD1
    /// MB11_16B_ID_H: MB11_16B_ID_H and MB3_64B_WORD11_H
    /// MB11_16B_ID_H: Message Buffer 11 ID Register
    /// MB3_64B_WORD11_H: Message Buffer 3 WORD_64B Register
    /// MB48_8B_WORD1: Message Buffer 48 WORD_8B Register
    /// MB6_32B_WORD5_H: Message Buffer 6 WORD_32B Register
    /// WORD148: Message Buffer 48 WORD1 Register
    pub MB11_16B_ID_H: RWRegister<u32>,

    /// CS49 and MB6_32B_WORD6_H
    /// CS49: CS49 and MB49_8B_CS
    /// CS49: CS49 and MB3_64B_WORD12_H
    /// CS49: CS49 and MB11_16B_WORD0_H
    /// CS49: Message Buffer 49 CS Register
    /// MB11_16B_WORD0_H: Message Buffer 11 WORD_16B Register
    /// MB3_64B_WORD12_H: Message Buffer 3 WORD_64B Register
    /// MB49_8B_CS: Message Buffer 49 CS Register
    /// MB6_32B_WORD6_H: Message Buffer 6 WORD_32B Register
    pub CS49: RWRegister<u32>,

    /// ID49 and MB6_32B_WORD7_H
    /// ID49: ID49 and MB49_8B_ID
    /// ID49: ID49 and MB3_64B_WORD13_H
    /// ID49: ID49 and MB11_16B_WORD1_H
    /// ID49: Message Buffer 49 ID Register
    /// MB11_16B_WORD1_H: Message Buffer 11 WORD_16B Register
    /// MB3_64B_WORD13_H: Message Buffer 3 WORD_64B Register
    /// MB49_8B_ID: Message Buffer 49 ID Register
    /// MB6_32B_WORD7_H: Message Buffer 6 WORD_32B Register
    pub ID49: RWRegister<u32>,

    /// MB11_16B_WORD2_H and WORD049
    /// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB7_32B_CS_H
    /// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB49_8B_WORD0
    /// MB11_16B_WORD2_H: MB11_16B_WORD2_H and MB3_64B_WORD14_H
    /// MB11_16B_WORD2_H: Message Buffer 11 WORD_16B Register
    /// MB3_64B_WORD14_H: Message Buffer 3 WORD_64B Register
    /// MB49_8B_WORD0: Message Buffer 49 WORD_8B Register
    /// MB7_32B_CS_H: Message Buffer 7 CS Register
    /// WORD049: Message Buffer 49 WORD0 Register
    pub MB11_16B_WORD2_H: RWRegister<u32>,

    /// MB11_16B_WORD3_H and WORD149
    /// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB7_32B_ID_H
    /// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB49_8B_WORD1
    /// MB11_16B_WORD3_H: MB11_16B_WORD3_H and MB3_64B_WORD15_H
    /// MB11_16B_WORD3_H: Message Buffer 11 WORD_16B Register
    /// MB3_64B_WORD15_H: Message Buffer 3 WORD_64B Register
    /// MB49_8B_WORD1: Message Buffer 49 WORD_8B Register
    /// MB7_32B_ID_H: Message Buffer 7 ID Register
    /// WORD149: Message Buffer 49 WORD1 Register
    pub MB11_16B_WORD3_H: RWRegister<u32>,

    /// CS50 and MB7_32B_WORD0_H
    /// CS50: CS50 and MB50_8B_CS
    /// CS50: CS50 and MB4_64B_CS_H
    /// CS50: CS50 and MB12_16B_CS_H
    /// CS50: Message Buffer 50 CS Register
    /// MB12_16B_CS_H: Message Buffer 12 CS Register
    /// MB4_64B_CS_H: Message Buffer 4 CS Register
    /// MB50_8B_CS: Message Buffer 50 CS Register
    /// MB7_32B_WORD0_H: Message Buffer 7 WORD_32B Register
    pub CS50: RWRegister<u32>,

    /// ID50 and MB7_32B_WORD1_H
    /// ID50: ID50 and MB50_8B_ID
    /// ID50: ID50 and MB4_64B_ID_H
    /// ID50: ID50 and MB12_16B_ID_H
    /// ID50: Message Buffer 50 ID Register
    /// MB12_16B_ID_H: Message Buffer 12 ID Register
    /// MB4_64B_ID_H: Message Buffer 4 ID Register
    /// MB50_8B_ID: Message Buffer 50 ID Register
    /// MB7_32B_WORD1_H: Message Buffer 7 WORD_32B Register
    pub ID50: RWRegister<u32>,

    /// MB12_16B_WORD0_H and WORD050
    /// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB7_32B_WORD2_H
    /// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB50_8B_WORD0
    /// MB12_16B_WORD0_H: MB12_16B_WORD0_H and MB4_64B_WORD0_H
    /// MB12_16B_WORD0_H: Message Buffer 12 WORD_16B Register
    /// MB4_64B_WORD0_H: Message Buffer 4 WORD_64B Register
    /// MB50_8B_WORD0: Message Buffer 50 WORD_8B Register
    /// MB7_32B_WORD2_H: Message Buffer 7 WORD_32B Register
    /// WORD050: Message Buffer 50 WORD0 Register
    pub MB12_16B_WORD0_H: RWRegister<u32>,

    /// MB12_16B_WORD1_H and WORD150
    /// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB7_32B_WORD3_H
    /// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB50_8B_WORD1
    /// MB12_16B_WORD1_H: MB12_16B_WORD1_H and MB4_64B_WORD1_H
    /// MB12_16B_WORD1_H: Message Buffer 12 WORD_16B Register
    /// MB4_64B_WORD1_H: Message Buffer 4 WORD_64B Register
    /// MB50_8B_WORD1: Message Buffer 50 WORD_8B Register
    /// MB7_32B_WORD3_H: Message Buffer 7 WORD_32B Register
    /// WORD150: Message Buffer 50 WORD1 Register
    pub MB12_16B_WORD1_H: RWRegister<u32>,

    /// CS51 and MB7_32B_WORD4_H
    /// CS51: CS51 and MB51_8B_CS
    /// CS51: CS51 and MB4_64B_WORD2_H
    /// CS51: CS51 and MB12_16B_WORD2_H
    /// CS51: Message Buffer 51 CS Register
    /// MB12_16B_WORD2_H: Message Buffer 12 WORD_16B Register
    /// MB4_64B_WORD2_H: Message Buffer 4 WORD_64B Register
    /// MB51_8B_CS: Message Buffer 51 CS Register
    /// MB7_32B_WORD4_H: Message Buffer 7 WORD_32B Register
    pub CS51: RWRegister<u32>,

    /// ID51 and MB7_32B_WORD5_H
    /// ID51: ID51 and MB51_8B_ID
    /// ID51: ID51 and MB4_64B_WORD3_H
    /// ID51: ID51 and MB12_16B_WORD3_H
    /// ID51: Message Buffer 51 ID Register
    /// MB12_16B_WORD3_H: Message Buffer 12 WORD_16B Register
    /// MB4_64B_WORD3_H: Message Buffer 4 WORD_64B Register
    /// MB51_8B_ID: Message Buffer 51 ID Register
    /// MB7_32B_WORD5_H: Message Buffer 7 WORD_32B Register
    pub ID51: RWRegister<u32>,

    /// MB13_16B_CS_H and WORD051
    /// MB13_16B_CS_H: MB13_16B_CS_H and MB7_32B_WORD6_H
    /// MB13_16B_CS_H: MB13_16B_CS_H and MB51_8B_WORD0
    /// MB13_16B_CS_H: MB13_16B_CS_H and MB4_64B_WORD4_H
    /// MB13_16B_CS_H: Message Buffer 13 CS Register
    /// MB4_64B_WORD4_H: Message Buffer 4 WORD_64B Register
    /// MB51_8B_WORD0: Message Buffer 51 WORD_8B Register
    /// MB7_32B_WORD6_H: Message Buffer 7 WORD_32B Register
    /// WORD051: Message Buffer 51 WORD0 Register
    pub MB13_16B_CS_H: RWRegister<u32>,

    /// MB13_16B_ID_H and WORD151
    /// MB13_16B_ID_H: MB13_16B_ID_H and MB7_32B_WORD7_H
    /// MB13_16B_ID_H: MB13_16B_ID_H and MB51_8B_WORD1
    /// MB13_16B_ID_H: MB13_16B_ID_H and MB4_64B_WORD5_H
    /// MB13_16B_ID_H: Message Buffer 13 ID Register
    /// MB4_64B_WORD5_H: Message Buffer 4 WORD_64B Register
    /// MB51_8B_WORD1: Message Buffer 51 WORD_8B Register
    /// MB7_32B_WORD7_H: Message Buffer 7 WORD_32B Register
    /// WORD151: Message Buffer 51 WORD1 Register
    pub MB13_16B_ID_H: RWRegister<u32>,

    /// CS52 and MB8_32B_CS_H
    /// CS52: CS52 and MB52_8B_CS
    /// CS52: CS52 and MB4_64B_WORD6_H
    /// CS52: CS52 and MB13_16B_WORD0_H
    /// CS52: Message Buffer 52 CS Register
    /// MB13_16B_WORD0_H: Message Buffer 13 WORD_16B Register
    /// MB4_64B_WORD6_H: Message Buffer 4 WORD_64B Register
    /// MB52_8B_CS: Message Buffer 52 CS Register
    /// MB8_32B_CS_H: Message Buffer 8 CS Register
    pub CS52: RWRegister<u32>,

    /// ID52 and MB8_32B_ID_H
    /// ID52: ID52 and MB52_8B_ID
    /// ID52: ID52 and MB4_64B_WORD7_H
    /// ID52: ID52 and MB13_16B_WORD1_H
    /// ID52: Message Buffer 52 ID Register
    /// MB13_16B_WORD1_H: Message Buffer 13 WORD_16B Register
    /// MB4_64B_WORD7_H: Message Buffer 4 WORD_64B Register
    /// MB52_8B_ID: Message Buffer 52 ID Register
    /// MB8_32B_ID_H: Message Buffer 8 ID Register
    pub ID52: RWRegister<u32>,

    /// MB13_16B_WORD2_H and WORD052
    /// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB8_32B_WORD0_H
    /// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB52_8B_WORD0
    /// MB13_16B_WORD2_H: MB13_16B_WORD2_H and MB4_64B_WORD8_H
    /// MB13_16B_WORD2_H: Message Buffer 13 WORD_16B Register
    /// MB4_64B_WORD8_H: Message Buffer 4 WORD_64B Register
    /// MB52_8B_WORD0: Message Buffer 52 WORD_8B Register
    /// MB8_32B_WORD0_H: Message Buffer 8 WORD_32B Register
    /// WORD052: Message Buffer 52 WORD0 Register
    pub MB13_16B_WORD2_H: RWRegister<u32>,

    /// MB13_16B_WORD3_H and WORD152
    /// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB8_32B_WORD1_H
    /// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB52_8B_WORD1
    /// MB13_16B_WORD3_H: MB13_16B_WORD3_H and MB4_64B_WORD9_H
    /// MB13_16B_WORD3_H: Message Buffer 13 WORD_16B Register
    /// MB4_64B_WORD9_H: Message Buffer 4 WORD_64B Register
    /// MB52_8B_WORD1: Message Buffer 52 WORD_8B Register
    /// MB8_32B_WORD1_H: Message Buffer 8 WORD_32B Register
    /// WORD152: Message Buffer 52 WORD1 Register
    pub MB13_16B_WORD3_H: RWRegister<u32>,

    /// CS53 and MB8_32B_WORD2_H
    /// CS53: CS53 and MB53_8B_CS
    /// CS53: CS53 and MB4_64B_WORD10_H
    /// CS53: CS53 and MB14_16B_CS_H
    /// CS53: Message Buffer 53 CS Register
    /// MB14_16B_CS_H: Message Buffer 14 CS Register
    /// MB4_64B_WORD10_H: Message Buffer 4 WORD_64B Register
    /// MB53_8B_CS: Message Buffer 53 CS Register
    /// MB8_32B_WORD2_H: Message Buffer 8 WORD_32B Register
    pub CS53: RWRegister<u32>,

    /// ID53 and MB8_32B_WORD3_H
    /// ID53: ID53 and MB53_8B_ID
    /// ID53: ID53 and MB4_64B_WORD11_H
    /// ID53: ID53 and MB14_16B_ID_H
    /// ID53: Message Buffer 53 ID Register
    /// MB14_16B_ID_H: Message Buffer 14 ID Register
    /// MB4_64B_WORD11_H: Message Buffer 4 WORD_64B Register
    /// MB53_8B_ID: Message Buffer 53 ID Register
    /// MB8_32B_WORD3_H: Message Buffer 8 WORD_32B Register
    pub ID53: RWRegister<u32>,

    /// MB14_16B_WORD0_H and WORD053
    /// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB8_32B_WORD4_H
    /// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB53_8B_WORD0
    /// MB14_16B_WORD0_H: MB14_16B_WORD0_H and MB4_64B_WORD12_H
    /// MB14_16B_WORD0_H: Message Buffer 14 WORD_16B Register
    /// MB4_64B_WORD12_H: Message Buffer 4 WORD_64B Register
    /// MB53_8B_WORD0: Message Buffer 53 WORD_8B Register
    /// MB8_32B_WORD4_H: Message Buffer 8 WORD_32B Register
    /// WORD053: Message Buffer 53 WORD0 Register
    pub MB14_16B_WORD0_H: RWRegister<u32>,

    /// MB14_16B_WORD1_H and WORD153
    /// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB8_32B_WORD5_H
    /// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB53_8B_WORD1
    /// MB14_16B_WORD1_H: MB14_16B_WORD1_H and MB4_64B_WORD13_H
    /// MB14_16B_WORD1_H: Message Buffer 14 WORD_16B Register
    /// MB4_64B_WORD13_H: Message Buffer 4 WORD_64B Register
    /// MB53_8B_WORD1: Message Buffer 53 WORD_8B Register
    /// MB8_32B_WORD5_H: Message Buffer 8 WORD_32B Register
    /// WORD153: Message Buffer 53 WORD1 Register
    pub MB14_16B_WORD1_H: RWRegister<u32>,

    /// CS54 and MB8_32B_WORD6_H
    /// CS54: CS54 and MB54_8B_CS
    /// CS54: CS54 and MB4_64B_WORD14_H
    /// CS54: CS54 and MB14_16B_WORD2_H
    /// CS54: Message Buffer 54 CS Register
    /// MB14_16B_WORD2_H: Message Buffer 14 WORD_16B Register
    /// MB4_64B_WORD14_H: Message Buffer 4 WORD_64B Register
    /// MB54_8B_CS: Message Buffer 54 CS Register
    /// MB8_32B_WORD6_H: Message Buffer 8 WORD_32B Register
    pub CS54: RWRegister<u32>,

    /// ID54 and MB8_32B_WORD7_H
    /// ID54: ID54 and MB54_8B_ID
    /// ID54: ID54 and MB4_64B_WORD15_H
    /// ID54: ID54 and MB14_16B_WORD3_H
    /// ID54: Message Buffer 54 ID Register
    /// MB14_16B_WORD3_H: Message Buffer 14 WORD_16B Register
    /// MB4_64B_WORD15_H: Message Buffer 4 WORD_64B Register
    /// MB54_8B_ID: Message Buffer 54 ID Register
    /// MB8_32B_WORD7_H: Message Buffer 8 WORD_32B Register
    pub ID54: RWRegister<u32>,

    /// MB15_16B_CS_H and WORD054
    /// MB15_16B_CS_H: MB15_16B_CS_H and MB9_32B_CS_H
    /// MB15_16B_CS_H: MB15_16B_CS_H and MB5_64B_CS_H
    /// MB15_16B_CS_H: MB15_16B_CS_H and MB54_8B_WORD0
    /// MB15_16B_CS_H: Message Buffer 15 CS Register
    /// MB54_8B_WORD0: Message Buffer 54 WORD_8B Register
    /// MB5_64B_CS_H: Message Buffer 5 CS Register
    /// MB9_32B_CS_H: Message Buffer 9 CS Register
    /// WORD054: Message Buffer 54 WORD0 Register
    pub MB15_16B_CS_H: RWRegister<u32>,

    /// MB15_16B_ID_H and WORD154
    /// MB15_16B_ID_H: MB15_16B_ID_H and MB9_32B_ID_H
    /// MB15_16B_ID_H: MB15_16B_ID_H and MB5_64B_ID_H
    /// MB15_16B_ID_H: MB15_16B_ID_H and MB54_8B_WORD1
    /// MB15_16B_ID_H: Message Buffer 15 ID Register
    /// MB54_8B_WORD1: Message Buffer 54 WORD_8B Register
    /// MB5_64B_ID_H: Message Buffer 5 ID Register
    /// MB9_32B_ID_H: Message Buffer 9 ID Register
    /// WORD154: Message Buffer 54 WORD1 Register
    pub MB15_16B_ID_H: RWRegister<u32>,

    /// CS55 and MB9_32B_WORD0_H
    /// CS55: CS55 and MB5_64B_WORD0_H
    /// CS55: CS55 and MB55_8B_CS
    /// CS55: CS55 and MB15_16B_WORD0_H
    /// CS55: Message Buffer 55 CS Register
    /// MB15_16B_WORD0_H: Message Buffer 15 WORD_16B Register
    /// MB55_8B_CS: Message Buffer 55 CS Register
    /// MB5_64B_WORD0_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD0_H: Message Buffer 9 WORD_32B Register
    pub CS55: RWRegister<u32>,

    /// ID55 and MB9_32B_WORD1_H
    /// ID55: ID55 and MB5_64B_WORD1_H
    /// ID55: ID55 and MB55_8B_ID
    /// ID55: ID55 and MB15_16B_WORD1_H
    /// ID55: Message Buffer 55 ID Register
    /// MB15_16B_WORD1_H: Message Buffer 15 WORD_16B Register
    /// MB55_8B_ID: Message Buffer 55 ID Register
    /// MB5_64B_WORD1_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD1_H: Message Buffer 9 WORD_32B Register
    pub ID55: RWRegister<u32>,

    /// MB15_16B_WORD2_H and WORD055
    /// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB9_32B_WORD2_H
    /// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB5_64B_WORD2_H
    /// MB15_16B_WORD2_H: MB15_16B_WORD2_H and MB55_8B_WORD0
    /// MB15_16B_WORD2_H: Message Buffer 15 WORD_16B Register
    /// MB55_8B_WORD0: Message Buffer 55 WORD_8B Register
    /// MB5_64B_WORD2_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD2_H: Message Buffer 9 WORD_32B Register
    /// WORD055: Message Buffer 55 WORD0 Register
    pub MB15_16B_WORD2_H: RWRegister<u32>,

    /// MB15_16B_WORD3_H and WORD155
    /// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB9_32B_WORD3_H
    /// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB5_64B_WORD3_H
    /// MB15_16B_WORD3_H: MB15_16B_WORD3_H and MB55_8B_WORD1
    /// MB15_16B_WORD3_H: Message Buffer 15 WORD_16B Register
    /// MB55_8B_WORD1: Message Buffer 55 WORD_8B Register
    /// MB5_64B_WORD3_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD3_H: Message Buffer 9 WORD_32B Register
    /// WORD155: Message Buffer 55 WORD1 Register
    pub MB15_16B_WORD3_H: RWRegister<u32>,

    /// CS56 and MB9_32B_WORD4_H
    /// CS56: CS56 and MB5_64B_WORD4_H
    /// CS56: CS56 and MB56_8B_CS
    /// CS56: CS56 and MB16_16B_CS_H
    /// CS56: Message Buffer 56 CS Register
    /// MB16_16B_CS_H: Message Buffer 16 CS Register
    /// MB56_8B_CS: Message Buffer 56 CS Register
    /// MB5_64B_WORD4_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD4_H: Message Buffer 9 WORD_32B Register
    pub CS56: RWRegister<u32>,

    /// ID56 and MB9_32B_WORD5_H
    /// ID56: ID56 and MB5_64B_WORD5_H
    /// ID56: ID56 and MB56_8B_ID
    /// ID56: ID56 and MB16_16B_ID_H
    /// ID56: Message Buffer 56 ID Register
    /// MB16_16B_ID_H: Message Buffer 16 ID Register
    /// MB56_8B_ID: Message Buffer 56 ID Register
    /// MB5_64B_WORD5_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD5_H: Message Buffer 9 WORD_32B Register
    pub ID56: RWRegister<u32>,

    /// MB16_16B_WORD0_H and WORD056
    /// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB9_32B_WORD6_H
    /// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB5_64B_WORD6_H
    /// MB16_16B_WORD0_H: MB16_16B_WORD0_H and MB56_8B_WORD0
    /// MB16_16B_WORD0_H: Message Buffer 16 WORD_16B Register
    /// MB56_8B_WORD0: Message Buffer 56 WORD_8B Register
    /// MB5_64B_WORD6_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD6_H: Message Buffer 9 WORD_32B Register
    /// WORD056: Message Buffer 56 WORD0 Register
    pub MB16_16B_WORD0_H: RWRegister<u32>,

    /// MB16_16B_WORD1_H and WORD156
    /// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB9_32B_WORD7_H
    /// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB5_64B_WORD7_H
    /// MB16_16B_WORD1_H: MB16_16B_WORD1_H and MB56_8B_WORD1
    /// MB16_16B_WORD1_H: Message Buffer 16 WORD_16B Register
    /// MB56_8B_WORD1: Message Buffer 56 WORD_8B Register
    /// MB5_64B_WORD7_H: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD7_H: Message Buffer 9 WORD_32B Register
    /// WORD156: Message Buffer 56 WORD1 Register
    pub MB16_16B_WORD1_H: RWRegister<u32>,

    /// CS57 and MB5_64B_WORD8_H
    /// CS57: CS57 and MB57_8B_CS
    /// CS57: CS57 and MB16_16B_WORD2_H
    /// CS57: CS57 and MB10_32B_CS_H
    /// CS57: Message Buffer 57 CS Register
    /// MB10_32B_CS_H: Message Buffer 10 CS Register
    /// MB16_16B_WORD2_H: Message Buffer 16 WORD_16B Register
    /// MB57_8B_CS: Message Buffer 57 CS Register
    /// MB5_64B_WORD8_H: Message Buffer 5 WORD_64B Register
    pub CS57: RWRegister<u32>,

    /// ID57 and MB5_64B_WORD9_H
    /// ID57: ID57 and MB57_8B_ID
    /// ID57: ID57 and MB16_16B_WORD3_H
    /// ID57: ID57 and MB10_32B_ID_H
    /// ID57: Message Buffer 57 ID Register
    /// MB10_32B_ID_H: Message Buffer 10 ID Register
    /// MB16_16B_WORD3_H: Message Buffer 16 WORD_16B Register
    /// MB57_8B_ID: Message Buffer 57 ID Register
    /// MB5_64B_WORD9_H: Message Buffer 5 WORD_64B Register
    pub ID57: RWRegister<u32>,

    /// MB10_32B_WORD0_H and WORD057
    /// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB5_64B_WORD10_H
    /// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB57_8B_WORD0
    /// MB10_32B_WORD0_H: MB10_32B_WORD0_H and MB17_16B_CS_H
    /// MB10_32B_WORD0_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_CS_H: Message Buffer 17 CS Register
    /// MB57_8B_WORD0: Message Buffer 57 WORD_8B Register
    /// MB5_64B_WORD10_H: Message Buffer 5 WORD_64B Register
    /// WORD057: Message Buffer 57 WORD0 Register
    pub MB10_32B_WORD0_H: RWRegister<u32>,

    /// MB10_32B_WORD1_H and WORD157
    /// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB5_64B_WORD11_H
    /// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB57_8B_WORD1
    /// MB10_32B_WORD1_H: MB10_32B_WORD1_H and MB17_16B_ID_H
    /// MB10_32B_WORD1_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_ID_H: Message Buffer 17 ID Register
    /// MB57_8B_WORD1: Message Buffer 57 WORD_8B Register
    /// MB5_64B_WORD11_H: Message Buffer 5 WORD_64B Register
    /// WORD157: Message Buffer 57 WORD1 Register
    pub MB10_32B_WORD1_H: RWRegister<u32>,

    /// CS58 and MB5_64B_WORD12_H
    /// CS58: CS58 and MB58_8B_CS
    /// CS58: CS58 and MB17_16B_WORD0_H
    /// CS58: CS58 and MB10_32B_WORD2_H
    /// CS58: Message Buffer 58 CS Register
    /// MB10_32B_WORD2_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD0_H: Message Buffer 17 WORD_16B Register
    /// MB58_8B_CS: Message Buffer 58 CS Register
    /// MB5_64B_WORD12_H: Message Buffer 5 WORD_64B Register
    pub CS58: RWRegister<u32>,

    /// ID58 and MB5_64B_WORD13_H
    /// ID58: ID58 and MB58_8B_ID
    /// ID58: ID58 and MB17_16B_WORD1_H
    /// ID58: ID58 and MB10_32B_WORD3_H
    /// ID58: Message Buffer 58 ID Register
    /// MB10_32B_WORD3_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD1_H: Message Buffer 17 WORD_16B Register
    /// MB58_8B_ID: Message Buffer 58 ID Register
    /// MB5_64B_WORD13_H: Message Buffer 5 WORD_64B Register
    pub ID58: RWRegister<u32>,

    /// MB10_32B_WORD4_H and WORD058
    /// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB5_64B_WORD14_H
    /// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB58_8B_WORD0
    /// MB10_32B_WORD4_H: MB10_32B_WORD4_H and MB17_16B_WORD2_H
    /// MB10_32B_WORD4_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD2_H: Message Buffer 17 WORD_16B Register
    /// MB58_8B_WORD0: Message Buffer 58 WORD_8B Register
    /// MB5_64B_WORD14_H: Message Buffer 5 WORD_64B Register
    /// WORD058: Message Buffer 58 WORD0 Register
    pub MB10_32B_WORD4_H: RWRegister<u32>,

    /// MB10_32B_WORD5_H and WORD158
    /// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB5_64B_WORD15_H
    /// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB58_8B_WORD1
    /// MB10_32B_WORD5_H: MB10_32B_WORD5_H and MB17_16B_WORD3_H
    /// MB10_32B_WORD5_H: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD3_H: Message Buffer 17 WORD_16B Register
    /// MB58_8B_WORD1: Message Buffer 58 WORD_8B Register
    /// MB5_64B_WORD15_H: Message Buffer 5 WORD_64B Register
    /// WORD158: Message Buffer 58 WORD1 Register
    pub MB10_32B_WORD5_H: RWRegister<u32>,

    /// CS59 and MB6_64B_CS_H
    /// CS59: CS59 and MB59_8B_CS
    /// CS59: CS59 and MB18_16B_CS_H
    /// CS59: CS59 and MB10_32B_WORD6_H
    /// CS59: Message Buffer 59 CS Register
    /// MB10_32B_WORD6_H: Message Buffer 10 WORD_32B Register
    /// MB18_16B_CS_H: Message Buffer 18 CS Register
    /// MB59_8B_CS: Message Buffer 59 CS Register
    /// MB6_64B_CS_H: Message Buffer 6 CS Register
    pub CS59: RWRegister<u32>,

    /// ID59 and MB6_64B_ID_H
    /// ID59: ID59 and MB59_8B_ID
    /// ID59: ID59 and MB18_16B_ID_H
    /// ID59: ID59 and MB10_32B_WORD7_H
    /// ID59: Message Buffer 59 ID Register
    /// MB10_32B_WORD7_H: Message Buffer 10 WORD_32B Register
    /// MB18_16B_ID_H: Message Buffer 18 ID Register
    /// MB59_8B_ID: Message Buffer 59 ID Register
    /// MB6_64B_ID_H: Message Buffer 6 ID Register
    pub ID59: RWRegister<u32>,

    /// MB11_32B_CS_H and WORD059
    /// MB11_32B_CS_H: MB11_32B_CS_H and MB6_64B_WORD0_H
    /// MB11_32B_CS_H: MB11_32B_CS_H and MB59_8B_WORD0
    /// MB11_32B_CS_H: MB11_32B_CS_H and MB18_16B_WORD0_H
    /// MB11_32B_CS_H: Message Buffer 11 CS Register
    /// MB18_16B_WORD0_H: Message Buffer 18 WORD_16B Register
    /// MB59_8B_WORD0: Message Buffer 59 WORD_8B Register
    /// MB6_64B_WORD0_H: Message Buffer 6 WORD_64B Register
    /// WORD059: Message Buffer 59 WORD0 Register
    pub MB11_32B_CS_H: RWRegister<u32>,

    /// MB11_32B_ID_H and WORD159
    /// MB11_32B_ID_H: MB11_32B_ID_H and MB6_64B_WORD1_H
    /// MB11_32B_ID_H: MB11_32B_ID_H and MB59_8B_WORD1
    /// MB11_32B_ID_H: MB11_32B_ID_H and MB18_16B_WORD1_H
    /// MB11_32B_ID_H: Message Buffer 11 ID Register
    /// MB18_16B_WORD1_H: Message Buffer 18 WORD_16B Register
    /// MB59_8B_WORD1: Message Buffer 59 WORD_8B Register
    /// MB6_64B_WORD1_H: Message Buffer 6 WORD_64B Register
    /// WORD159: Message Buffer 59 WORD1 Register
    pub MB11_32B_ID_H: RWRegister<u32>,

    /// CS60 and MB6_64B_WORD2_H
    /// CS60: CS60 and MB60_8B_CS
    /// CS60: CS60 and MB18_16B_WORD2_H
    /// CS60: CS60 and MB11_32B_WORD0_H
    /// CS60: Message Buffer 60 CS Register
    /// MB11_32B_WORD0_H: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD2_H: Message Buffer 18 WORD_16B Register
    /// MB60_8B_CS: Message Buffer 60 CS Register
    /// MB6_64B_WORD2_H: Message Buffer 6 WORD_64B Register
    pub CS60: RWRegister<u32>,

    /// ID60 and MB6_64B_WORD3_H
    /// ID60: ID60 and MB60_8B_ID
    /// ID60: ID60 and MB18_16B_WORD3_H
    /// ID60: ID60 and MB11_32B_WORD1_H
    /// ID60: Message Buffer 60 ID Register
    /// MB11_32B_WORD1_H: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD3_H: Message Buffer 18 WORD_16B Register
    /// MB60_8B_ID: Message Buffer 60 ID Register
    /// MB6_64B_WORD3_H: Message Buffer 6 WORD_64B Register
    pub ID60: RWRegister<u32>,

    /// MB11_32B_WORD2_H and WORD060
    /// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB6_64B_WORD4_H
    /// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB60_8B_WORD0
    /// MB11_32B_WORD2_H: MB11_32B_WORD2_H and MB19_16B_CS_H
    /// MB11_32B_WORD2_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_CS_H: Message Buffer 19 CS Register
    /// MB60_8B_WORD0: Message Buffer 60 WORD_8B Register
    /// MB6_64B_WORD4_H: Message Buffer 6 WORD_64B Register
    /// WORD060: Message Buffer 60 WORD0 Register
    pub MB11_32B_WORD2_H: RWRegister<u32>,

    /// MB11_32B_WORD3_H and WORD160
    /// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB6_64B_WORD5_H
    /// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB60_8B_WORD1
    /// MB11_32B_WORD3_H: MB11_32B_WORD3_H and MB19_16B_ID_H
    /// MB11_32B_WORD3_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_ID_H: Message Buffer 19 ID Register
    /// MB60_8B_WORD1: Message Buffer 60 WORD_8B Register
    /// MB6_64B_WORD5_H: Message Buffer 6 WORD_64B Register
    /// WORD160: Message Buffer 60 WORD1 Register
    pub MB11_32B_WORD3_H: RWRegister<u32>,

    /// CS61 and MB6_64B_WORD6_H
    /// CS61: CS61 and MB61_8B_CS
    /// CS61: CS61 and MB19_16B_WORD0_H
    /// CS61: CS61 and MB11_32B_WORD4_H
    /// CS61: Message Buffer 61 CS Register
    /// MB11_32B_WORD4_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD0_H: Message Buffer 19 WORD_16B Register
    /// MB61_8B_CS: Message Buffer 61 CS Register
    /// MB6_64B_WORD6_H: Message Buffer 6 WORD_64B Register
    pub CS61: RWRegister<u32>,

    /// ID61 and MB6_64B_WORD7_H
    /// ID61: ID61 and MB61_8B_ID
    /// ID61: ID61 and MB19_16B_WORD1_H
    /// ID61: ID61 and MB11_32B_WORD5_H
    /// ID61: Message Buffer 61 ID Register
    /// MB11_32B_WORD5_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD1_H: Message Buffer 19 WORD_16B Register
    /// MB61_8B_ID: Message Buffer 61 ID Register
    /// MB6_64B_WORD7_H: Message Buffer 6 WORD_64B Register
    pub ID61: RWRegister<u32>,

    /// MB11_32B_WORD6_H and WORD061
    /// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB6_64B_WORD8_H
    /// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB61_8B_WORD0
    /// MB11_32B_WORD6_H: MB11_32B_WORD6_H and MB19_16B_WORD2_H
    /// MB11_32B_WORD6_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD2_H: Message Buffer 19 WORD_16B Register
    /// MB61_8B_WORD0: Message Buffer 61 WORD_8B Register
    /// MB6_64B_WORD8_H: Message Buffer 6 WORD_64B Register
    /// WORD061: Message Buffer 61 WORD0 Register
    pub MB11_32B_WORD6_H: RWRegister<u32>,

    /// MB11_32B_WORD7_H and WORD161
    /// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB6_64B_WORD9_H
    /// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB61_8B_WORD1
    /// MB11_32B_WORD7_H: MB11_32B_WORD7_H and MB19_16B_WORD3_H
    /// MB11_32B_WORD7_H: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD3_H: Message Buffer 19 WORD_16B Register
    /// MB61_8B_WORD1: Message Buffer 61 WORD_8B Register
    /// MB6_64B_WORD9_H: Message Buffer 6 WORD_64B Register
    /// WORD161: Message Buffer 61 WORD1 Register
    pub MB11_32B_WORD7_H: RWRegister<u32>,

    /// CS62 and MB6_64B_WORD10_H
    /// CS62: CS62 and MB62_8B_CS
    /// CS62: CS62 and MB20_16B_CS_H
    /// CS62: Message Buffer 62 CS Register
    /// MB20_16B_CS_H: Message Buffer 20 CS Register
    /// MB62_8B_CS: Message Buffer 62 CS Register
    /// MB6_64B_WORD10_H: Message Buffer 6 WORD_64B Register
    pub CS62: RWRegister<u32>,

    /// ID62 and MB6_64B_WORD11_H
    /// ID62: ID62 and MB62_8B_ID
    /// ID62: ID62 and MB20_16B_ID_H
    /// ID62: Message Buffer 62 ID Register
    /// MB20_16B_ID_H: Message Buffer 20 ID Register
    /// MB62_8B_ID: Message Buffer 62 ID Register
    /// MB6_64B_WORD11_H: Message Buffer 6 WORD_64B Register
    pub ID62: RWRegister<u32>,

    /// MB20_16B_WORD0_H and WORD062
    /// MB20_16B_WORD0_H: MB20_16B_WORD0_H and MB6_64B_WORD12_H
    /// MB20_16B_WORD0_H: MB20_16B_WORD0_H and MB62_8B_WORD0
    /// MB20_16B_WORD0_H: Message Buffer 20 WORD_16B Register
    /// MB62_8B_WORD0: Message Buffer 62 WORD_8B Register
    /// MB6_64B_WORD12_H: Message Buffer 6 WORD_64B Register
    /// WORD062: Message Buffer 62 WORD0 Register
    pub MB20_16B_WORD0_H: RWRegister<u32>,

    /// MB20_16B_WORD1_H and WORD162
    /// MB20_16B_WORD1_H: MB20_16B_WORD1_H and MB6_64B_WORD13_H
    /// MB20_16B_WORD1_H: MB20_16B_WORD1_H and MB62_8B_WORD1
    /// MB20_16B_WORD1_H: Message Buffer 20 WORD_16B Register
    /// MB62_8B_WORD1: Message Buffer 62 WORD_8B Register
    /// MB6_64B_WORD13_H: Message Buffer 6 WORD_64B Register
    /// WORD162: Message Buffer 62 WORD1 Register
    pub MB20_16B_WORD1_H: RWRegister<u32>,

    /// CS63 and MB6_64B_WORD14_H
    /// CS63: CS63 and MB63_8B_CS
    /// CS63: CS63 and MB20_16B_WORD2_H
    /// CS63: Message Buffer 63 CS Register
    /// MB20_16B_WORD2_H: Message Buffer 20 WORD_16B Register
    /// MB63_8B_CS: Message Buffer 63 CS Register
    /// MB6_64B_WORD14_H: Message Buffer 6 WORD_64B Register
    pub CS63: RWRegister<u32>,

    /// ID63 and MB6_64B_WORD15_H
    /// ID63: ID63 and MB63_8B_ID
    /// ID63: ID63 and MB20_16B_WORD3_H
    /// ID63: Message Buffer 63 ID Register
    /// MB20_16B_WORD3_H: Message Buffer 20 WORD_16B Register
    /// MB63_8B_ID: Message Buffer 63 ID Register
    /// MB6_64B_WORD15_H: Message Buffer 6 WORD_64B Register
    pub ID63: RWRegister<u32>,

    /// MB63_8B_WORD0 and WORD063
    /// MB63_8B_WORD0: Message Buffer 63 WORD_8B Register
    /// WORD063: Message Buffer 63 WORD0 Register
    pub MB63_8B_WORD0: RWRegister<u32>,

    /// MB63_8B_WORD1 and WORD163
    /// MB63_8B_WORD1: Message Buffer 63 WORD_8B Register
    /// WORD163: Message Buffer 63 WORD1 Register
    pub MB63_8B_WORD1: RWRegister<u32>,

    _reserved4: [u32; 256],

    /// Rx Individual Mask registers
    pub RXIMR0: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR1: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR2: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR3: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR4: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR5: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR6: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR7: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR8: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR9: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR10: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR11: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR12: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR13: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR14: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR15: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR16: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR17: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR18: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR19: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR20: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR21: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR22: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR23: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR24: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR25: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR26: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR27: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR28: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR29: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR30: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR31: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR32: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR33: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR34: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR35: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR36: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR37: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR38: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR39: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR40: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR41: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR42: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR43: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR44: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR45: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR46: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR47: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR48: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR49: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR50: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR51: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR52: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR53: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR54: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR55: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR56: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR57: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR58: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR59: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR60: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR61: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR62: RWRegister<u32>,

    /// Rx Individual Mask registers
    pub RXIMR63: RWRegister<u32>,

    _reserved5: [u32; 88],

    /// Memory Error Control register
    pub MECR: RWRegister<u32>,

    /// Error Injection Address register
    pub ERRIAR: RWRegister<u32>,

    /// Error Injection Data Pattern register
    pub ERRIDPR: RWRegister<u32>,

    /// Error Injection Parity Pattern register
    pub ERRIPPR: RWRegister<u32>,

    /// Error Report Address register
    pub RERRAR: RORegister<u32>,

    /// Error Report Data register
    pub RERRDR: RORegister<u32>,

    /// Error Report Syndrome register
    pub RERRSYNR: RORegister<u32>,

    /// Error Status register
    pub ERRSR: RWRegister<u32>,

    _reserved6: [u32; 64],

    /// CAN FD Control register
    pub FDCTRL: RWRegister<u32>,

    /// CAN FD Bit Timing register
    pub FDCBT: RWRegister<u32>,

    /// CAN FD CRC register
    pub FDCRC: RORegister<u32>,
}
pub struct ResetValues {
    pub MCR: u32,
    pub CTRL1: u32,
    pub TIMER: u32,
    pub RXMGMASK: u32,
    pub RX14MASK: u32,
    pub RX15MASK: u32,
    pub ECR: u32,
    pub ESR1: u32,
    pub IMASK2: u32,
    pub IMASK1: u32,
    pub IFLAG2: u32,
    pub IFLAG1: u32,
    pub CTRL2: u32,
    pub ESR2: u32,
    pub CRCR: u32,
    pub RXFGMASK: u32,
    pub RXFIR: u32,
    pub CBT: u32,
    pub CS0: u32,
    pub ID0: u32,
    pub MB0: u32,
    pub MB0_16B_WORD1_L: u32,
    pub CS1: u32,
    pub ID1: u32,
    pub MB: u32,
    pub MB0_32B_WORD5_L: u32,
    pub CS2: u32,
    pub ID2: u32,
    pub MB0_64B_WORD8_L: u32,
    pub MB0_64B_WORD9_L: u32,
    pub CS3: u32,
    pub ID3: u32,
    pub MB0_64B_WORD12_L: u32,
    pub MB0_64B_WORD13_L: u32,
    pub CS4: u32,
    pub ID4: u32,
    pub MB1: u32,
    pub MB1_32B_WORD7_L: u32,
    pub CS5: u32,
    pub ID5: u32,
    pub MB1_64B_WORD2_L: u32,
    pub MB1_64B_WORD3_L: u32,
    pub CS6: u32,
    pub ID6: u32,
    pub MB1_64B_WORD6_L: u32,
    pub MB1_64B_WORD7_L: u32,
    pub CS7: u32,
    pub ID7: u32,
    pub MB1_64B_WORD10_L: u32,
    pub MB1_64B_WORD11_L: u32,
    pub CS8: u32,
    pub ID8: u32,
    pub MB1_64B_WORD14_L: u32,
    pub MB1_64B_WORD15_L: u32,
    pub CS9: u32,
    pub ID9: u32,
    pub MB2_64B_WORD0_L: u32,
    pub MB2_64B_WORD1_L: u32,
    pub CS10: u32,
    pub ID10: u32,
    pub MB10_8B_WORD0: u32,
    pub MB10_8B_WORD1: u32,
    pub CS11: u32,
    pub ID11: u32,
    pub MB11_8B_WORD0: u32,
    pub MB11_8B_WORD1: u32,
    pub CS12: u32,
    pub ID12: u32,
    pub MB12_8B_WORD0: u32,
    pub MB12_8B_WORD1: u32,
    pub CS13: u32,
    pub ID13: u32,
    pub MB13_8B_WORD0: u32,
    pub MB13_8B_WORD1: u32,
    pub CS14: u32,
    pub ID14: u32,
    pub MB14_8B_WORD0: u32,
    pub MB14_8B_WORD1: u32,
    pub CS15: u32,
    pub ID15: u32,
    pub MB10_16B_WORD0_L: u32,
    pub MB10_16B_WORD1_L: u32,
    pub CS16: u32,
    pub ID16: u32,
    pub MB11_16B_CS_L: u32,
    pub MB11_16B_ID_L: u32,
    pub CS17: u32,
    pub ID17: u32,
    pub MB11_16B_WORD2_L: u32,
    pub MB11_16B_WORD3_L: u32,
    pub CS18: u32,
    pub ID18: u32,
    pub MB12_16B_WORD0_L: u32,
    pub MB12_16B_WORD1_L: u32,
    pub CS19: u32,
    pub ID19: u32,
    pub MB13_16B_CS_L: u32,
    pub MB13_16B_ID_L: u32,
    pub CS20: u32,
    pub ID20: u32,
    pub MB13_16B_WORD2_L: u32,
    pub MB13_16B_WORD3_L: u32,
    pub CS21: u32,
    pub ID21: u32,
    pub MB14_16B_WORD0_L: u32,
    pub MB14_16B_WORD1_L: u32,
    pub CS22: u32,
    pub ID22: u32,
    pub MB15_16B_CS_L: u32,
    pub MB15_16B_ID_L: u32,
    pub CS23: u32,
    pub ID23: u32,
    pub MB15_16B_WORD2_L: u32,
    pub MB15_16B_WORD3_L: u32,
    pub CS24: u32,
    pub ID24: u32,
    pub MB16_16B_WORD0_L: u32,
    pub MB16_16B_WORD1_L: u32,
    pub CS25: u32,
    pub ID25: u32,
    pub MB10_32B_WORD0_L: u32,
    pub MB10_32B_WORD1_L: u32,
    pub CS26: u32,
    pub ID26: u32,
    pub MB10_32B_WORD4_L: u32,
    pub MB10_32B_WORD5_L: u32,
    pub CS27: u32,
    pub ID27: u32,
    pub MB11_32B_CS_L: u32,
    pub MB11_32B_ID_L: u32,
    pub CS28: u32,
    pub ID28: u32,
    pub MB11_32B_WORD2_L: u32,
    pub MB11_32B_WORD3_L: u32,
    pub CS29: u32,
    pub ID29: u32,
    pub MB11_32B_WORD6_L: u32,
    pub MB11_32B_WORD7_L: u32,
    pub CS30: u32,
    pub ID30: u32,
    pub MB20_16B_WORD0_L: u32,
    pub MB20_16B_WORD1_L: u32,
    pub CS31: u32,
    pub ID31: u32,
    pub MB31_8B_WORD0: u32,
    pub MB31_8B_WORD1: u32,
    pub CS32: u32,
    pub ID32: u32,
    pub MB0_16B_WORD0_H: u32,
    pub MB0_16B_WORD1_H: u32,
    pub CS33: u32,
    pub ID33: u32,
    pub MB0_32B_WORD4_H: u32,
    pub MB0_32B_WORD5_H: u32,
    pub CS34: u32,
    pub ID34: u32,
    pub MB0_64B_WORD8_H: u32,
    pub MB0_64B_WORD9_H: u32,
    pub CS35: u32,
    pub ID35: u32,
    pub MB0_64B_WORD12_H: u32,
    pub MB0_64B_WORD13_H: u32,
    pub CS36: u32,
    pub ID36: u32,
    pub MB1_32B_WORD6_H: u32,
    pub MB1_32B_WORD7_H: u32,
    pub CS37: u32,
    pub ID37: u32,
    pub MB1_64B_WORD2_H: u32,
    pub MB1_64B_WORD3_H: u32,
    pub CS38: u32,
    pub ID38: u32,
    pub MB1_64B_WORD6_H: u32,
    pub MB1_64B_WORD7_H: u32,
    pub CS39: u32,
    pub ID39: u32,
    pub MB1_64B_WORD10_H: u32,
    pub MB1_64B_WORD11_H: u32,
    pub CS40: u32,
    pub ID40: u32,
    pub MB1_64B_WORD14_H: u32,
    pub MB1_64B_WORD15_H: u32,
    pub CS41: u32,
    pub ID41: u32,
    pub MB2_64B_WORD0_H: u32,
    pub MB2_64B_WORD1_H: u32,
    pub CS42: u32,
    pub ID42: u32,
    pub MB2_64B_WORD4_H: u32,
    pub MB2_64B_WORD5_H: u32,
    pub CS43: u32,
    pub ID43: u32,
    pub MB2_64B_WORD8_H: u32,
    pub MB2_64B_WORD9_H: u32,
    pub CS44: u32,
    pub ID44: u32,
    pub MB2_64B_WORD12_H: u32,
    pub MB2_64B_WORD13_H: u32,
    pub CS45: u32,
    pub ID45: u32,
    pub MB3_64B_CS_H: u32,
    pub MB3_64B_ID_H: u32,
    pub CS46: u32,
    pub ID46: u32,
    pub MB3_64B_WORD2_H: u32,
    pub MB3_64B_WORD3_H: u32,
    pub CS47: u32,
    pub ID47: u32,
    pub MB10_16B_WORD0_H: u32,
    pub MB10_16B_WORD1_H: u32,
    pub CS48: u32,
    pub ID48: u32,
    pub MB11_16B_CS_H: u32,
    pub MB11_16B_ID_H: u32,
    pub CS49: u32,
    pub ID49: u32,
    pub MB11_16B_WORD2_H: u32,
    pub MB11_16B_WORD3_H: u32,
    pub CS50: u32,
    pub ID50: u32,
    pub MB12_16B_WORD0_H: u32,
    pub MB12_16B_WORD1_H: u32,
    pub CS51: u32,
    pub ID51: u32,
    pub MB13_16B_CS_H: u32,
    pub MB13_16B_ID_H: u32,
    pub CS52: u32,
    pub ID52: u32,
    pub MB13_16B_WORD2_H: u32,
    pub MB13_16B_WORD3_H: u32,
    pub CS53: u32,
    pub ID53: u32,
    pub MB14_16B_WORD0_H: u32,
    pub MB14_16B_WORD1_H: u32,
    pub CS54: u32,
    pub ID54: u32,
    pub MB15_16B_CS_H: u32,
    pub MB15_16B_ID_H: u32,
    pub CS55: u32,
    pub ID55: u32,
    pub MB15_16B_WORD2_H: u32,
    pub MB15_16B_WORD3_H: u32,
    pub CS56: u32,
    pub ID56: u32,
    pub MB16_16B_WORD0_H: u32,
    pub MB16_16B_WORD1_H: u32,
    pub CS57: u32,
    pub ID57: u32,
    pub MB10_32B_WORD0_H: u32,
    pub MB10_32B_WORD1_H: u32,
    pub CS58: u32,
    pub ID58: u32,
    pub MB10_32B_WORD4_H: u32,
    pub MB10_32B_WORD5_H: u32,
    pub CS59: u32,
    pub ID59: u32,
    pub MB11_32B_CS_H: u32,
    pub MB11_32B_ID_H: u32,
    pub CS60: u32,
    pub ID60: u32,
    pub MB11_32B_WORD2_H: u32,
    pub MB11_32B_WORD3_H: u32,
    pub CS61: u32,
    pub ID61: u32,
    pub MB11_32B_WORD6_H: u32,
    pub MB11_32B_WORD7_H: u32,
    pub CS62: u32,
    pub ID62: u32,
    pub MB20_16B_WORD0_H: u32,
    pub MB20_16B_WORD1_H: u32,
    pub CS63: u32,
    pub ID63: u32,
    pub MB63_8B_WORD0: u32,
    pub MB63_8B_WORD1: u32,
    pub RXIMR0: u32,
    pub RXIMR1: u32,
    pub RXIMR2: u32,
    pub RXIMR3: u32,
    pub RXIMR4: u32,
    pub RXIMR5: u32,
    pub RXIMR6: u32,
    pub RXIMR7: u32,
    pub RXIMR8: u32,
    pub RXIMR9: u32,
    pub RXIMR10: u32,
    pub RXIMR11: u32,
    pub RXIMR12: u32,
    pub RXIMR13: u32,
    pub RXIMR14: u32,
    pub RXIMR15: u32,
    pub RXIMR16: u32,
    pub RXIMR17: u32,
    pub RXIMR18: u32,
    pub RXIMR19: u32,
    pub RXIMR20: u32,
    pub RXIMR21: u32,
    pub RXIMR22: u32,
    pub RXIMR23: u32,
    pub RXIMR24: u32,
    pub RXIMR25: u32,
    pub RXIMR26: u32,
    pub RXIMR27: u32,
    pub RXIMR28: u32,
    pub RXIMR29: u32,
    pub RXIMR30: u32,
    pub RXIMR31: u32,
    pub RXIMR32: u32,
    pub RXIMR33: u32,
    pub RXIMR34: u32,
    pub RXIMR35: u32,
    pub RXIMR36: u32,
    pub RXIMR37: u32,
    pub RXIMR38: u32,
    pub RXIMR39: u32,
    pub RXIMR40: u32,
    pub RXIMR41: u32,
    pub RXIMR42: u32,
    pub RXIMR43: u32,
    pub RXIMR44: u32,
    pub RXIMR45: u32,
    pub RXIMR46: u32,
    pub RXIMR47: u32,
    pub RXIMR48: u32,
    pub RXIMR49: u32,
    pub RXIMR50: u32,
    pub RXIMR51: u32,
    pub RXIMR52: u32,
    pub RXIMR53: u32,
    pub RXIMR54: u32,
    pub RXIMR55: u32,
    pub RXIMR56: u32,
    pub RXIMR57: u32,
    pub RXIMR58: u32,
    pub RXIMR59: u32,
    pub RXIMR60: u32,
    pub RXIMR61: u32,
    pub RXIMR62: u32,
    pub RXIMR63: u32,
    pub MECR: u32,
    pub ERRIAR: u32,
    pub ERRIDPR: u32,
    pub ERRIPPR: u32,
    pub RERRAR: u32,
    pub RERRDR: u32,
    pub RERRSYNR: u32,
    pub ERRSR: u32,
    pub FDCTRL: u32,
    pub FDCBT: u32,
    pub FDCRC: u32,
}
pub struct Instance<const N: u8> {
    #[cfg_attr(feature = "nosync", allow(unused))]
    pub(crate) addr: u32,
    #[cfg_attr(feature = "nosync", allow(unused))]
    pub(crate) intrs: &'static [crate::Interrupt],
}

#[cfg(not(feature = "nosync"))]
impl<const N: u8> ::core::ops::Deref for Instance<N> {
    type Target = RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &RegisterBlock {
        unsafe { &*(self.addr as *const _) }
    }
}

#[cfg(not(feature = "nosync"))]
unsafe impl<const N: u8> Send for Instance<N> {}

#[cfg(not(feature = "nosync"))]
impl<const N: u8> Instance<N> {
    /// Return the interrupt signals associated with this
    /// peripheral instance
    ///
    /// Collection may be empty if there is no interrupt signal
    /// associated with the peripheral. There's no guarantee for
    /// interrupt signal ordering in the collection.
    #[inline(always)]
    pub const fn interrupts<'a>(&'a self) -> &'a [crate::Interrupt] {
        self.intrs
    }
}
