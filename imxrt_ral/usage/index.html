<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Documentation-only module for usage"><meta name="keywords" content="rust, rustlang, rust-lang, usage"><title>imxrt_ral::usage - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../imxrt_ral/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module usage</h2><div class="sidebar-elems"><div id="sidebar-vars" data-name="usage" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">imxrt_ral</a>::<wbr><a class="mod" href="#">usage</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/imxrt_ral/usage.rs.html#1-387" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Documentation-only module for usage</p>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2>
<p>imxrt-ral APIs use const generics to differentiate different peripheral instances.
This section describes some design techniques for using, or ignoring, these type
hints.</p>
<p>A function that accepts any GPIO instance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;

<span class="kw">fn</span> <span class="ident">any_gpio</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="ident">gpio</span>: <span class="ident">gpio::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>) { <span class="comment">/* ... */</span> }

<span class="kw">let</span> <span class="ident">gpio1</span> <span class="op">=</span> <span class="ident">gpio::GPIO1::take</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>();

<span class="ident">any_gpio</span>(<span class="ident">gpio1</span>);
<span class="ident">any_gpio</span>(<span class="ident">gpio2</span>);</code></pre></div>
<p>A function that <em>only</em> accepts GPIO1:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;

<span class="kw">fn</span> <span class="ident">only_gpio1</span>(<span class="ident">gpio</span>: <span class="ident">gpio::Instance</span><span class="op">&lt;</span><span class="number">1</span><span class="op">&gt;</span>) { <span class="comment">/* ... */</span> }

<span class="kw">let</span> <span class="ident">gpio1</span> <span class="op">=</span> <span class="ident">gpio::GPIO1::take</span>().<span class="ident">unwrap</span>();

<span class="ident">only_gpio1</span>(<span class="ident">gpio1</span>);</code></pre></div>
<p><code>only_gpio1</code> rejects GPIO2 at compile time:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">let</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>();
<span class="ident">only_gpio1</span>(<span class="ident">gpio2</span>);</code></pre></div>
<p>In fact, rejection applies to the <code>release</code> functions, too:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">let</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>();
<span class="ident">gpio::GPIO1::release</span>(<span class="ident">gpio2</span>);</code></pre></div>
<p>These function designs apply to structures, too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;

<span class="kw">struct</span> <span class="ident">GpioDriver</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span> {
    <span class="ident">gpio</span>: <span class="ident">gpio::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>,
    <span class="comment">// ...</span>
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span> <span class="ident">GpioDriver</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">gpio</span>: <span class="ident">gpio::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="comment">// ...</span>
    }
}

<span class="kw">let</span> <span class="ident">gpio1_driver</span> <span class="op">=</span> <span class="ident">GpioDriver::new</span>(<span class="ident">gpio::GPIO1::take</span>().<span class="ident">unwrap</span>());</code></pre></div>
<p>Require that other resources, which are tagged with instance identifiers,
match their peripheral instance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;

<span class="doccomment">/// Type-level constant...</span>
<span class="kw">enum</span> <span class="ident">Const</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span> {}

<span class="doccomment">/// Represents a GPIO pin</span>
<span class="kw">trait</span> <span class="ident">GpioPin</span> {
    <span class="doccomment">/// The associated GPIO instance number</span>
    <span class="kw">type</span> <span class="ident">GpioInstance</span>;
    <span class="kw">const</span> <span class="ident">OFFSET</span>: <span class="ident">u32</span>;
}

<span class="doccomment">/// GPIO2[17]</span>
<span class="kw">struct</span> <span class="ident">AD_B1_00</span> { <span class="comment">/* ... */</span> }

<span class="kw">impl</span> <span class="ident">GpioPin</span> <span class="kw">for</span> <span class="ident">AD_B1_00</span> {
    <span class="kw">type</span> <span class="ident">GpioInstance</span> <span class="op">=</span> <span class="ident">Const</span><span class="op">&lt;</span><span class="number">2</span><span class="op">&gt;</span>;
    <span class="kw">const</span> <span class="ident">OFFSET</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">17</span>;
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span> <span class="ident">GpioDriver</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_high</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">pin</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">P</span>)
    <span class="kw">where</span>
        <span class="ident">P</span>: <span class="ident">GpioPin</span><span class="op">&lt;</span><span class="ident">GpioInstance</span> <span class="op">=</span> <span class="ident">Const</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span><span class="op">&gt;</span>, <span class="comment">// &lt;-- Requirement here</span>
    {
        <span class="comment">// ...</span>
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">GpioDriver::new</span>(<span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ad_b1_00</span> <span class="op">=</span> <span class="comment">// Ownership of pin...</span>
<span class="ident">gpio2</span>.<span class="ident">set_high</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ad_b1_00</span>);</code></pre></div>
<p>If you provide a GPIO<strong>1</strong> pin to the GPIO<strong>2</strong> driver, it fails
at compile time:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="doccomment">/// GPIO1[6]</span>
<span class="kw">struct</span> <span class="ident">SD_B0_03</span> { <span class="comment">/* ... */</span> }

<span class="kw">impl</span> <span class="ident">GpioPin</span> <span class="kw">for</span> <span class="ident">SD_B0_03</span> {
    <span class="kw">type</span> <span class="ident">GpioInstance</span> <span class="op">=</span> <span class="ident">Const</span><span class="op">&lt;</span><span class="number">1</span><span class="op">&gt;</span>;
    <span class="kw">const</span> <span class="ident">OFFSET</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">6</span>;
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">GpioDriver::new</span>(<span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sd_b0_03</span> <span class="op">=</span> <span class="comment">// Ownership of pin...</span>
<span class="comment">// Incorrect: GPIO1 pin with GPIO2 driver</span>
<span class="ident">gpio2</span>.<span class="ident">set_high</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">sd_b0_03</span>);</code></pre></div>
<p>If you would like such a statement to compile, remove the <code>GpioPin</code> constraint
on the <code>set_high</code> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span> <span class="ident">GpioDriver</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_high</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">pin</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">P</span>)
    <span class="kw">where</span>
        <span class="ident">P</span>: <span class="ident">GpioPin</span><span class="comment">/*&lt;GpioInstance = Const&lt;N&gt;&gt;*/</span>, <span class="comment">// No constraint that pin matches driver</span>
    {
        <span class="comment">// ...</span>
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">GpioDriver::new</span>(<span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sd_b0_03</span> <span class="op">=</span> <span class="comment">// Ownership of pin...</span>
<span class="comment">// Now OK: GPIO1 pin with GPIO2 driver</span>
<span class="ident">gpio2</span>.<span class="ident">set_high</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">sd_b0_03</span>);</code></pre></div>
<p>If you don’t want to carry around a generic type for your driver struct,
you can still model peripheral ownership, and work with a pointer to the
register block. You’ll need to use some <code>unsafe</code> code, as shown below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;

<span class="kw">struct</span> <span class="ident">GpioDriver</span> {
    <span class="ident">gpio</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">gpio::RegisterBlock</span>,
}

<span class="kw">impl</span> <span class="ident">GpioDriver</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="ident">gpio</span>: <span class="ident">gpio::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>) -&gt; <span class="ident">GpioDriver</span> {
        <span class="comment">// Instance derefs to a register block</span>
        <span class="kw">let</span> <span class="ident">register</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">gpio::RegisterBlock</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">gpio</span>;
        <span class="comment">// Safety: pointer points to static peripheral memory,</span>
        <span class="comment">// which will outlive the gpio Instance.</span>
        <span class="kw">let</span> <span class="ident">register</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">register</span> };
        <span class="ident">GpioDriver</span> { <span class="ident">gpio</span>: <span class="ident">register</span> }
        <span class="comment">// gpio::Instance dropped, but it&#39;s still maked as</span>
        <span class="comment">// &quot;taken.&quot; So it appears that we own it.</span>
    }
}

<span class="kw">let</span> <span class="ident">gpio2</span> <span class="op">=</span> <span class="ident">GpioDriver::new</span>(<span class="ident">gpio::GPIO2::take</span>().<span class="ident">unwrap</span>());
<span class="comment">// This would fail, since the instance is still &quot;taken&quot; by the</span>
<span class="comment">// driver. Users would need an unsafe steal() to get another handle.</span>
<span class="comment">// gpio::GPIO2::take().unwrap();</span></code></pre></div>
<p>This approach loses some of the compile-time checks, but may be simpler
for others to use.</p>
<h3 id="peripheral-name-vs-instancen" class="section-header"><a href="#peripheral-name-vs-instancen"><code>[Peripheral name]</code> vs <code>Instance&lt;N&gt;</code></a></h3>
<p>Design to a concrete type when you know that there’s only one, single instance
of that peripheral across all chips. This simplifies your driver API while still
supporting all i.MX RT chips. The CCM peripheral is an example of a peripheral with
one instance across all i.MX RT chips.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::ccm</span>;

<span class="comment">// A truly single instance:</span>
<span class="kw">fn</span> <span class="ident">new_ccm</span>(<span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="ident">ccm::CCM</span>) { <span class="comment">/* ... */</span> }

<span class="comment">// Still works, but more general (though the generality isn&#39;t</span>
<span class="comment">// necessary, since there&#39;s only one CCM instance)</span>
<span class="kw">fn</span> <span class="ident">new_ccm_explicit</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="ident">ccm::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>) { <span class="comment">/* ... */</span> }

<span class="kw">let</span> <span class="ident">ccm</span> <span class="op">=</span> <span class="ident">ccm::CCM::take</span>().<span class="ident">unwrap</span>();
<span class="ident">new_ccm</span>(<span class="kw-2">&amp;</span><span class="ident">ccm</span>);
<span class="ident">new_ccm_explicit</span>(<span class="kw-2">&amp;</span><span class="ident">ccm</span>);</code></pre></div>
<p>A <code>CCM</code> is actually an <code>Instance&lt;imxrt_ral::SOLE_INSTANCE&gt;</code>. So, you could
always design to a generic <code>Instance</code> type to be explicit, but it’s not necessary.</p>
<p>When there’s a chance for a peripheral to have multiple instances across
different chips, favor <code>Instance&lt;N&gt;</code> for maximal reuse. Since all instances
are generic, the same function should work no matter how many peripheral
instances exist on your chip. For example, this same function works for 1021
chips – having only one USB instance – and 1062 chips – having two USB instances.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::usb</span>;

<span class="kw">fn</span> <span class="ident">new_usb_driver</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="kw">_</span>: <span class="ident">usb::Instance</span><span class="op">&lt;</span><span class="ident">N</span><span class="op">&gt;</span>) { <span class="comment">/* ... */</span> }

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;imxrt1021&quot;</span>)]</span>
<span class="ident">new_usb_driver</span>(<span class="ident">usb::USB::take</span>().<span class="ident">unwrap</span>());

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;imxrt1062&quot;</span>)]</span>
{
    <span class="ident">new_usb_driver</span>(<span class="ident">usb::USB1::take</span>().<span class="ident">unwrap</span>());
    <span class="ident">new_usb_driver</span>(<span class="ident">usb::USB2::take</span>().<span class="ident">unwrap</span>());
}</code></pre></div>
<p>When compared to the USB implementation, you would <em>not</em> want to use
the a concrete USB <code>Instance</code>, since there are chips that have multiple
USB instances:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">use</span> <span class="ident">imxrt_ral::usb</span>;

<span class="doccomment">/// A function that only takes the sole USB instance, Instance&lt;0&gt;.</span>
<span class="kw">fn</span> <span class="ident">new_usb_driver</span>(<span class="kw">_</span>: <span class="ident">usb::USB</span>) { <span class="comment">/* ... */</span> }

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;imxrt1062&quot;</span>)]</span>
<span class="ident">new_usb_driver</span>(<span class="ident">usb::USB1::take</span>().<span class="ident">unwrap</span>()); <span class="comment">// &lt;-- Fails to compile! Instance&lt;1&gt; != Instance&lt;0&gt;</span>

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;imxrt1021&quot;</span>)]</span>
<span class="ident">new_usb_driver</span>(<span class="ident">usb::USB::take</span>().<span class="ident">unwrap</span>()); <span class="comment">// &lt;-- Doesn&#39;t work here, either! USB == Instance&lt;0&gt; != Instance&lt;1&gt;</span></code></pre></div>
<h3 id="valid-instance-numbers" class="section-header"><a href="#valid-instance-numbers">Valid instance numbers</a></h3>
<p>Consider a function that needs to change behavior given only the const generic instance
number:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="kw">use</span> <span class="ident">imxrt_ral::ccm</span>;

<span class="doccomment">/// Enable the LPUART clock gate in the CCM.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Panics</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Panics if `LPUART_N` does not represent a valid LPUART instance.</span>
<span class="kw">fn</span> <span class="ident">ccm_enable_lpuart_clock_gate</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">LPUART_N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="ident">ccm</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm::CCM</span>) {
    <span class="kw">match</span> <span class="ident">LPUART_N</span> {
        <span class="number">1</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="number">2</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="number">3</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="comment">// 4..=8</span>
        <span class="kw">_</span> =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Unhandled LPUART instance number&quot;</span>),
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ccm</span> <span class="op">=</span> <span class="ident">ccm::CCM::take</span>()<span class="question-mark">?</span>;
<span class="ident">ccm_enable_lpuart_clock_gate</span>::<span class="op">&lt;</span><span class="number">3</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm</span>); <span class="comment">// OK: LPUART3 is valid.</span>
<span class="ident">ccm_enable_lpuart_clock_gate</span>::<span class="op">&lt;</span><span class="number">9</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm</span>); <span class="comment">// panic! LPUART9 isn&#39;t valid</span></code></pre></div>
<p>To catch an invalid N at compile time, use <code>Valid</code>, a trait implemented on
all valid <code>Instance&lt;N&gt;</code> types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::lpuart</span>;

<span class="kw">fn</span> <span class="ident">ccm_enable_lpuart_clock_gate</span><span class="op">&lt;</span><span class="kw">const</span> <span class="ident">LPUART_N</span>: <span class="ident">u8</span><span class="op">&gt;</span>(<span class="ident">ccm</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm::CCM</span>)
<span class="kw">where</span>
    <span class="ident">lpuart::Instance</span><span class="op">&lt;</span><span class="ident">LPUART_N</span><span class="op">&gt;</span>: <span class="ident">imxrt_ral::Valid</span>, <span class="comment">// NEW: constrain LPUART_N to valid instance numbers.</span>
{
    <span class="kw">match</span> <span class="ident">LPUART_N</span> {
        <span class="number">1</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="number">2</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="number">3</span> =&gt; { <span class="comment">/* ... */</span> }
        <span class="comment">// 4..=8</span>
        <span class="kw">_</span> =&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;Handled all LPUART instances&quot;</span>),
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ccm</span> <span class="op">=</span> <span class="ident">ccm::CCM::take</span>()<span class="question-mark">?</span>;
<span class="ident">ccm_enable_lpuart_clock_gate</span>::<span class="op">&lt;</span><span class="number">3</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm</span>); <span class="comment">// OK: LPUART3 is valid.</span></code></pre></div>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="ident">ccm_enable_lpuart_clock_gate</span>::<span class="op">&lt;</span><span class="number">9</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ccm</span>); <span class="comment">// Does not compile!</span></code></pre></div>
<h3 id="disable-strongly-typed-instances" class="section-header"><a href="#disable-strongly-typed-instances">Disable strongly-typed instances</a></h3>
<p>If you don’t want strongly-typed peripheral instances, enable the <code>nosync</code> feature.
<code>nosync</code> disables all synchronised access functions, like <code>take()</code> and <code>release()</code>,
as well as all the types associated with that API. <code>nosync</code> requires direct, unsafe
access to peripherals. This is “C” mode, where you’re responsible for maintaining
synchronization. <code>nosync</code> is a negative feature; enabling the feature may cause other
dependencies to break, especially if they rely on owning strongly-typed instances.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">imxrt_ral::gpio</span>;
<span class="kw">use</span> <span class="ident">core::sync::atomic</span>::{<span class="ident">AtomicBool</span>, <span class="ident">Ordering</span>};

<span class="kw">struct</span> <span class="ident">GpioDriver</span> {
    <span class="ident">gpio</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">gpio::RegisterBlock</span>,
}

<span class="kw">impl</span> <span class="ident">GpioDriver</span> {
    <span class="doccomment">/// Acquire the GPIO1 driver, if it exists</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">gpio1</span>() -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">GpioDriver</span><span class="op">&gt;</span> {
        <span class="kw">static</span> <span class="ident">TAKEN</span>: <span class="ident">AtomicBool</span> <span class="op">=</span> <span class="ident">AtomicBool::new</span>(<span class="bool-val">false</span>);
        <span class="kw">if</span> <span class="op">!</span><span class="ident">TAKEN</span>.<span class="ident">swap</span>(<span class="bool-val">true</span>, <span class="ident">Ordering::SeqCst</span>) {
            <span class="comment">// Safety: GPIO1 pointes to static memory</span>
            <span class="prelude-val">Some</span>(<span class="kw">unsafe</span> { <span class="self">Self</span> { <span class="ident">gpio</span>: <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">gpio::GPIO1</span> } })
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        }
    }
}

<span class="kw">let</span> <span class="ident">gpio1</span> <span class="op">=</span> <span class="ident">GpioDriver::gpio1</span>().<span class="ident">unwrap</span>();
<span class="macro">assert!</span>(<span class="ident">GpioDriver::gpio1</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="imxrt_ral" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>